<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.damon8.cn/"/>
  <updated>2021-11-16T07:28:28.662Z</updated>
  <id>http://www.damon8.cn/</id>
  
  <author>
    <name>码疯窝在香嗝喱辣</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WebClient 增删改查</title>
    <link href="http://www.damon8.cn/2021/11/16/webclient-restful-api/"/>
    <id>http://www.damon8.cn/2021/11/16/webclient-restful-api/</id>
    <published>2021-11-16T07:27:25.000Z</published>
    <updated>2021-11-16T07:28:28.662Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Webclient-使用场景"><a href="#Webclient-使用场景" class="headerlink" title="Webclient 使用场景"></a>Webclient 使用场景</h2><p>前面介绍了 什么是阻塞、非阻塞，以及对应的客户端库，非阻塞在<strong>高并发</strong>、<strong>内存不足</strong>的情况下，还是一个不错的选择，当被访问者的服务响应很慢、或者自己在请求对方时，并不是很想知道对方返回的结果，都可以使用 Webclient 来进行非阻塞式请求。下面紧接着讲非阻塞客户端库 Webclient如何实现增删改查。</p><h2 id="Webclient-的RestFul-请求"><a href="#Webclient-的RestFul-请求" class="headerlink" title="Webclient 的RestFul 请求"></a>Webclient 的RestFul 请求</h2><h3 id="一、RESTful风格与HTTP-method"><a href="#一、RESTful风格与HTTP-method" class="headerlink" title="一、RESTful风格与HTTP method"></a>一、RESTful风格与HTTP method</h3><p>熟悉RESTful风格的朋友，应该了解RESTful风格API使用HTTP method表达对资源的操作。</p><table><thead><tr><th>常用HTTP方法</th><th>RESTful风格语义（操作）</th></tr></thead><tbody><tr><td>POST</td><td>新增、提交数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>PUT</td><td>更新、修改数据</td></tr><tr><td>GET</td><td>查询、获取数据</td></tr></tbody></table><p>下面我们就来讲下这些资源场景的使用方式。</p><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>POST等常见使用如下方法：</p><ul><li>block()阻塞获取响应结果的方法</li><li>subscribe()非阻塞异步结果订阅方法</li><li>retrieve(）获取HTTP响应体，exchange()除了获取HTTP响应体，还可以获取HTTP 状态码、headers、cookies等HTTP报文信息。</li><li>使用Mono接收单个对象的响应结果，使用Flux接收集合类对象的响应结果。</li><li>占位符语法传参方式</li></ul><h4 id="模拟表单提交数据"><a href="#模拟表单提交数据" class="headerlink" title="模拟表单提交数据"></a>模拟表单提交数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void testFormSubmit() &#123;</span><br><span class="line"></span><br><span class="line">    MultiValueMap&lt;String, String&gt; map &#x3D; new LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">    map.add(&quot;username&quot;, &quot;damoin&quot;);</span><br><span class="line">    map.add(&quot;UID&quot;, &quot;11024319902323&quot;);</span><br><span class="line"></span><br><span class="line">    Mono&lt;String&gt; mono &#x3D; webClientBuilder.build().post()</span><br><span class="line">                    .uri(&quot;http:&#x2F;&#x2F;rest-service-service&#x2F;add&quot;)</span><br><span class="line">                    .contentType(MediaType.APPLICATION_FORM_URLENCODED)</span><br><span class="line">                    .body(BodyInserters.fromFormData(map))</span><br><span class="line">                    .retrieve()</span><br><span class="line">                    .bodyToMono(String.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(mono.block());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，在提交表单的时候，需要说明表单数据类型，以及表单的具体数据，我们知道：常见的表单数据都是以map形式存在，在请求后要想获取响应返回，可以使用<code>retrieve</code>函数，同时可以借助Mono来对返回结果进行类型转换，如果是单个对象使用Mono，如果是集合流，可以使用Flux。同时，如果想要阻塞拿到返回结果的信息，可以通过<code>block</code>函数来处理。</p><h5 id="传输对象以JSON数据形式发送"><a href="#传输对象以JSON数据形式发送" class="headerlink" title="传输对象以JSON数据形式发送"></a>传输对象以JSON数据形式发送</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void testPostJson() &#123;</span><br><span class="line">    SysUser user &#x3D; new SysUser();</span><br><span class="line">    user.setRealName(&quot;dwdwdww&quot;);</span><br><span class="line">    user.setPhone(&quot;32323232&quot;);</span><br><span class="line">    Mono&lt;String&gt; mono &#x3D; webClientBuilder.build()</span><br><span class="line">                    .post()</span><br><span class="line">                    .uri(&quot;http:&#x2F;&#x2F;rest-service-service&#x2F;add&quot;)</span><br><span class="line">                    .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                    .bodyValue(user)</span><br><span class="line">                    .retrieve()</span><br><span class="line">                    .bodyToMono(String.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(mono.block());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里将传输的数据以Json格式来进行发送给对方，同样需要注明数据类型<code>MediaType.APPLICATION_JSON</code>，其它的函数都是跟上面一样。</p><h5 id="模拟向服务端发送JSON字符串数据"><a href="#模拟向服务端发送JSON字符串数据" class="headerlink" title="模拟向服务端发送JSON字符串数据"></a>模拟向服务端发送JSON字符串数据</h5><p>如果有时候对方需要的不是一个JSON对象，可能是需要一个JSON字符串，那怎么办呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void testPostJsonStr() &#123;</span><br><span class="line">    String jsonStr &#x3D; &quot;&#123;\&quot;realName\&quot;: \&quot;damon\&quot;,\&quot;phone\&quot;: \&quot;32323232\&quot;&#125;&quot;;</span><br><span class="line">    Mono&lt;String&gt; mono &#x3D; webClientBuilder.build().post()</span><br><span class="line">                    .uri(&quot;http:&#x2F;&#x2F;rest-service-service&#x2F;add&quot;)</span><br><span class="line">                    .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                    .body(BodyInserters.fromValue(jsonStr))</span><br><span class="line">                    .retrieve()</span><br><span class="line">                    .bodyToMono(String.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 输出结果</span><br><span class="line">    System.out.println(mono.block());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，数据类型同样还是 <code>MediaType.APPLICATION_JSON</code>，但传输的是JSON串。</p><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><p>使用 DELETE方法去删除资源，删除一个已经存在的资源，使用webClient的delete()方法。该方法会向URL代表的资源发送一个HTTP DELETE方法请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void testDelete()  &#123;</span><br><span class="line">  webClientBuilder.build()</span><br><span class="line">  .delete()</span><br><span class="line">  .uri(&quot;http:&#x2F;&#x2F;rest-service-service&#x2F;1&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h4><p>修改一个已经存在的资源，使用webClient的put()方法。该方法会向URL代表的资源发送一个HTTP PUT方法请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void testPut() &#123;</span><br><span class="line">        SysUser user &#x3D; new SysUser();</span><br><span class="line">        user.setRealName(&quot;dwdwdww&quot;);</span><br><span class="line">        user.setPhone(&quot;32323232&quot;);</span><br><span class="line"></span><br><span class="line">        Mono&lt;String&gt; mono &#x3D; webClientBuilder.build()</span><br><span class="line">                        .put()</span><br><span class="line">                        .uri(&quot;http:&#x2F;&#x2F;rest-service-service&#x2F;1&quot;)</span><br><span class="line">                        .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                        .bodyValue(user).retrieve().bodyToMono(String.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(mono.block());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里以传json数据的格式来进行发送修改，修改完成后返回修改结果信息。</p><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p>新增完数据后，我们来查看数据对象，如果是一个对象数据的话，可以使用 Mono：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(value &#x3D; &quot;&#x2F;getClientResByWebClient2&quot;, produces &#x3D; MediaType.TEXT_EVENT_STREAM_VALUE)</span><br><span class="line">    public Mono&lt;String&gt; getClientResByWebClient2() throws Exception &#123;</span><br><span class="line">             Mono&lt;String&gt; resp &#x3D; webClientBuilder.build()</span><br><span class="line">             .get()</span><br><span class="line">             .uri(&quot;http:&#x2F;&#x2F;diff-ns-service-service&#x2F;all&#x2F;getService&quot;)</span><br><span class="line">             .retrieve().bodyToMono(String.class);</span><br><span class="line">             &#x2F;&#x2F;.exchange().flatMap(clientResp -&gt; clientResp.bodyToMono(String.class));</span><br><span class="line"></span><br><span class="line">            resp.subscribe(body -&gt; System.out.println(body));</span><br><span class="line">            return resp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果是多个对象，那就是集合集，此时需要用Flux来获取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void testFlux() &#123;</span><br><span class="line">    Flux&lt;SysUser&gt; flux &#x3D; webClientBuilder.build()</span><br><span class="line">              .get()</span><br><span class="line">              .uri(&quot;http:&#x2F;&#x2F;diff-ns-service-service&#x2F;all&quot;)</span><br><span class="line">              .retrieve()</span><br><span class="line">              .bodyToFlux(SysUser.class);</span><br><span class="line">      List&lt;SysUser&gt; li &#x3D; flux.collectList().block();</span><br><span class="line">      assert li !&#x3D; null;</span><br><span class="line">      System.out.println(&quot;li集合元素数量：&quot; + li.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p><span class="suffix" style="display: none;"></span></h6></p><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码:</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;">https://gitee.com/damon_one/spring-cloud-k8s</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">程序猿Damon</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://www.damon8.cn" style="text-decoration: none" title="">Damon | Micro-Service | Containerization | DevOps</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：程序猿Damon"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Unit one --><p><ins class="adsbygoogle"     style="display:inline-block;text-align:center;width:880px;height:150px"     data-ad-client="ca-pub-1354758384344627"     data-ad-slot="8964778819"></ins></p><script>    (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>阻塞与非阻塞式客户端</title>
    <link href="http://www.damon8.cn/2021/11/15/non-block-client/"/>
    <id>http://www.damon8.cn/2021/11/15/non-block-client/</id>
    <published>2021-11-15T03:42:07.000Z</published>
    <updated>2021-11-15T07:15:44.669Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>阻塞是指程序会一直等待该进程或线程完成当前任务期间不做其它事情。而非阻塞，是指当前线程在处理一些事情的同时，还可以处理其它的事情，并不需要等待当前事件完成才执行其它事件。</p><h2 id="阻塞与非阻塞客户端"><a href="#阻塞与非阻塞客户端" class="headerlink" title="阻塞与非阻塞客户端"></a>阻塞与非阻塞客户端</h2><p>对于请求当中，我们有需要借助一些请求封装的客户端，这里可以分为两大类：阻塞式、非阻塞式。</p><p>阻塞式客户端以常见的 <code>RestTemplate</code>为例，这是一种常见的客户端请求封装，要创建负载平衡<code>RestTemplate</code>，下面看看其Bean：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@LoadBalanced</span><br><span class="line">@Bean</span><br><span class="line">public RestTemplate restTemplate() &#123;</span><br><span class="line">    return new RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在底层，RestTemplate 使用了基于每个请求对应一个线程模型（thread-per-request）的 Java Servlet API。在阻塞客户端中，这意味着，直到 Web 客户端收到响应之前，线程都将一直被阻塞下去。而阻塞带来的问题是：每个线程都消耗了一定的内存和 CPU 周期。</p><p>如果在并发下，等待结果的请求迟早都会堆积起来。这样，程序将创建很多线程，这些线程将耗尽线程池或占用所有可用内存。由于频繁的 CPU 线程切换，我们还会遇到性能下降的问题。</p><p>这在 Spring5 中，提出了一种新的客户端抽象：反应式客户端 <code>WebClient</code>，而 WebClient 使用了 <code>Spring Reactive Framework</code> 所提供的异步非阻塞解决方案。所以，当 <code>RestTemplate</code>创建一个个新的线程时，Webclient是为其创建类似task的线程，并且在底层，<br>Reactive 框架将对这些 task 进行排队，并且仅在适当的响应可用时再执行它们。WebClient 是 Spring WebFlux 库的一部分。所以，我们还可以使用了流畅的函数式 API 编程，并将响应类型作为声明来进行组合。如果需要使用 WebClient，同样可以创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@LoadBalanced</span><br><span class="line">public WebClient.Builder loadBalancedWebClientBuilder() &#123;</span><br><span class="line">    return WebClient.builder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>假设这里有一个响应非常慢的服务rest-service，我们分别用阻塞式、非阻塞式客户端来测试一下。</p><h4 id="阻塞式"><a href="#阻塞式" class="headerlink" title="阻塞式"></a>阻塞式</h4><p>我们利用 <code>RestTemplate</code>实现阻塞式请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@LoadBalanced</span><br><span class="line">public RestTemplate restTemplate() &#123;</span><br><span class="line">return new RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;&#x2F;getClientRes&quot;)</span><br><span class="line">public Response&lt;Object&gt; getClientRes() throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;block api enter&quot;);</span><br><span class="line">HttpHeaders headers &#x3D; new HttpHeaders();</span><br><span class="line">MediaType type &#x3D; MediaType.parseMediaType(&quot;application&#x2F;json; charset&#x3D;UTF-8&quot;);</span><br><span class="line">headers.setContentType(type);</span><br><span class="line">headers.add(&quot;Accept&quot;, MediaType.APPLICATION_JSON.toString());</span><br><span class="line">HttpEntity&lt;String&gt; formEntity &#x3D; new HttpEntity&lt;String&gt;(null, headers);</span><br><span class="line">String body &#x3D; &quot;&quot;;</span><br><span class="line">try &#123;</span><br><span class="line">ResponseEntity&lt;String&gt; responseEntity &#x3D; restTemplate.exchange(&quot;http:&#x2F;&#x2F;diff-ns-service-service&#x2F;getservicedetail?servicename&#x3D;cas-server-service&quot;,</span><br><span class="line">HttpMethod.GET, formEntity, String.class);</span><br><span class="line">System.out.println(JSON.toJSONString(responseEntity));</span><br><span class="line">if (responseEntity.getStatusCodeValue() &#x3D;&#x3D; 200) &#123;</span><br><span class="line">    System.out.println(&quot;block api exit&quot;);</span><br><span class="line">return Response.ok(responseEntity.getBody());</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;block api failed, exit&quot;);</span><br><span class="line">return Response.error(&quot;failed&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在启动服务请求后，发现其打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">block api enter</span><br><span class="line"></span><br><span class="line">[&#123;&quot;host&quot;:&quot;10.244.0.55&quot;,&quot;instanceId&quot;:&quot;71f96128-3bb1-11ec-97e6-ac1f6ba00d36&quot;,&quot;metadata&quot;:&#123;&quot;kubectl.kubernetes.io&#x2F;last-applied-configuration&quot;:&quot;&#123;\&quot;apiVersion\&quot;:\&quot;v1\&quot;,\&quot;kind\&quot;:\&quot;Service\&quot;,\&quot;metadata\&quot;:&#123;\&quot;annotations\&quot;:&#123;&#125;,\&quot;name\&quot;:\&quot;cas-server-service\&quot;,\&quot;namespace\&quot;:\&quot;system-server\&quot;&#125;,\&quot;spec\&quot;:&#123;\&quot;ports\&quot;:[&#123;\&quot;name\&quot;:\&quot;cas-server01\&quot;,\&quot;port\&quot;:2000,\&quot;targetPort\&quot;:\&quot;cas-server01\&quot;&#125;],\&quot;selector\&quot;:&#123;\&quot;app\&quot;:\&quot;cas-server\&quot;&#125;&#125;&#125;\n&quot;,&quot;port.cas-server01&quot;:&quot;2000&quot;,&quot;k8s_namespace&quot;:&quot;system-server&quot;&#125;,&quot;namespace&quot;:&quot;system-server&quot;,&quot;port&quot;:2000,&quot;scheme&quot;:&quot;http&quot;,&quot;secure&quot;:false,&quot;serviceId&quot;:&quot;cas-server-service&quot;,&quot;uri&quot;:&quot;http:&#x2F;&#x2F;10.244.0.55:2000&quot;&#125;,&#123;&quot;host&quot;:&quot;10.244.0.56&quot;,&quot;instanceId&quot;:&quot;71fc1c14-3bb1-11ec-97e6-ac1f6ba00d36&quot;,&quot;metadata&quot;:&#123;&quot;$ref&quot;:&quot;$[0].metadata&quot;&#125;,&quot;namespace&quot;:&quot;system-server&quot;,&quot;port&quot;:2000,&quot;scheme&quot;:&quot;http&quot;,&quot;secure&quot;:false,&quot;serviceId&quot;:&quot;cas-server-service&quot;,&quot;uri&quot;:&quot;http:&#x2F;&#x2F;10.244.0.56:2000&quot;&#125;]</span><br><span class="line"></span><br><span class="line">block api exit</span><br></pre></td></tr></table></figure><h4 id="非阻塞式"><a href="#非阻塞式" class="headerlink" title="非阻塞式"></a>非阻塞式</h4><p>上面的打印符合我们的逾期，接下来我们来看看非阻塞、反应式客户端请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@LoadBalanced</span><br><span class="line">public WebClient.Builder loadBalancedWebClientBuilder() &#123;</span><br><span class="line">    return WebClient.builder();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@GetMapping(value &#x3D; &quot;&#x2F;getClientResByWebClient&quot;, produces &#x3D; MediaType.TEXT_EVENT_STREAM_VALUE)</span><br><span class="line">public Mono&lt;String&gt; getClientResByWebClient() throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;no block api enter&quot;);</span><br><span class="line">Mono&lt;String&gt; resp &#x3D; webClientBuilder.build().get()</span><br><span class="line">.uri(&quot;http:&#x2F;&#x2F;diff-ns-service-service&#x2F;getservicedetail?servicename&#x3D;cas-server-service&quot;).retrieve()</span><br><span class="line">.bodyToMono(String.class);</span><br><span class="line">resp.subscribe(body -&gt; System.out.println(body.toString()));</span><br><span class="line">System.out.println(&quot;no block api exit&quot;);</span><br><span class="line">return resp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完代码后，看打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">no block api enter</span><br><span class="line"></span><br><span class="line">no block api exit</span><br><span class="line"></span><br><span class="line">[&#123;&quot;host&quot;:&quot;10.244.0.55&quot;,&quot;instanceId&quot;:&quot;71f96128-3bb1-11ec-97e6-ac1f6ba00d36&quot;,&quot;metadata&quot;:&#123;&quot;kubectl.kubernetes.io&#x2F;last-applied-configuration&quot;:&quot;&#123;\&quot;apiVersion\&quot;:\&quot;v1\&quot;,\&quot;kind\&quot;:\&quot;Service\&quot;,\&quot;metadata\&quot;:&#123;\&quot;annotations\&quot;:&#123;&#125;,\&quot;name\&quot;:\&quot;cas-server-service\&quot;,\&quot;namespace\&quot;:\&quot;system-server\&quot;&#125;,\&quot;spec\&quot;:&#123;\&quot;ports\&quot;:[&#123;\&quot;name\&quot;:\&quot;cas-server01\&quot;,\&quot;port\&quot;:2000,\&quot;targetPort\&quot;:\&quot;cas-server01\&quot;&#125;],\&quot;selector\&quot;:&#123;\&quot;app\&quot;:\&quot;cas-server\&quot;&#125;&#125;&#125;\n&quot;,&quot;port.cas-server01&quot;:&quot;2000&quot;,&quot;k8s_namespace&quot;:&quot;system-server&quot;&#125;,&quot;namespace&quot;:&quot;system-server&quot;,&quot;port&quot;:2000,&quot;scheme&quot;:&quot;http&quot;,&quot;secure&quot;:false,&quot;serviceId&quot;:&quot;cas-server-service&quot;,&quot;uri&quot;:&quot;http:&#x2F;&#x2F;10.244.0.55:2000&quot;&#125;,&#123;&quot;host&quot;:&quot;10.244.0.56&quot;,&quot;instanceId&quot;:&quot;71fc1c14-3bb1-11ec-97e6-ac1f6ba00d36&quot;,&quot;metadata&quot;:&#123;&quot;$ref&quot;:&quot;$[0].metadata&quot;&#125;,&quot;namespace&quot;:&quot;system-server&quot;,&quot;port&quot;:2000,&quot;scheme&quot;:&quot;http&quot;,&quot;secure&quot;:false,&quot;serviceId&quot;:&quot;cas-server-service&quot;,&quot;uri&quot;:&quot;http:&#x2F;&#x2F;10.244.0.56:2000&quot;&#125;]</span><br></pre></td></tr></table></figure><p>在本例中，WebClient 返回一个 Mono 生产者后完成方法的执行。如果一旦结果可用，发布者将开始向其订阅者发送数据。调用这个API的客户端（浏览器）也将订阅返回的 Mono 对象。</p><h4 id="阻塞式转非阻塞式"><a href="#阻塞式转非阻塞式" class="headerlink" title="阻塞式转非阻塞式"></a>阻塞式转非阻塞式</h4><p>可以将前面的阻塞式请求，直接转为非阻塞请求，前提是你使用的是 Spring5，此时，可以直接这样来写，贴代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;hello&quot;)</span><br><span class="line">public Mono&lt;String&gt; hello() &#123;</span><br><span class="line">    return Mono.fromCallable(() -&gt; restTemplate.getForObject(&quot;http:&#x2F;&#x2F;diff-ns-service-service&#x2F;all&#x2F;getService&quot;, String.class))</span><br><span class="line">            .subscribeOn(Schedulers.elastic());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样后，在请求访问时，直接返回了提供者服务返回的信息体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;result&quot;:&#123;&quot;status&quot;:200,&quot;code&quot;:0,&quot;msg&quot;:&quot;success&quot;&#125;,&quot;data&quot;:[&#123;&quot;host&quot;:&quot;10.244.0.55&quot;,&quot;instanceId&quot;:&quot;71f96128-3bb1-11ec-97e6-ac1f6ba00d36&quot;,&quot;metadata&quot;:&#123;&quot;kubectl.kubernetes.io&#x2F;last-applied-configuration&quot;:&quot;&#123;\&quot;apiVersion\&quot;:\&quot;v1\&quot;,\&quot;kind\&quot;:\&quot;Service\&quot;,\&quot;metadata\&quot;:&#123;\&quot;annotations\&quot;:&#123;&#125;,\&quot;name\&quot;:\&quot;cas-server-service\&quot;,\&quot;namespace\&quot;:\&quot;system-server\&quot;&#125;,\&quot;spec\&quot;:&#123;\&quot;ports\&quot;:[&#123;\&quot;name\&quot;:\&quot;cas-server01\&quot;,\&quot;port\&quot;:2000,\&quot;targetPort\&quot;:\&quot;cas-server01\&quot;&#125;],\&quot;selector\&quot;:&#123;\&quot;app\&quot;:\&quot;cas-server\&quot;&#125;&#125;&#125;\n&quot;,&quot;port.cas-server01&quot;:&quot;2000&quot;,&quot;k8s_namespace&quot;:&quot;system-server&quot;&#125;,&quot;namespace&quot;:&quot;system-server&quot;,&quot;port&quot;:2000,&quot;scheme&quot;:&quot;http&quot;,&quot;secure&quot;:false,&quot;serviceId&quot;:&quot;cas-server-service&quot;,&quot;uri&quot;:&quot;http:&#x2F;&#x2F;10.244.0.55:2000&quot;&#125;,&#123;&quot;host&quot;:&quot;10.244.0.56&quot;,&quot;instanceId&quot;:&quot;71fc1c14-3bb1-11ec-97e6-ac1f6ba00d36&quot;,&quot;metadata&quot;:&#123;&quot;$ref&quot;:&quot;$[0].metadata&quot;&#125;,&quot;namespace&quot;:&quot;system-server&quot;,&quot;port&quot;:2000,&quot;scheme&quot;:&quot;http&quot;,&quot;secure&quot;:false,&quot;serviceId&quot;:&quot;cas-server-service&quot;,&quot;uri&quot;:&quot;http:&#x2F;&#x2F;10.244.0.56:2000&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，请求时，需要直接返回服务提供者的标准信息体，不能再作二次封装返回，否则，只能拿到信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;result&quot;:&#123;&quot;status&quot;:200,&quot;code&quot;:0,&quot;msg&quot;:&quot;success&quot;&#125;,&quot;data&quot;:&#123;&quot;scanAvailable&quot;:true&#125;&#125;</span><br></pre></td></tr></table></figure><p>表示本次 callable 为true，但这不是我们需要的信息，我们还是需要其本身返回的业务数据。所以需要提供者的返回标准化，因为直接将信息返回给可接收的浏览器等前端。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在大部分场景下， <code>RestTemplate</code> 还是继续被使用的，但有些场景下，反应式非阻塞请求还是必须的，系统资源要少得多。<code>WebClient</code>不失为是一个更好的选择。</p><br><br><p><span class="suffix" style="display: none;"></span></h6></p><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码:</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;">https://gitee.com/damon_one/spring-cloud-k8s</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">程序猿Damon</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://www.damon8.cn" style="text-decoration: none" title="">Damon | Micro-Service | Containerization | DevOps</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：程序猿Damon"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Unit one --><p><ins class="adsbygoogle"     style="display:inline-block;text-align:center;width:880px;height:150px"     data-ad-client="ca-pub-1354758384344627"     data-ad-slot="8964778819"></ins></p><script>    (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>注意了，ribbon将被替换</title>
    <link href="http://www.damon8.cn/2021/11/15/spring-cloud-loadbalancer/"/>
    <id>http://www.damon8.cn/2021/11/15/spring-cloud-loadbalancer/</id>
    <published>2021-11-15T03:39:19.000Z</published>
    <updated>2021-11-15T03:41:09.613Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="Ribbon"><a href="#Ribbon" class="headerlink" title="- Ribbon"></a>- Ribbon</h3><p>Ribbon 是由 Netflix 发布的负载均衡器，它有助于控制 HTTP 和 TCP 的客户端的行为。Ribbon 属于客户端负载均衡。大家都知道，在我们最早使用 Springcloud 微服务架构时，就是使用 Netflix 公司的荣誉出品：<code>https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/</code>。但可惜的是，Eureka 早就正式被官方废弃，不再更新了。这也许是为了更好的统一架构。</p><h3 id="Spring-cloud-loadbalancer"><a href="#Spring-cloud-loadbalancer" class="headerlink" title="- Spring-cloud-loadbalancer"></a>- Spring-cloud-loadbalancer</h3><p>Spring-cloud-loadbalancer，是官方正式推出的一款新负载均衡利器。早在 2017 年 spring 开始尝试开发<code>spring-cloud-loadbalancer</code> 替代 ribbon，项目托管在 <a href="https://github.com/spring-cloud-incubator/spring-cloud-loadbalancer" target="_blank" rel="noopener">spring-cloud-incubator 孵化器</a>，而后，经过一段时间，突然把此项目标记成归档迁移到<a href="https://github.com/spring-cloud/spring-cloud-commons" target="_blank" rel="noopener">spring-cloud-commons</a>，说明官方在做统一公共基础架构的决心在一步步前进。</p><p>早在 <a href="https://spring.io/blog/2019/08/19/spring-cloud-hoxton-m2-released" target="_blank" rel="noopener">Spring Cloud Hoxton.M2</a>，第一个整合<code>spring-cloud-loadbalancer</code>来替换老的 ribbon:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Spring Cloud Hoxton.M2 is the first release containing both blocking and non-blocking load balancer client implementations as an alternative to Netflix Ribbon which has entered maintenance mode.</span><br><span class="line"></span><br><span class="line">To use the new &#96;BlockingLoadBalancerClient&#96; with a &#96;RestTemplate&#96; you will need to include &#96;org.springframework.cloud:spring-cloud-loadbalancer&#96; on your application’s classpath. The same dependency can be used in a reactive application when using &#96;@LoadBalanced WebClient.Builder&#96; - the only difference is that Spring Cloud will auto-configure a &#96;ReactorLoadBalancerExchangeFilterFunction&#96; instance. See the [documentation](https:&#x2F;&#x2F;cloud.spring.io&#x2F;spring-cloud-static&#x2F;spring-cloud-commons&#x2F;2.2.0.M2&#x2F;reference&#x2F;html&#x2F;#_spring_resttemplate_as_a_load_balancer_client) for additional information. The new &#96;ReactorLoadBalancerExchangeFilterFunction&#96; can also be autowired and passed directly to &#96;WebClient.Builder&#96; (see the [documentation](https:&#x2F;&#x2F;cloud.spring.io&#x2F;spring-cloud-commons&#x2F;reference&#x2F;html&#x2F;#webflux-with-reactive-loadbalancer)). For all these features, [Project Reactor](https:&#x2F;&#x2F;projectreactor.io&#x2F;)-based &#96;RoundRobinLoadBalancer&#96; is used underneath.</span><br></pre></td></tr></table></figure><p>从这段原文可以看到，目前只支持<code>BlockingLoadBalancerClient</code>，同样是基于 <code>RestTemplate</code>。我们知道 ribbon 也是基于<code>RestTemplate</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@LoadBalanced</span><br><span class="line">@Bean</span><br><span class="line">public RestTemplate restTemplate() &#123;</span><br><span class="line">        SimpleClientHttpRequestFactory requestFactory &#x3D; new SimpleClientHttpRequestFactory();</span><br><span class="line">        requestFactory.setReadTimeout(env.getProperty(&quot;client.http.request.readTimeout&quot;, Integer.class, 15000));</span><br><span class="line">        requestFactory.setConnectTimeout(env.getProperty(&quot;client.http.request.connectTimeout&quot;, Integer.class, 3000));</span><br><span class="line">        RestTemplate rt &#x3D; new RestTemplate(requestFactory);</span><br><span class="line">        return rt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但对于配置，ribbon 显然还是较老练：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">backend:</span><br><span class="line">  ribbon:</span><br><span class="line">    client:</span><br><span class="line">      enabled: true</span><br><span class="line">    ServerListRefreshInterval: 5000</span><br><span class="line"></span><br><span class="line">ribbon:</span><br><span class="line">  ConnectTimeout: 3000</span><br><span class="line">  ReadTimeout: 1000</span><br><span class="line">  eager-load:</span><br><span class="line">    enabled: true</span><br><span class="line">    clients: cas-server,customer-server</span><br><span class="line">  MaxAutoRetries: 2</span><br><span class="line">  MaxAutoRetriesNextServer: 3</span><br><span class="line">  OkToRetryOnAllOperations: true</span><br><span class="line">  NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule</span><br></pre></td></tr></table></figure><p>可以多维度配置：超时、刷新服务列表、重试机制等。</p><p>但对于<code>spring-cloud-loadbalancer</code>，可以没有那么好，毕竟是刚养大的崽。但 Spring Cloud Hoxton 版本中第一次引入同时支持阻塞式与非阻塞式的负载均衡器<code>spring-cloud-loadbalancer</code>来作为已经进入维护状态的 Netflix Ribbon。接下来，我们实战看看如何使用。</p><h2 id="实战spring-cloud-loadbalancer"><a href="#实战spring-cloud-loadbalancer" class="headerlink" title="实战spring-cloud-loadbalancer"></a>实战<code>spring-cloud-loadbalancer</code></h2><p>在使用时，我们从原文中了解到，只需要引入<code>org.springframework.cloud:spring-cloud-loadbalancer</code>依赖，就可以将新的<code>BlockingLoadBalancerClient</code>与<code>RestTemplate</code>一起使用了。同时，该依赖的引入也将支持 Reactive 应用，跟其他使用一样，只需要使用<code>@LoadBalanced</code>来修饰<code>WebClient.Builder</code>即可。</p><p>我们先来引入依赖，这里用的是基于 Nacos 的服务注册与发现，我们先来注入依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;exclusion&gt;</span><br><span class="line">    &lt;&#x2F;exclusions&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-loadbalancer&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>在这里，我们使用到新的负载均衡器，需要排除 ribbon 依赖，不然 loadbalancer 无效。同时，我们需要禁用 ribbon 的负载均衡能力：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    loadbalancer:</span><br><span class="line">      ribbon:</span><br><span class="line">        enabled: false</span><br></pre></td></tr></table></figure><p>禁用之后，我们在结合<code>RestTemplate</code>使用，并使用<code>@LoadBalanced</code>来修饰<code>WebClient.Builder</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@LoadBalanced&#x2F;&#x2F;就不能用ip等形式来请求其他服务</span><br><span class="line">@Bean</span><br><span class="line">public RestTemplate restTemplate() &#123;</span><br><span class="line">        SimpleClientHttpRequestFactory requestFactory &#x3D; new SimpleClientHttpRequestFactory();</span><br><span class="line">        requestFactory.setReadTimeout(env.getProperty(&quot;client.http.request.readTimeout&quot;, Integer.class, 15000));</span><br><span class="line">        requestFactory.setConnectTimeout(env.getProperty(&quot;client.http.request.connectTimeout&quot;, Integer.class, 3000));</span><br><span class="line">        RestTemplate rt &#x3D; new RestTemplate(requestFactory);</span><br><span class="line">        return rt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个细心的同学可以开始看到：这个和 Ribbon 的配置是一样样的。此时，我们启动服务提供者、消费者即可测试。这里就不再展示了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>按照官方的孵化，新的负载均衡器将会取代老的 ribbon，毕竟引入了新的功能：<strong>Reactive</strong>，加入了对其的大力支持。这在性能方面有所提升。</p><p>同时，现在<code>spring-cloud-loadbalancer</code>还是存在一定局限的，比如：</p><ul><li>ribbon 提供几种默认的负载均衡策略</li><li>目前<code>spring-cloud-loadbalancer</code> 仅支持重试操作的配置</li><li>ribbon 支持超时、懒加载处理、重试及其和 hystrix 整合高级属性等</li></ul><p>在 Spring-cloud 体系中，大部分范围还是老实使用 Ribbon，但基于 spring-cloud-k8s，可能需要使用基于<code>spring-cloud-starter-kubernetes-loadbalancer</code>。因为在前面实践过，基于 Ribbon 的 LB，无法跨命名空间来实现服务间的相互访问。</p><br><br><p><span class="suffix" style="display: none;"></span></h6></p><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码:</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;">https://gitee.com/damon_one/spring-cloud-k8s</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">程序猿Damon</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://www.damon8.cn" style="text-decoration: none" title="">Damon | Micro-Service | Containerization | DevOps</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：程序猿Damon"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Unit one --><p><ins class="adsbygoogle"     style="display:inline-block;text-align:center;width:880px;height:150px"     data-ad-client="ca-pub-1354758384344627"     data-ad-slot="8964778819"></ins></p><script>    (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>k8s 集群从0到1</title>
    <link href="http://www.damon8.cn/2021/11/12/kubeadm-install-k8s/"/>
    <id>http://www.damon8.cn/2021/11/12/kubeadm-install-k8s/</id>
    <published>2021-11-12T02:08:01.000Z</published>
    <updated>2021-11-12T02:22:46.432Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp; 本文只讲 docker + kubernetes 集群的 kubeadm 部署方式，不讲 k8s 各组件工作原理。个人认为在学习 k8s 的过程中，先动手搭建起来一个测试集群，比一味的看书学原理要好得多，一边操作一边学习是比较有效率的。</p><p>&emsp;&emsp;使用 yum 安装 docker、 kubelet、 kubeadm 包的方式，会自动部署 service 文件及环境，相比二进制安装更简单一些。<a href="https://note.youdao.com/" target="_blank" rel="noopener">二进制安装</a>更复杂但是也更灵活一些，学习二进制安装有助于用户学习各部件工作原理，以及排错能力。下面先介绍比较简单的 yum 安装的方式。</p><h1 id="Yum-安装包部署k8s-集群流程"><a href="#Yum-安装包部署k8s-集群流程" class="headerlink" title="Yum 安装包部署k8s 集群流程"></a>Yum 安装包部署k8s 集群流程</h1><h2 id="一、准备工作-（所有节点）"><a href="#一、准备工作-（所有节点）" class="headerlink" title="一、准备工作 （所有节点）"></a>一、准备工作 （所有节点）</h2><ol><li><p>配置所有节点互通 ssh 免密（ssh-copy-id）</p></li><li><p>配置所有节点 /etc/hosts 文件统一记录所有机器 hostname 和ip。hosts 文件需要在新增节点时更新，在大型集群中最好通过 git 来同步所有机器。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-1 data]# cat /etc/hosts</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">192.168.63.131 k8s-master-1</span><br><span class="line">192.168.63.141 k8s-node-1</span><br><span class="line">192.168.63.142 k8s-node-2</span><br><span class="line">192.168.63.143 k8s-node-3</span><br></pre></td></tr></table></figure></li><li><p>ntp 时间同步，k8s 很多组件工作需要保证所有节点 时间一致。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum install -y ntpdate</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用公网 ntp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ntpdate us.pool.ntp.org</span></span><br><span class="line"></span><br><span class="line">时间不对的话确认系统时区</span><br><span class="line"><span class="meta">#</span><span class="bash"> ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br></pre></td></tr></table></figure></li><li><p>关闭 防火墙，selinux ，swap</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">测试环境</span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl stop firewalld</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl <span class="built_in">disable</span> firewalld</span></span><br><span class="line">正式环境（不允许关闭防火墙，保证默认规则为 ACCEPT ）</span><br><span class="line"><span class="meta">#</span><span class="bash"> iptables -L | grep Chain</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # setenforce 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/selinux/config</span></span><br><span class="line">SELINUX=disabled</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> swapoff -a</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 编辑/etc/fstab，注释掉包含swap的那一行即可，重启后可永久关闭</span></span></span><br></pre></td></tr></table></figure></li><li><p>修改必要的内核参数</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">二层的网桥在转发包时也会被iptables的FORWARD规则所过滤</span><br><span class="line">linux主机有多个网卡时一个网卡收到的信息是否能够传递给其他的网卡</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> modprobe br_netfilter</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/sysctl.d/k8s.conf</span></span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> sysctl -p /etc/sysctl.d/k8s.conf</span></span><br></pre></td></tr></table></figure></li><li><p>配置 yum 源装包。</p><ul><li><p>使用 docker-ce 官方 yum 源安装  docker-ce 软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一种：官方提供的脚本</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二种：手动添加源安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum remove docker \</span></span><br><span class="line">                 docker-client \</span><br><span class="line">                 docker-client-latest \</span><br><span class="line">                 docker-common \</span><br><span class="line">                 docker-latest \</span><br><span class="line">                 docker-latest-logrotate \</span><br><span class="line">                docker-logrotate \</span><br><span class="line">            docker-engine</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install -y yum-utils \</span></span><br><span class="line"> device-mapper-persistent-data \</span><br><span class="line"> lvm2</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum-config-manager \</span></span><br><span class="line">  --add-repo \</span><br><span class="line">  http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install docker-ce docker-ce-cli containerd.io</span></span><br><span class="line">指定版本</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install docker-ce-18.09.1 docker-ce-cli-18.09.1 containerd.io</span></span><br></pre></td></tr></table></figure><ul><li>使用 阿里云的 yum 源安装  kubelet kubeadm kubectl 软件包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-1 data]# cat /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">        http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line"></span><br><span class="line">[root@k8s-master-1 data]# yum install -y kubelet-1.15.6 kubeadm-1.15.6 kubectl-1.15.6</span><br></pre></td></tr></table></figure></li></ul></li><li><p>开启docker 服务</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl start docker ; systemctl <span class="built_in">enable</span> docker</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker run hello-world      测试docker 是否可用</span></span><br></pre></td></tr></table></figure></li><li><p>开启kubelet 服务</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl <span class="built_in">enable</span> kubelet ; systemctl start kubelet</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发现kubelet 启动报错，这是正常的，因为缺少证书，kubeadm 部署后，即可正常启动。</span></span><br></pre></td></tr></table></figure></li><li><p>确保 kubelet 和 docker 的 cgroup drive 一致，使用 systemd 作为initd 的发行版本，推荐使用systemd ，cgroup 管理更加稳定</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker info | grep -i cgroup</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/systemd/system/kubelet.service.d/10-kubeadm.conf</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 修改 docker</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/docker/daemon.json</span></span><br><span class="line">&#123;</span><br><span class="line"> "exec-opts":["native.cgroupdriver=systemd"]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 修改 kubelet</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sed -i <span class="string">"s/cgroup-driver=systemd/cgroup-driver=cgroupfs/g"</span> /etc/systemd/system/kubelet.service.d/10-kubeadm.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl daemon-reload</span></span><br></pre></td></tr></table></figure></li><li><p>提前准备镜像，kubeadm 工具部署集群时需要用到一些镜像，默认去墙外的网站拉取，如果你的机器不能访问墙外的世界，那就需要提前准备，并且把准备的镜像打上默认需要的版本的 tag， 学习的路上总是有一些障碍的，还好阿里的源为我们准备了这些镜像</p><ul><li><p>查看kubeadm 需要的所有镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-1 data]# kubeadm config images list --kubernetes-version=v1.16.2</span><br><span class="line">k8s.gcr.io/kube-apiserver:v1.16.2</span><br><span class="line">k8s.gcr.io/kube-controller-manager:v1.16.2</span><br><span class="line">k8s.gcr.io/kube-scheduler:v1.16.2</span><br><span class="line">k8s.gcr.io/kube-proxy:v1.16.2</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd:3.3.15-0</span><br><span class="line">k8s.gcr.io/coredns:1.6.2</span><br></pre></td></tr></table></figure></li><li><p>上面 k8s.gcr.io 的地址在墙外，我们换成阿里云地址就可以拉下来。registry.cn-hangzhou.aliyuncs.com/google_containers/kube-xxx:v1.16.2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubeadm config images list |sed -e 's/^/docker pull /g' -e 's#k8s.gcr.io#docker.io/registry.cn-hangzhou.aliyuncs.com/google_containers#g' |sh -x</span><br><span class="line">docker images |grep registry.cn-hangzhou.aliyuncs.com/google_containers |awk '&#123;print "docker tag ",$1":"$2,$1":"$2&#125;' |sed -e 's#docker.io/mirrorgooglecontainers#k8s.gcr.io#2' |sh -x</span><br><span class="line">docker images |grep registry.cn-hangzhou.aliyuncs.com/google_containers |awk '&#123;print "docker rmi ", $1":"$2&#125;' |sh -x</span><br><span class="line">docker pull coredns/coredns:1.2.2</span><br><span class="line">docker tag coredns/coredns:1.2.2 k8s.gcr.io/coredns:1.2.2</span><br><span class="line">docker rmi coredns/coredns:1.2.2</span><br></pre></td></tr></table></figure></li><li><p>如果我们的 k8s 版本在 1.13 以上 可以直接用 –image-repository 修改 kubeadm 拉取镜像的地址。</p><blockquote><p>kubeadm init –image-repository registry.aliyuncs.com/google_containers</p></blockquote></li></ul></li></ol><h2 id="二、部署-master-节点（master节点）"><a href="#二、部署-master-节点（master节点）" class="headerlink" title="二、部署 master 节点（master节点）"></a>二、部署 master 节点（master节点）</h2><ol><li><p>使用 kubeadm 初始化 k8s 集群 master 节点，可以看到 kubeadm 都做了那些工作。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-1 ~]# kubeadm init --kubernetes-version=v1.16.2 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.96.0.0/12；</span><br><span class="line">[init] Using Kubernetes version: v1.16.2</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">[WARNING SystemVerification]: this Docker version is not on the list of validated versions: 19.03.4. Latest validated version: 18.09</span><br><span class="line">[WARNING Hostname]: hostname "k8s-master-1" could not be reached</span><br><span class="line">[WARNING Hostname]: hostname "k8s-master-1": lookup k8s-master-1 on 192.168.63.2:53: server misbehaving</span><br><span class="line">[WARNING Service-Kubelet]: kubelet service is not enabled, please run 'systemctl enable kubelet.service'</span><br><span class="line">[preflight] Pulling images required for setting up a Kubernetes cluster</span><br><span class="line">[preflight] This might take a minute or two, depending on the speed of your internet connection</span><br><span class="line">[preflight] You can also perform this action in beforehand using 'kubeadm config images pull'</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"</span><br><span class="line">[kubelet-start] Activating the kubelet service</span><br><span class="line">[certs] Using certificateDir folder "/etc/kubernetes/pki"</span><br><span class="line">[certs] Generating "ca" certificate and key</span><br><span class="line">[certs] Generating "apiserver" certificate and key</span><br><span class="line">[certs] apiserver serving cert is signed for DNS names [k8s-master-1 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 192.168.63.131]</span><br><span class="line">[certs] Generating "apiserver-kubelet-client" certificate and key</span><br><span class="line">[certs] Generating "front-proxy-ca" certificate and key</span><br><span class="line">[certs] Generating "front-proxy-client" certificate and key</span><br><span class="line">[certs] Generating "etcd/ca" certificate and key</span><br><span class="line">[certs] Generating "etcd/server" certificate and key</span><br><span class="line">[certs] etcd/server serving cert is signed for DNS names [k8s-master-1 localhost] and IPs [192.168.63.131 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating "etcd/peer" certificate and key</span><br><span class="line">[certs] etcd/peer serving cert is signed for DNS names [k8s-master-1 localhost] and IPs [192.168.63.131 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating "etcd/healthcheck-client" certificate and key</span><br><span class="line">[certs] Generating "apiserver-etcd-client" certificate and key</span><br><span class="line">[certs] Generating "sa" key and public key</span><br><span class="line">[kubeconfig] Using kubeconfig folder "/etc/kubernetes"</span><br><span class="line">[kubeconfig] Writing "admin.conf" kubeconfig file</span><br><span class="line">[kubeconfig] Writing "kubelet.conf" kubeconfig file</span><br><span class="line">[kubeconfig] Writing "controller-manager.conf" kubeconfig file</span><br><span class="line">[kubeconfig] Writing "scheduler.conf" kubeconfig file</span><br><span class="line">[control-plane] Using manifest folder "/etc/kubernetes/manifests"</span><br><span class="line">[control-plane] Creating static Pod manifest for "kube-apiserver"</span><br><span class="line">[control-plane] Creating static Pod manifest for "kube-controller-manager"</span><br><span class="line">[control-plane] Creating static Pod manifest for "kube-scheduler"</span><br><span class="line">[etcd] Creating static Pod manifest for local etcd in "/etc/kubernetes/manifests"</span><br><span class="line">[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory "/etc/kubernetes/manifests". This can take up to 4m0s</span><br><span class="line">[apiclient] All control plane components are healthy after 22.511803 seconds</span><br><span class="line">[upload-config] Storing the configuration used in ConfigMap "kubeadm-config" in the "kube-system" Namespace</span><br><span class="line">[kubelet] Creating a ConfigMap "kubelet-config-1.16" in namespace kube-system with the configuration for the kubelets in the cluster</span><br><span class="line">[upload-certs] Skipping phase. Please see --upload-certs</span><br><span class="line">[mark-control-plane] Marking the node k8s-master-1 as control-plane by adding the label "node-role.kubernetes.io/master=''"</span><br><span class="line">[mark-control-plane] Marking the node k8s-master-1 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]</span><br><span class="line">[bootstrap-token] Using token: tacwl8.r9rybowvi486j94t</span><br><span class="line">[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster</span><br><span class="line">[bootstrap-token] Creating the "cluster-info" ConfigMap in the "kube-public" namespace</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 192.168.63.131:6443 --token tacwl8.r9rybowvi486j94t \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:83d9e155464739407fe5a782b41eac35c42fcba2a1e8c252066cd7e00eaf21ff</span><br></pre></td></tr></table></figure></li><li><p>初始化后根据 提示 完成 config 文件的配置，并且记住 kubeadm join 命令，以便于后续添加node 节点。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mkdir -p <span class="variable">$HOME</span>/.kube</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span></span><br></pre></td></tr></table></figure></li><li><p>部署网络插件,使用  flannel 或者 calico 需要自己选择。calico 需要配置rbac ，新版本已经集成到 calico.yaml文件中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span></span><br><span class="line">或</span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl apply -f https://docs.projectcalico.org/v3.9/manifests/calico-etcd.yaml</span></span><br><span class="line"></span><br><span class="line">如果没有关闭防火墙需要为calico 打开端口</span><br><span class="line"><span class="meta">#</span><span class="bash"> firewall-cmd --permanent --add-port=5543/tcp --zone=public</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> firewall-cmd --permanent --add-port=179/tcp --zone=public</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> firewall-cmd --reload</span></span><br></pre></td></tr></table></figure></li><li><p>部署 dashboard   web ui 管理界面。</p><ul><li><p>事先准备镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker pull registry.cn-hangzhou.aliyuncs.com/rsqlh/kubernetes-dashboard:v1.10.1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker tag registry.cn-hangzhou.aliyuncs.com/rsqlh/kubernetes-dashboard:v1.10.1 k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker rmi registry.cn-hangzhou.aliyuncs.com/rsqlh/kubernetes-dashboard:v1.10.1</span></span><br></pre></td></tr></table></figure></li><li><p>应用 yaml 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-1 data]# kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;dashboard&#x2F;v1.10.1&#x2F;src&#x2F;deploy&#x2F;recommended&#x2F;kubernetes-dashboard.yaml</span><br><span class="line">secret&#x2F;kubernetes-dashboard-certs created</span><br><span class="line">serviceaccount&#x2F;kubernetes-dashboard created</span><br><span class="line">role.rbac.authorization.k8s.io&#x2F;kubernetes-dashboard-minimal created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io&#x2F;kubernetes-dashboard-minimal created</span><br><span class="line">deployment.apps&#x2F;kubernetes-dashboard created</span><br><span class="line">service&#x2F;kubernetes-dashboard created</span><br><span class="line"></span><br><span class="line">查看pod</span><br><span class="line"># kubectl get pods -n kube-system</span><br><span class="line">kubernetes-dashboard-57df4db6b-p9sm8      1&#x2F;1     Running   0          15s</span><br></pre></td></tr></table></figure></li><li><p>开启集群外部访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-1 data]# kubectl get svc -n kube-system</span><br><span class="line">NAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">kube-dns               ClusterIP   10.96.0.10       &lt;none&gt;        53/UDP,53/TCP,9153/TCP   8d</span><br><span class="line">kubernetes-dashboard   ClusterIP   10.110.144.227   &lt;none&gt;        443/TCP                  40s</span><br><span class="line">[root@k8s-master-1 data]# kubectl patch svc kubernetes-dashboard -p '&#123;"spec":&#123;"type":"NodePort"&#125;&#125;' -n kube-system</span><br><span class="line">service/kubernetes-dashboard patched</span><br><span class="line">[root@k8s-master-1 data]# kubectl get svc -n kube-system</span><br><span class="line">NAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">kube-dns               ClusterIP   10.96.0.10       &lt;none&gt;        53/UDP,53/TCP,9153/TCP   8d</span><br><span class="line">kubernetes-dashboard   NodePort    10.110.144.227   &lt;none&gt;        443:30541/TCP            51s</span><br></pre></td></tr></table></figure></li><li><p>通过 ip 和端口 访问会看到需要 token 验证或者 kubeconfig 文件验证。具体的token 获取方法需要创建  serivceaccount 然后 拿到secret 的token 即可，这里不详细阐述。</p></li></ul></li></ol><h2 id="三、部署-node-节点加入集群（node节点）"><a href="#三、部署-node-节点加入集群（node节点）" class="headerlink" title="三、部署 node 节点加入集群（node节点）"></a>三、部署 node 节点加入集群（node节点）</h2><ol><li><p>使用上面记住的命令 初始化 node 节点。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubeadm join 192.168.63.131:6443 --token tacwl8.r9rybowvi486j94t --discovery-token-ca-cert-hash sha256:83d9e155464739407fe5a782b41eac35c42fcba2a1e8c252066cd7e00eaf21ff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 如果没有关闭防火墙</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> firewall-cmd --permanent --add-port=6443/tcp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> firewall-cmd --reload</span></span><br></pre></td></tr></table></figure></li><li><p>如果在node 节点需要使用kubectl 命令 ，需要为对应用户配置 config 文件。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mkdir -p <span class="variable">$HOME</span>/.kube</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> scp -i master:/etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span></span><br></pre></td></tr></table></figure></li><li><p>kubectl get pod –all-namespaces 检查 pod 运行情况</p></li></ol><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/" target="_blank" rel="noopener">https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/</a></p><p><a href="https://github.com/kubernetes/dashboard" target="_blank" rel="noopener">https://github.com/kubernetes/dashboard</a></p><br><br><p><span class="suffix" style="display: none;"></span></h6></p><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码:</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;">https://gitee.com/damon_one/spring-cloud-k8s</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">程序猿Damon</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://www.damon8.cn" style="text-decoration: none" title="">Damon | Micro-Service | Containerization | DevOps</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：程序猿Damon"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Unit one --><p><ins class="adsbygoogle"     style="display:inline-block;text-align:center;width:880px;height:150px"     data-ad-client="ca-pub-1354758384344627"     data-ad-slot="8964778819"></ins></p><script>    (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>记录那些年 Nacos 的坑</title>
    <link href="http://www.damon8.cn/2021/11/12/alibaba-nacos/"/>
    <id>http://www.damon8.cn/2021/11/12/alibaba-nacos/</id>
    <published>2021-11-12T01:22:46.000Z</published>
    <updated>2021-11-12T01:39:41.016Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Nacos-旧史"><a href="#Nacos-旧史" class="headerlink" title="Nacos 旧史"></a>Nacos 旧史</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018年11月左右，Springcloud 联合创始人Spencer Gibb在Spring官网的博客页面宣布：阿里巴巴开源 Spring Cloud Alibaba，并发布了首个预览版本。随后，Spring Cloud 官方Twitter也发布了此消息。</span><br></pre></td></tr></table></figure><p>随着这一消息发布，外面才知道 Nacos 的诞生。毕竟是大厂的 KPI 产物，我们来尝尝鲜。</p><h3 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h3><ul><li><p>Spring Boot: 2.3.12</p></li><li><p>Spring Cloud: Hoxton.SR12</p></li><li><p>Spring Cloud Alibaba: 2.2.6.RELEASE</p></li><li><p>Maven: 3.5.4</p></li><li><p>Java 1.8 +</p></li><li><p>Oauth2 (Spring Security 5.3.9)</p></li></ul><h3 id="安装-Nacos"><a href="#安装-Nacos" class="headerlink" title="安装 Nacos"></a>安装 Nacos</h3><p>下载 Nacos 地址：<a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">https://github.com/alibaba/nacos/releases</a></p><p>版本：v1.2.1</p><p>执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Linux&#x2F;Unix&#x2F;Mac：sh startup.sh -m standalone</span><br><span class="line"></span><br><span class="line">Windows：cmd startup.cmd -m standalone</span><br></pre></td></tr></table></figure><p>启动完成之后，访问：<a href="http://127.0.0.1:8848/nacos/，可以进入Nacos的服务管理页面，具体如下：" target="_blank" rel="noopener">http://127.0.0.1:8848/nacos/，可以进入Nacos的服务管理页面，具体如下：</a></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93f92dff43ba4fd3a70221218351c619~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"><br>在上面，我们可以看到启动的服务列表信息，同时，我们也可以去配置此服务的相关配置：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/539b4386019d43039abdc819f2f290d9~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>具体的配置如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f96658492f3a4aa492c1800812b1533b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>这里，我们可以设置配置的类型，比如：yaml、properties。默认的是后者，这里我们可以设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cas-server</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: 127.0.0.1:8848</span><br><span class="line">      discovery:</span><br><span class="line">        enabled: true</span><br><span class="line">        namespace: a48cec97-fa0f-48e0-97c7-0aced5c7ecbe #默认public</span><br><span class="line">        #group: mine #$&#123;nacos.runtime-env&#125;</span><br><span class="line">        heart-beat-interval: 10</span><br><span class="line">        heart-beat-timeout: 15</span><br><span class="line"></span><br><span class="line">      config:</span><br><span class="line">        enabled: true</span><br><span class="line">        #namespace: $&#123;nacos.namespace&#125;</span><br><span class="line">        file-extension: yaml #默认properties</span><br><span class="line">        #group: $&#123;spring.application.name&#125;</span><br><span class="line">        shared-configs:</span><br><span class="line">          - data-id: application-mysql.properties</span><br><span class="line">            refresh: false</span><br></pre></td></tr></table></figure><h3 id="不同-namespace-下的服务互调"><a href="#不同-namespace-下的服务互调" class="headerlink" title="不同 namespace 下的服务互调"></a>不同 namespace 下的服务互调</h3><p>在 Nacos 里，有几个概念，命令空间 namespace、分组 group 等。虽然这里的关键词跟 K8s 类似，但差别还是很大。这就是我今天想说的坑。这里我们默认配置了 properties。</p><p>在 Nacos 中，为了将不同的服务进行划分区域，这也引入了一些概念：namespace、group 我们先来设置一下 namespace，假如我们这里新建一个 namespace：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba183445d0be48e984fea2fac3faa1c2~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"><br>那么在注册服务时，我们把这个服务放在了这个 <code>new-NS</code>下，启动该服务，我们来看信息：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4b723c5d5b34f22bec5f6c341958a87~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"><br>我们可以看到<code>cas-server</code>服务在 namespace 名称为 new-NS 下。</p><p>下面，我们继续加入一个新服务，把这个新服务放在默认的 namespace 下，假设利用它来调用 cas-server 服务。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/782676157b4541a58a4e0f56c3cb4926~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>接下来，我们通过命令调用服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -H &quot;Accept: application&#x2F;json&quot; -H &quot;Authorization:bearer fbbb08b5-fc9c-4bf9-a676-6a1d5d6a0dda&quot; -X GET http:&#x2F;&#x2F;localhost:2001&#x2F;api&#x2F;user&#x2F;get</span><br></pre></td></tr></table></figure><p>此时可以看到日志：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0b64ebb0c254328b57a40e5cdb3436b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>这里由于被访问的服务是需要鉴权的，所以可以看到：这里的日志是去请求统一认证鉴权中心的<code>check_token</code>接口。由于这两个服务都被注册到 Nacos，这里直接通过域名来请求了。</p><p>但从日志中可以看到，抛出异常：<code>java.lang.IllegalStateException: No instances available for cas-server</code>，这是因为无法解析到这个域名对应的 ip。但从上面，我们可以看到明明有注册信息，为啥不能访问呢？</p><p>这就是 Nacos 现在呈现的第一个坑：<code>无法在跨namespace 下访问其他服务</code>。如果我们把<code>cas-server</code>也放在默认的 namespace 下呢？</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31dfca23ce094b939851254afbb56155~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>再次，我们通过命令调用服务，会发现可以正常请求了：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3aef7e77d97c4c4db6fc213dccb6b358~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>我们发现正常请求后，返回了信息，只不过返回的是<code>400</code>，这是由于我这个 token 失效了，<code>无效的token，请重新认证访问</code>。</p><h3 id="同-namespace-下不同组的服务互调"><a href="#同-namespace-下不同组的服务互调" class="headerlink" title="同 namespace 下不同组的服务互调"></a>同 namespace 下不同组的服务互调</h3><p>上面说到不同 namespace 下的服务互调的问题，接下来，我们看看同一 namespace 下不同分组的服务互调是咋样的呢？</p><p>同样的，我们假设把 cas-server 分配到一个新的 group：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cas-server</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: 127.0.0.1:8848</span><br><span class="line">      discovery:</span><br><span class="line">        enabled: true</span><br><span class="line">        group: mine</span><br><span class="line">        heart-beat-interval: 10</span><br><span class="line">        heart-beat-timeout: 15</span><br></pre></td></tr></table></figure><p>新服务<code>rest-service</code>还是放在默认分组<code>DEFAULT_GROUP</code>里：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c562f94cb61a4c40940d2801b17e0820~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>接下来，我们通过命令调用服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -H &quot;Accept: application&#x2F;json&quot; -H &quot;Authorization:bearer fbbb08b5-fc9c-4bf9-a676-6a1d5d6a0dda&quot; -X GET http:&#x2F;&#x2F;localhost:2001&#x2F;api&#x2F;user&#x2F;get</span><br></pre></td></tr></table></figure><p>我们来看看日志：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bba2aab02ce4a5a8b3be2ae172664f2~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>发现还是跟前面说的那种情况请求后一样，仍然抛出异常：<code>java.lang.IllegalStateException: No instances available for cas-server</code>。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在 Nacos 较高版本中验证这两种情况，同样得出相同的结论：<code>同一namespace下的不同group的服务无法相互调用，不同namespace下的同group的服务无法相互调用</code>。</p><h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>在这里说出 Nacos 的坑，并不是在指责 Nacos 团队哈，只是希望官方尽快出新的 feature。</p><br><br><p><span class="suffix" style="display: none;"></span></h6></p><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码:</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;">https://gitee.com/damon_one/spring-cloud-k8s</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">程序猿Damon</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://www.damon8.cn" style="text-decoration: none" title="">Damon | Micro-Service | Containerization | DevOps</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：程序猿Damon"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Unit one --><p><ins class="adsbygoogle"     style="display:inline-block;text-align:center;width:880px;height:150px"     data-ad-client="ca-pub-1354758384344627"     data-ad-slot="8964778819"></ins></p><script>    (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>统一认证中心 Oauth2 高可用坑</title>
    <link href="http://www.damon8.cn/2021/11/12/oauth2-ha/"/>
    <id>http://www.damon8.cn/2021/11/12/oauth2-ha/</id>
    <published>2021-11-12T00:10:32.000Z</published>
    <updated>2021-11-12T01:42:02.908Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前面 (<a href="https://www.damon8.cn/2021/11/11/oauth2/">统一认证中心 Oauth2 认证坑</a>) 我们利用<code>user-info-uri</code>来实现消费端的认证信息以及授权获取判断，接下来我们借助 <code>token-info-uri</code> 来实现认证以及授权破。具体配置见：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cas-server-url: http:&#x2F;&#x2F;cas-server</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  path:</span><br><span class="line">    ignores: &#x2F;,&#x2F;index,&#x2F;static&#x2F;**,&#x2F;css&#x2F;**, &#x2F;image&#x2F;**, &#x2F;favicon.ico, &#x2F;js&#x2F;**,&#x2F;plugin&#x2F;**,&#x2F;avue.min.js,&#x2F;img&#x2F;**,&#x2F;fonts&#x2F;**</span><br><span class="line">  oauth2:</span><br><span class="line">    client:</span><br><span class="line">      client-id: rest-service</span><br><span class="line">      client-secret: rest-service-123</span><br><span class="line">      user-authorization-uri: $&#123;cas-server-url&#125;&#x2F;oauth&#x2F;authorize</span><br><span class="line">      access-token-uri: $&#123;cas-server-url&#125;&#x2F;oauth&#x2F;token</span><br><span class="line">    resource:</span><br><span class="line">      loadBalanced: true</span><br><span class="line">      id: rest-service</span><br><span class="line">      prefer-token-info: true</span><br><span class="line">      token-info-uri: $&#123;cas-server-url&#125;&#x2F;oauth&#x2F;check_token</span><br><span class="line">    authorization:</span><br><span class="line">      check-token-access: $&#123;cas-server-url&#125;&#x2F;oauth&#x2F;check_token</span><br></pre></td></tr></table></figure><p>这里的<code>/oauth/check_token</code>是 Oauth2 原生自带的，这里不需要封装。接下来，我们启动服务，在拿到 token 后，通过 token 请求消费端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2021-11-03 16:40:09.057 DEBUG 24652 --- [io2-2001-exec-4] o.s.web.client.RestTemplate              : HTTP POST http:&#x2F;&#x2F;cas-server&#x2F;oauth&#x2F;check_token</span><br><span class="line">2021-11-03 16:40:09.060 DEBUG 24652 --- [io2-2001-exec-4] o.s.web.client.RestTemplate              : Accept&#x3D;[application&#x2F;json, application&#x2F;*+json]</span><br><span class="line">2021-11-03 16:40:09.062 DEBUG 24652 --- [io2-2001-exec-4] o.s.web.client.RestTemplate              : Writing [&#123;token&#x3D;[b34841b4-61fa-4dbb-9e2b-76496deb27b4]&#125;] as &quot;application&#x2F;x-www-form-urlencoded&quot;</span><br><span class="line">2021-11-03 16:40:11.332 ERROR 24652 --- [io2-2001-exec-4] o.a.c.c.C.[.[.[&#x2F;].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception</span><br><span class="line"></span><br><span class="line">org.springframework.web.client.ResourceAccessException: I&#x2F;O error on POST request for &quot;http:&#x2F;&#x2F;cas-server&#x2F;oauth&#x2F;check_token&quot;: cas-server; nested exception is java.net.UnknownHostException: cas-server</span><br><span class="line">at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:746)</span><br><span class="line">at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:672)</span><br><span class="line">at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:581)</span><br><span class="line">at org.springframework.security.oauth2.provider.token.RemoteTokenServices.postForMap(RemoteTokenServices.java:149)</span><br></pre></td></tr></table></figure><p>我们从上面的日志中，可以发现系统抛出 UnknownHostException 这种异常，无法找到<code>cas-server</code>，但我要说的是：我们这里用到的是Nacos注册中心来实现服务的注册与发现：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e496a5d43cce4561a6716c8ecabec914~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>那说明注册的服务可以被发现，接下来我们看支持 LB 的几种服务消费方式： RestTemplate、WebClient、Feign。<br>我们这里基于 Ribbon，RestTemplate，因为在Oauth2原生中，就是基于RestTemplate来调用远程服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String, Object&gt; postForMap(String path, MultiValueMap&lt;String, String&gt; formData, HttpHeaders headers) &#123;</span><br><span class="line">if (headers.getContentType() &#x3D;&#x3D; null) &#123;</span><br><span class="line">headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);</span><br><span class="line">&#125;</span><br><span class="line">@SuppressWarnings(&quot;rawtypes&quot;)</span><br><span class="line">Map map &#x3D; restTemplate.exchange(path, HttpMethod.POST,</span><br><span class="line">new HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt;(formData, headers), Map.class).getBody();</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">Map&lt;String, Object&gt; result &#x3D; map;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家都知道默认的原生Ribbon，是基于 RestTemplate 的负载均衡，所以这里配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@LoadBalanced</span><br><span class="line">@Bean</span><br><span class="line">public RestTemplate restTemplate() &#123;</span><br><span class="line">        SimpleClientHttpRequestFactory requestFactory &#x3D; new SimpleClientHttpRequestFactory();</span><br><span class="line">        requestFactory.setReadTimeout(env.getProperty(&quot;client.http.request.readTimeout&quot;, Integer.class, 15000));</span><br><span class="line">        requestFactory.setConnectTimeout(env.getProperty(&quot;client.http.request.connectTimeout&quot;, Integer.class, 3000));</span><br><span class="line">        RestTemplate rt &#x3D; new RestTemplate(requestFactory);</span><br><span class="line">        return rt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在定义 RestTemplate 的时候，增加了<code>@LoadBalanced</code>注解，但其实在真正调用服务接口的时候，原来host部分是通过手工拼接ip和端口的，直接采用服务名的时候来写请求路径即可。在真正调用的时候，Spring Cloud会将请求拦截下来，然后通过负载均衡器选出节点，并替换服务名为具体的ip和端口，从而实现基于服务名的负载均衡调用。</p><p>接下来，我们再看看负载均衡的策略是否有问题，Ribbon默认的负载均衡策略是<strong>轮询</strong>，内置了多种负载均衡策略，内置的负载均衡的顶级接口为<code>com.netflix.loadbalancer.IRule</code>。具体的策略有：AvailabilityFilteringRule、RoundRobinRule、RetryRule、RandomRule、WeightedResponseTimeRule、BestAvailableRule等。这里直接使用默认的<strong>轮询</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public IRule ribbonRule(IClientConfig config)&#123;</span><br><span class="line">            &#x2F;&#x2F;return new AvailabilityFilteringRule();</span><br><span class="line">    return new RoundRobinRule();&#x2F;&#x2F;轮询</span><br><span class="line">    &#x2F;&#x2F;return new RetryRule();&#x2F;&#x2F;重试</span><br><span class="line">            &#x2F;&#x2F;return new RandomRule();&#x2F;&#x2F;这里配置策略，和配置文件对应</span><br><span class="line">            &#x2F;&#x2F;return new WeightedResponseTimeRule();&#x2F;&#x2F;这里配置策略，和配置文件对应</span><br><span class="line">    &#x2F;&#x2F;return new BestAvailableRule();&#x2F;&#x2F;选择一个最小的并发请求的server</span><br><span class="line">    &#x2F;&#x2F;return new MyProbabilityRandomRule();&#x2F;&#x2F;自定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，目前都还未发现问题，那么既然实现了基于RestTemplate的负载均衡，为什么还是报错呢？</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bac955fa9c14e22bc000407f0c9147a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>找了半天，最后发现在Oauth2源码中，注入的是这么个玩意：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a056a19a7fd4d5884434dd97dac5adb~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>这时候才发现多么的坑，于是乎，一顿猛操作：在资源检验时调用的覆盖其注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Autowired(required &#x3D; true)</span><br><span class="line">private RemoteTokenServices remoteTokenServices;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">RestTemplate restTemplate;</span><br></pre></td></tr></table></figure><p>其二，直接set RestTemplate：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void configure(ResourceServerSecurityConfigurer resource) throws Exception &#123;</span><br><span class="line">super.configure(resource);</span><br><span class="line"></span><br><span class="line">        restTemplate.setErrorHandler(new DefaultResponseErrorHandler() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            &#x2F;&#x2F; Ignore 400</span><br><span class="line">            public void handleError(ClientHttpResponse response) throws IOException &#123;</span><br><span class="line">                if (response.getRawStatusCode() !&#x3D; 400) &#123;</span><br><span class="line">                    super.handleError(response);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        if (Objects.nonNull(remoteTokenServices)) &#123;</span><br><span class="line">            remoteTokenServices.setRestTemplate(restTemplate);</span><br><span class="line">            resource.tokenServices(remoteTokenServices);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        resource</span><br><span class="line">        &#x2F;&#x2F;.tokenStore(tokenStore)</span><br><span class="line">        &#x2F;&#x2F;.tokenServices(tokenServices)</span><br><span class="line">        .authenticationEntryPoint(customAuthenticationEntryPoint)</span><br><span class="line">.accessDeniedHandler(customAccessDeniedHandler)</span><br><span class="line">        &#x2F;&#x2F;.tokenExtractor(new BearerTokenExtractor())</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接下来，我们重启消费端，看看效果，根据之前请求的token，直接访问消费端接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2021-11-03 16:57:50.476  INFO 81424 --- [io2-2001-exec-3] o.s.web.servlet.DispatcherServlet        : Completed initialization in 12 ms</span><br><span class="line">2021-11-03 16:57:50.522 DEBUG 81424 --- [io2-2001-exec-3] o.s.web.client.RestTemplate              : HTTP POST http:&#x2F;&#x2F;cas-server&#x2F;oauth&#x2F;check_token</span><br><span class="line">2021-11-03 16:57:50.526 DEBUG 81424 --- [io2-2001-exec-3] o.s.web.client.RestTemplate              : Accept&#x3D;[application&#x2F;json, application&#x2F;*+json]</span><br><span class="line">2021-11-03 16:57:50.528 DEBUG 81424 --- [io2-2001-exec-3] o.s.web.client.RestTemplate              : Writing [&#123;token&#x3D;[b34841b4-61fa-4dbb-9e2b-76496deb27b4]&#125;] as &quot;application&#x2F;x-www-form-urlencoded&quot;</span><br><span class="line">2021-11-03 16:57:50.635 DEBUG 81424 --- [io2-2001-exec-3] o.s.web.client.RestTemplate              : Response 200 OK</span><br></pre></td></tr></table></figure><p>发现ok了，返回成功<code>200</code>，并且有权限访问该接口：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af71b380ca1546b79640fd3c60014d93~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>总结</p><p>有时候自己的代码写的已经很好了，但发现还是无法实现自己想要的：于是乎，可以大胆设想是不是官网源码出了幺蛾子，就像本文一样，如果不一步步检查，怎么也不会发现原来是源码留下如此大的坑，在前面的文章中，其实发现很多源码的不合理之处之后，都在修改，并且生成一套自己的规范返回，这样对于代码本身来说，我们会更加深刻体会、理解。Oauth2源码本身可以只是一个带头的基础功能，后面基于大项目，需要自己对于一些系统的设计进行改造，例如：高可用、高并发鉴权方案、统一认证SSO等等。</p><br><br><p><span class="suffix" style="display: none;"></span></h6></p><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码:</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;">https://gitee.com/damon_one/spring-cloud-k8s</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">程序猿Damon</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://www.damon8.cn" style="text-decoration: none" title="">Damon | Micro-Service | Containerization | DevOps</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：程序猿Damon"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Unit one --><p><ins class="adsbygoogle"     style="display:inline-block;text-align:center;width:880px;height:150px"     data-ad-client="ca-pub-1354758384344627"     data-ad-slot="8964778819"></ins></p><script>    (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>统一认证中心 Oauth2 认证坑</title>
    <link href="http://www.damon8.cn/2021/11/11/oauth2/"/>
    <id>http://www.damon8.cn/2021/11/11/oauth2/</id>
    <published>2021-11-11T07:11:21.000Z</published>
    <updated>2021-11-12T01:41:55.645Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在前面文章 <a href="https://www.damon8.cn/2021/10/11/oauth-ha/">Springcloud Oauth2 HA篇</a> 中，实现了基于 Oauth2 的统一认证的认证与授权。在配置中，我们可以看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cas-server-url: http:&#x2F;&#x2F;cas-server-service #这里配置成HA地址</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  oauth2: #与cas-server对应的配置</span><br><span class="line">    client:</span><br><span class="line">      client-id: admin-web</span><br><span class="line">      client-secret: admin-web-123</span><br><span class="line">      user-authorization-uri: $&#123;cas-server-url&#125;&#x2F;oauth&#x2F;authorize #是授权码认证方式需要的</span><br><span class="line">      access-token-uri: $&#123;cas-server-url&#125;&#x2F;oauth&#x2F;token #是密码模式需要用到的获取 token 的接口</span><br><span class="line">    resource:</span><br><span class="line">      loadBalanced: true</span><br><span class="line">      id: admin-web</span><br><span class="line">      user-info-uri: $&#123;cas-server-url&#125;&#x2F;api&#x2F;user #指定user info的URI</span><br><span class="line">      prefer-token-info: false</span><br></pre></td></tr></table></figure><p>这里的 url 配置是基于k8s的 Service，实现负载均衡，从而实现高可用。但我们接下来分析 user-info-uri。user-info-uri 的原理是在授权服务器认证后将认证信息 Principal 通过形参绑定的方法通过URL的方式获取用户信息。当然它也有配套的 UserInfoTokenService 等。</p><p>但这个在客户端获取用户权限时候，是存在一定问题的。譬如 Web端请求消费端的某个接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 返回发现的所有服务</span><br><span class="line"> * @author Damon</span><br><span class="line"> * @date 2021年11月2日 下午8:18:44</span><br><span class="line"> * @return</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">@PreAuthorize(&quot;hasRole(&#39;admin&#39;)&quot;)</span><br><span class="line">@GetMapping(value &#x3D; &quot;&#x2F;getService&quot;)</span><br><span class="line">    public String getService()&#123;</span><br><span class="line">HttpHeaders headers &#x3D; new HttpHeaders();</span><br><span class="line">MediaType type &#x3D; MediaType.parseMediaType(&quot;application&#x2F;json; charset&#x3D;UTF-8&quot;);</span><br><span class="line">headers.setContentType(type);</span><br><span class="line">headers.add(&quot;Accept&quot;, MediaType.APPLICATION_JSON.toString());</span><br><span class="line">HttpEntity&lt;String&gt; formEntity &#x3D; new HttpEntity&lt;String&gt;(null, headers);</span><br><span class="line">String body &#x3D; &quot;&quot;;</span><br><span class="line">try &#123;</span><br><span class="line">ResponseEntity&lt;String&gt; responseEntity &#x3D; restTemplate.exchange(&quot;http:&#x2F;&#x2F;cas-server&#x2F;api&#x2F;v1&#x2F;user&quot;,</span><br><span class="line">HttpMethod.GET, formEntity, String.class);</span><br><span class="line">if (responseEntity.getStatusCodeValue() &#x3D;&#x3D; 200) &#123;</span><br><span class="line">return &quot;ok&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">return body;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在这个接口中，我们通过添加<code>@PreAuthorize(&quot;hasRole(&#39;admin&#39;)&quot;)</code>来控制权限，只要是admin的用户才能访问改接口。</p><p>我们先来请求认证中心登录接口，获取token：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eeb4bb0860054c15a2f03e781d165664~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>在拿到token之后，我们请求这个接口，我们会发现：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bbca89d4ba84ac0acc6dde997d279e7~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>说明未认证，我们再看看：发现原来当请求这个接口时，消费端后去请求认证中心的接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2021-11-03 15:59:09.385 DEBUG 127896 --- [io2-2001-exec-4] org.springframework.web.HttpLogging      : HTTP GET http:&#x2F;&#x2F;cas-server&#x2F;auth&#x2F;user</span><br><span class="line">2021-11-03 15:59:09.389 DEBUG 127896 --- [io2-2001-exec-4] org.springframework.web.HttpLogging      : Accept&#x3D;[application&#x2F;json, application&#x2F;*+json]</span><br><span class="line">2021-11-03 15:59:09.427 DEBUG 127896 --- [io2-2001-exec-4] org.springframework.web.HttpLogging      : Response 404 NOT_FOUND</span><br><span class="line">2021-11-03 15:59:09.446 DEBUG 127896 --- [io2-2001-exec-4] o.s.w.c.HttpMessageConverterExtractor    : Reading to [org.springframework.security.oauth2.common.exceptions.OAuth2Exception]</span><br><span class="line">2021-11-03 15:59:09.456  WARN 127896 --- [io2-2001-exec-4] o.s.b.a.s.o.r.UserInfoTokenServices      : Could not fetch user details: class org.springframework.web.client.HttpClientErrorException$NotFound, 404 : [&#123;&quot;timestamp&quot;:&quot;2021-11-03T07:59:09.423+00:00&quot;,&quot;status&quot;:404,&quot;error&quot;:&quot;Not Found&quot;,&quot;message&quot;:&quot;&quot;,&quot;path&quot;:&quot;&#x2F;auth&#x2F;user&quot;&#125;]</span><br><span class="line">2021-11-03 15:59:09.457 ERROR 127896 --- [io2-2001-exec-4] c.l.h.CustomAuthenticationEntryPoint     : 无效的token，请重新认证访问</span><br><span class="line">&#123;&quot;data&quot;:&quot;b34841b4-61fa-4dbb-9e2b-76496deb27b4&quot;,&quot;result&quot;:&#123;&quot;code&quot;:20202,&quot;msg&quot;:&quot;未认证&quot;,&quot;status&quot;:401&#125;&#125;</span><br></pre></td></tr></table></figure><p>但认证中心给返回的<code>404</code>状态码，此时会走统一异常EntryPoint提示报错：<code>无效的token，请重新认证访问</code>。从而返回信息体：<code>{&quot;data&quot;:&quot;b34841b4-61fa-4dbb-9e2b-76496deb27b4&quot;,&quot;result&quot;:{&quot;code&quot;:20202,&quot;msg&quot;:&quot;未认证&quot;,&quot;status&quot;:401}}</code>。</p><p>接下来分析：为什么认证中心会返回<code>404</code>呢？看认证中心日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2021-11-03 15:59:09.407 DEBUG 54492 --- [o2-2000-exec-15] o.s.web.servlet.DispatcherServlet        : GET &quot;&#x2F;auth&#x2F;user&quot;, parameters&#x3D;&#123;&#125;</span><br><span class="line">2021-11-03 15:59:09.409 DEBUG 54492 --- [o2-2000-exec-15] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped to ResourceHttpRequestHandler [&quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;&quot;, &quot;classpath:&#x2F;resources&#x2F;&quot;, &quot;classpath:&#x2F;static&#x2F;&quot;, &quot;classpath:&#x2F;public&#x2F;&quot;]</span><br><span class="line">2021-11-03 15:59:09.413 DEBUG 54492 --- [o2-2000-exec-15] o.s.w.s.r.ResourceHttpRequestHandler     : Resource not found</span><br><span class="line">2021-11-03 15:59:09.414 DEBUG 54492 --- [o2-2000-exec-15] o.s.web.servlet.DispatcherServlet        : Completed 404 NOT_FOUND</span><br><span class="line">2021-11-03 15:59:09.422 DEBUG 54492 --- [o2-2000-exec-15] o.s.web.servlet.DispatcherServlet        : &quot;ERROR&quot; dispatch for GET &quot;&#x2F;error&quot;, parameters&#x3D;&#123;&#125;</span><br><span class="line">2021-11-03 15:59:09.423 DEBUG 54492 --- [o2-2000-exec-15] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped to org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController#error(HttpServletRequest)</span><br><span class="line">2021-11-03 15:59:09.424 DEBUG 54492 --- [o2-2000-exec-15] o.s.w.s.m.m.a.HttpEntityMethodProcessor  : Using &#39;application&#x2F;json&#39;, given [application&#x2F;json] and supported [application&#x2F;json, application&#x2F;*+json, application&#x2F;json, application&#x2F;*+json, application&#x2F;json, application&#x2F;*+json]</span><br><span class="line">2021-11-03 15:59:09.424 DEBUG 54492 --- [o2-2000-exec-15] o.s.w.s.m.m.a.HttpEntityMethodProcessor  : Writing [&#123;timestamp&#x3D;Wed Nov 03 15:59:09 CST 2021, status&#x3D;404, error&#x3D;Not Found, message&#x3D;, path&#x3D;&#x2F;auth&#x2F;user&#125;]</span><br><span class="line">2021-11-03 15:59:09.426 DEBUG 54492 --- [o2-2000-exec-15] o.s.web.servlet.DispatcherServlet        : Exiting from &quot;ERROR&quot; dispatch, status 404</span><br></pre></td></tr></table></figure><p>发现原来Oauth2没有此类接口:<code>/auth/user</code>。最后决定自写一个接口来替换原生:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;api&#x2F;v1&#x2F;user&quot;)</span><br><span class="line">    public Authentication user(Map map, Principal user, Authentication auth) &#123;</span><br><span class="line">        &#x2F;&#x2F;获取当前用户信息</span><br><span class="line">    logger.info(&quot;cas-server provide user: &quot; + JSON.toJSONString(auth));</span><br><span class="line">        return auth;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在封装、覆盖后，在消费端直接配置相关配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cas-server-url: http:&#x2F;&#x2F;cas-server</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  path:</span><br><span class="line">    ignores: &#x2F;,&#x2F;index,&#x2F;static&#x2F;**,&#x2F;css&#x2F;**, &#x2F;image&#x2F;**, &#x2F;favicon.ico, &#x2F;js&#x2F;**,&#x2F;plugin&#x2F;**,&#x2F;avue.min.js,&#x2F;img&#x2F;**,&#x2F;fonts&#x2F;**</span><br><span class="line">  oauth2:</span><br><span class="line">    client:</span><br><span class="line">      client-id: rest-service</span><br><span class="line">      client-secret: rest-service-123</span><br><span class="line">      user-authorization-uri: $&#123;cas-server-url&#125;&#x2F;oauth&#x2F;authorize</span><br><span class="line">      access-token-uri: $&#123;cas-server-url&#125;&#x2F;oauth&#x2F;token</span><br><span class="line">    resource:</span><br><span class="line">      loadBalanced: true</span><br><span class="line">      id: rest-service</span><br><span class="line">      prefer-token-info: false</span><br><span class="line">      user-info-uri: $&#123;cas-server-url&#125;&#x2F;api&#x2F;v1&#x2F;user</span><br><span class="line">    authorization:</span><br><span class="line">      check-token-access: $&#123;cas-server-url&#125;&#x2F;oauth&#x2F;check_token</span><br></pre></td></tr></table></figure><p>同时启动认证中心、消费端，继续获取token后，请求接口：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29428df6a1234d6da3e94f6911dd5c38~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>此时，发现是<code>403</code>，没有权限了，这下我们可以对用户添加这种权限即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;authorities&quot;: [ &#123; &quot;authority&quot;: &quot;ROLE_admin&quot; &#125;, &#123; &quot;authority&quot;: &quot;admin&quot; &#125;</span><br></pre></td></tr></table></figure><p>添加完之后，我们发现可以请求接口成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;authorities&quot;: [ &#123; &quot;authority&quot;: &quot;ROLE_admin&quot; &#125;, &#123; &quot;authority&quot;: &quot;admin&quot; &#125; ], &quot;details&quot;: &#123; &quot;remoteAddress&quot;: &quot;0:0:0:0:0:0:0:1&quot;, &quot;sessionId&quot;: null, &quot;tokenValue&quot;: &quot;b34841b4-61fa-4dbb-9e2b-76496deb27b4&quot;, &quot;tokenType&quot;: &quot;bearer&quot;, &quot;decodedDetails&quot;: null &#125;, &quot;authenticated&quot;: true, &quot;userAuthentication&quot;: &#123; &quot;authorities&quot;: [ &#123; &quot;authority&quot;: &quot;ROLE_admin&quot; &#125;, &#123; &quot;authority&quot;: &quot;admin&quot; &#125; ], &quot;details&quot;: &#123; &quot;authorities&quot;: [ &#123; &quot;authority&quot;: &quot;ROLE_admin&quot; &#125;, &#123; &quot;authority&quot;: &quot;admin&quot; &#125; ], &quot;details&quot;: &#123; &quot;remoteAddress&quot;: &quot;169.254.200.12&quot;, &quot;sessionId&quot;: null, &quot;tokenValue&quot;: &quot;b34841b4-61fa-4dbb-9e2b-76496deb27b4&quot;, &quot;tokenType&quot;: &quot;Bearer&quot;, &quot;decodedDetails&quot;: null &#125;, &quot;authenticated&quot;: true, &quot;userAuthentication&quot;: &#123; &quot;authorities&quot;: [ &#123; &quot;authority&quot;: &quot;ROLE_admin&quot; &#125;, &#123; &quot;authority&quot;: &quot;admin&quot; &#125; ],</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里简单测试，直接写的返回当前用户权限的接口，发现权限就是”ROLE_admin、”admin”。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有时候官网的源码解析很少，我们必须看源码，结合实际行动才能准确的分析其用意。所以当其不存在、或者不满足我们的需求时，可以选择覆盖其源码逻辑，实现自定义模式，这样会避免很多不必要的麻烦。因为源码解析毕竟不同版本，对应的源码也是不同的。</p><br><br><p><span class="suffix" style="display: none;"></span></h6></p><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码:</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;">https://gitee.com/damon_one/spring-cloud-k8s</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">程序猿Damon</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://www.damon8.cn" style="text-decoration: none" title="">Damon | Micro-Service | Containerization | DevOps</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：程序猿Damon"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Unit one --><p><ins class="adsbygoogle"     style="display:inline-block;text-align:center;width:880px;height:150px"     data-ad-client="ca-pub-1354758384344627"     data-ad-slot="8964778819"></ins></p><script>    (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>基于 spring-cloud-k8s 跨NS坑续集</title>
    <link href="http://www.damon8.cn/2021/11/11/spring-cloud-k8s-note2/"/>
    <id>http://www.damon8.cn/2021/11/11/spring-cloud-k8s-note2/</id>
    <published>2021-11-11T07:07:51.000Z</published>
    <updated>2021-11-12T01:42:56.476Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在前面文章 (<a href="https://www.damon8.cn/2021/11/11/spring-cloud-k8s-note1/">spring-cloud-k8s 跨 NS 的坑</a>) 中，讲述了 <code>spring-cloud-k8s</code> 中，如何利用 k8s 基于 Ribbon 等负载均衡利器来实现 LB，但存在<code>跨命名空间</code>的问题。</p><p>今天主要分享的是，基于 K8s 本身的 LB 利器，如何实现跨命名空间的应用服务互相访问，而且不是通过 K8s 原生的负载均衡 url 方式。还是基于 ServiceName。</p><h3 id="直击源码"><a href="#直击源码" class="headerlink" title="直击源码"></a>直击源码</h3><p>首先，我们新建一个服务提供者:<code>diff-ns-service</code>，该服务提供了一个接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 返回远程调用的结果</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RequestMapping(&quot;&#x2F;getservicedetail&quot;)</span><br><span class="line">public String getservicedetail(</span><br><span class="line">        @RequestParam(value &#x3D; &quot;servicename&quot;, defaultValue &#x3D; &quot;&quot;) String servicename) &#123;</span><br><span class="line">    return JSON.toJSONString(discoveryClient.getInstances(servicename));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口的功能是返回指定 service 的相关信息。比如：这个 Service 对应的有几个 pod，每个 pod 的节点信息，host 等。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a735bc6e831949619b1ae69cd22309ab~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>如果想结合 K8s 来实现这个服务的发现，可以基于这个配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">management:</span><br><span class="line">  endpoint:</span><br><span class="line">    restart:</span><br><span class="line">      enabled: true</span><br><span class="line">    health:</span><br><span class="line">      enabled: true</span><br><span class="line">    info:</span><br><span class="line">      enabled: true</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: diff-ns-service</span><br><span class="line">  cloud:</span><br><span class="line">    loadbalancer:</span><br><span class="line">      ribbon:</span><br><span class="line">        enabled: false</span><br><span class="line">    kubernetes:</span><br><span class="line">      ribbon:</span><br><span class="line">        mode: SERVICE</span><br><span class="line">      discovery:</span><br><span class="line">        all-namespaces: true</span><br></pre></td></tr></table></figure><p>另外，如果想利用 k8s configMap 的配置来实现动态刷新应用服务的环境配置，可以这样配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: diff-ns-service</span><br><span class="line">  cloud:</span><br><span class="line">    kubernetes:</span><br><span class="line">      reload:</span><br><span class="line">        enabled: true</span><br><span class="line">        strategy: refresh</span><br><span class="line"></span><br><span class="line">        mode: event</span><br><span class="line">      config:</span><br><span class="line">        name: $&#123;spring.application.name&#125;</span><br><span class="line">        namespace: default</span><br><span class="line">        sources:</span><br><span class="line">          - name: $&#123;spring.application.name&#125;</span><br><span class="line">            namespace: ns-app</span><br></pre></td></tr></table></figure><p>这里的动态刷新的模式有两个：<code>[polling</code>、<code>event</code>。一个是主动拉取，一个是当 configmap 发生改变时，这种事件会被监听到，会主动刷新。</p><p>另外，这个刷新的策略也有几种：</p><ul><li>refresh，直接刷新</li><li>restart_context，整个 Spring Context 会优雅重启，里面的所有配置都会重新加载</li><li>shutdown，重启容器</li></ul><p>这样，我们再来配置一下 Service：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: diff-ns-service-service</span><br><span class="line">  namespace: ns-app</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - name: diff-ns-svc</span><br><span class="line">    port: 2008</span><br><span class="line">    targetPort: 2001</span><br><span class="line">  selector:</span><br><span class="line">    app: diff-ns-service</span><br></pre></td></tr></table></figure><p>这里我们设置了 Service 的 port,并且这个 Service 以 <code>NodePort</code> 类型创建。在(<a href="https://juejin.cn/post/7028718715399061534" target="_blank" rel="noopener">spring-cloud-k8s 跨 NS 的坑</a>)一文中，我们使用的是默认的类型：ClusterIp。</p><p>这样，一个简单的服务提供者就创建成功了。接下来，我们看看服务消费者。</p><p>同样，我们先来创建一个服务 <code>rest-service</code>，创建接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;getClientRes&quot;)</span><br><span class="line">public Response&lt;Object&gt; getClientRes() throws Exception &#123;</span><br><span class="line">        HttpHeaders headers &#x3D; new HttpHeaders();</span><br><span class="line">        MediaType type &#x3D; MediaType.parseMediaType(&quot;application&#x2F;json; charset&#x3D;UTF-8&quot;);</span><br><span class="line">        headers.setContentType(type);</span><br><span class="line">        headers.add(&quot;Accept&quot;, MediaType.APPLICATION_JSON.toString());</span><br><span class="line">        HttpEntity&lt;String&gt; formEntity &#x3D; new HttpEntity&lt;String&gt;(null, headers);</span><br><span class="line">        String body &#x3D; &quot;&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">                ResponseEntity&lt;String&gt; responseEntity &#x3D; restTemplate.exchange(&quot;http:&#x2F;&#x2F;diff-ns-service-service&#x2F;getservicedetail?servicename&#x3D;cas-server-service&quot;,</span><br><span class="line">                                HttpMethod.GET, formEntity, String.class);</span><br><span class="line">                System.out.println(JSON.toJSONString(responseEntity));</span><br><span class="line">                if (responseEntity.getStatusCodeValue() &#x3D;&#x3D; 200) &#123;</span><br><span class="line">                        return Response.ok(responseEntity.getBody());</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        return Response.error(&quot;failed&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理地，结合 K8s 来实现这个服务的发现，可以基于这个配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">management:</span><br><span class="line">  endpoint:</span><br><span class="line">    restart:</span><br><span class="line">      enabled: true</span><br><span class="line">    health:</span><br><span class="line">      enabled: true</span><br><span class="line">    info:</span><br><span class="line">      enabled: true</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: rest-service</span><br><span class="line">  cloud:</span><br><span class="line">    loadbalancer:</span><br><span class="line">      ribbon:</span><br><span class="line">        enabled: false</span><br><span class="line">    kubernetes:</span><br><span class="line">      ribbon:</span><br><span class="line">        mode: SERVICE</span><br><span class="line">      discovery:</span><br><span class="line">        all-namespaces: true</span><br></pre></td></tr></table></figure><p>这里，我们不使用 RibbonLoadBalancerClient。</p><p>另外，如果想利用 k8s configMap 的配置来实现动态刷新应用服务的环境配置，可以这样配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    kubernetes:</span><br><span class="line">      reload:</span><br><span class="line">        enabled: true</span><br><span class="line">        strategy: refresh</span><br><span class="line"></span><br><span class="line">        mode: event</span><br><span class="line">      config:</span><br><span class="line">        name: $&#123;spring.application.name&#125;</span><br><span class="line">        namespace: default</span><br><span class="line">        sources:</span><br><span class="line">          - name: $&#123;spring.application.name&#125;</span><br><span class="line">            namespace: system-server</span><br></pre></td></tr></table></figure><p>对于这些，在前面的文章说过，我们需要依赖配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-webflux&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-actuator-autoconfigure&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-kubernetes&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-starter-kubernetes-config&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-kubernetes-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-kubernetes-loadbalancer&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.squareup.okhttp3&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;okhttp&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>这里没有用 Ribbon 的，直接使用 <code>spring-cloud-starter-kubernetes-loadbalancer</code>，但我们还是利用 <code>RestTemplate</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@LoadBalanced</span><br><span class="line">@Bean</span><br><span class="line">public RestTemplate restTemplate() &#123;</span><br><span class="line">        SimpleClientHttpRequestFactory requestFactory &#x3D; new SimpleClientHttpRequestFactory();</span><br><span class="line">        requestFactory.setReadTimeout(env.getProperty(&quot;client.http.request.readTimeout&quot;, Integer.class, 15000));</span><br><span class="line">        requestFactory.setConnectTimeout(env.getProperty(&quot;client.http.request.connectTimeout&quot;, Integer.class, 3000));</span><br><span class="line">        RestTemplate rt &#x3D; new RestTemplate(requestFactory);</span><br><span class="line">        return rt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们开始部署这两个应用服务了，同时，我们采用服务扩容方式实现多 pod：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale --replicas&#x3D;2 deployment diff-ns-service-deployment</span><br></pre></td></tr></table></figure><p>我们苦役看看服务节点信息：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f99a4ba585c74385aeb79c57595ad743~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>查看 Service 信息：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4df1129a9e54c99bd48cf90516e778e~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>接下来，我们访问服务<code>rest-service</code>：<a href="http://192.168.8.107:5556/rest-service/getClientRes，" target="_blank" rel="noopener">http://192.168.8.107:5556/rest-service/getClientRes，</a> 这里我们可以看到日志：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33e6101356114bb6864689edc3d5193f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>同时，去哦们可以看到返回结果：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc8a5a4e63aa4b9da4c69ed9ad0567b7~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"><br>这里，我们请求的是获取<code>cas-server</code> 这个服务的 pod 的分布信息。</p><p>同样地，我们通过 Service 的 Ip 和端口也可以直接访问：<code>http://192.168.8.107:30916/getservicedetail?servicename=cas-server-service</code></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/625abd4fde7f429a8c4ada4864d68b3c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>PS:如果需要实现负载均衡，还是需要注入：<code>@LoadBalanced</code>，如果我们把这个注解去掉会发生什么呢？</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53081b6de743497b871f117851d95e10~tplv-k3u1fbpfcp-watermark.image?" alt="1636538633(1).png"></p><p>我们发现去掉后，竟然不能访问了。</p><p>我们再做一组测试，如果我们利用 <code>spring.cloud.kubernetes.ribbon.mode=POD</code>，我们来看看会有啥结果不？<br>修改配置后，重新编译、部署，我们继续请求 url<code>http://192.168.8.107:5556/rest-service/getClientRes</code>:</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80a005f867ba421882147f61f61bf7b7~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h3 id="新发现"><a href="#新发现" class="headerlink" title="新发现"></a>新发现</h3><p>如果我们引入的是基于 Spring cloud 本身的<code>spring-cloud-starter-kubernetes-loadbalancer</code>，同时，我们没有去掉基于 Ribbon 的 LB 的能力，如：<code>spring.cloud.loadbalancer.ribbon.enabled=false</code>，是有可能会报错的：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3b5ff9c059045d4b89f987d11e5474f~tplv-k3u1fbpfcp-watermark.image?" alt="1636601324.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>Spring cloud 本身：如果是基于 Spring cloud 本身的 LB，需要隐藏 Ribbon 的能力，同时基于<code>RestTemplate</code> 需要注解<code>@LoadBalanced</code>。</p></li><li><p>k8s 本身：如果采用 Spring cloud 的负载，再结合 K8s，可以实现应用服务的 LB。如果设置<code>spring.cloud.kubernetes.ribbon.mode=POD</code>，其禁用了 Ribbon 的 LB 能力，此时不会生效，走的还是 Spring cloud LoadBalancer。另外对于 Service，这里都设置为 NodePort 类型，如果是默认类型是否可以实现 LB，需要待确认，因为目前来看，没有实现，可能是网络问题，并不是说默认类型的 Service 不可实现 LB。</p></li><li><p>Ribbon，基于上面，下次可以尝试基于 NodePort 类型的 Service 来实现 Ribbon 的 LB，看是否是因为 Service 的网络导致的。</p></li></ul><h3 id="实践验证"><a href="#实践验证" class="headerlink" title="实践验证"></a>实践验证</h3><p>在前面我们已经针对默认类型的Service进行Ribbon负载均衡测试过，发现无法对跨 NS 进行LB。接下来，我们测试下基于 NodePort 类型的Service，打开<code>spring.cloud.loadbalancer.ribbon.enabled=true</code>，引入依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-kubernetes-ribbon&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>按照以上配置，我们部署服务<code>diff-ns-service</code>，我们发现服务启动后日志：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db0f5a1280e645fb88909b39aa3be35c~tplv-k3u1fbpfcp-watermark.image?" alt="1636603546(1).png"></p><p>请求后返回日志：<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2975fc0433b40dd8424d07c7583ef7c~tplv-k3u1fbpfcp-watermark.image?" alt="1636603299(1).png"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>不管怎样，Ribbon 无法解决跨 NS 的应用服务之间的相互访问。但对于 Service 类型来说，可能是网络设置问题，跟其类型无关。</p><br><br><p><span class="suffix" style="display: none;"></span></h6></p><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码:</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;">https://gitee.com/damon_one/spring-cloud-k8s</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">程序猿Damon</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://www.damon8.cn" style="text-decoration: none" title="">Damon | Micro-Service | Containerization | DevOps</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：程序猿Damon"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Unit one --><p><ins class="adsbygoogle"     style="display:inline-block;text-align:center;width:880px;height:150px"     data-ad-client="ca-pub-1354758384344627"     data-ad-slot="8964778819"></ins></p><script>    (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>spring-cloud-k8s 跨 NS 的坑</title>
    <link href="http://www.damon8.cn/2021/11/11/spring-cloud-k8s-note1/"/>
    <id>http://www.damon8.cn/2021/11/11/spring-cloud-k8s-note1/</id>
    <published>2021-11-11T07:06:15.000Z</published>
    <updated>2021-11-12T01:42:47.212Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>前面文章 (<a href="https://www.damon8.cn/2020/07/23/spring-cloud-k8s-discovery/">Spring Cloud Kubernetes 之实战服务注册与发现</a>) 中，讲述了 <code>spring-cloud-k8s</code> 在微服务实践中，带来了多大的优势。介绍了 k8s 中资源 Service，其如何来实现服务的注册与发现。</p><p>其实在 k8s 中，Service 资源的类型比较多，有四种：</p><ul><li>ExternalName：创建一个 DNS 别名指向 service name，这样可以防止 service name 发生变化，但需要配合 DNS 插件使用。</li><li>ClusterIP：默认的类型，用于为集群内 Pod 访问时，提供的固定访问地址,默认是自动分配地址,可使用 ClusterIP 关键字指定固定 IP。</li><li>NodePort：基于 ClusterIp，用于为集群外部访问 Service 后面 Pod 提供访问接入端口。</li><li>LoadBalancer：它是基于 NodePort。</li></ul><p>我们一般会默认使用的类型：ClusterIP，但此时会出现一种问题，那就是此类型的 Service 被用来访问非同一 NS 下的 pods，即<code>&lt;servicename&gt;.&lt;namespace&gt;.svc.cluster.local</code>形式访问 pod，只能通过 servicename 直接访问同一 namespace 下的 pod。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>下面，我们来看案例：假设我这里有三个服务：cas-server、rest-service、diff-ns-service 等，我通过 deployment 来部署这些服务的 pod。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2950309ca46a4cbaa608fb1c22e8ca3a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>可以看到这些 pod 处于 不同的 namespace 下，同样的对应的 service 也是处于对应的 namespace 下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ns-app          diff-ns-service-service   ClusterIP   10.16.178.187   &lt;none&gt;        2008&#x2F;TCP        6h39m   app&#x3D;diff-ns-service</span><br><span class="line">system-server   cas-server-service        ClusterIP   10.16.134.168   &lt;none&gt;        2000&#x2F;TCP        16d     app&#x3D;cas-server</span><br><span class="line">system-server   rest-service-service      ClusterIP   10.16.128.58    &lt;none&gt;        2001&#x2F;TCP        16d     app&#x3D;rest-service</span><br></pre></td></tr></table></figure><p>这里的 Service 类型都是 <code>ClusterIp</code>,在前面，我们验证过基于这样的服务，我们可以利用 springcloud-k8s 来实现同一 namespace 下服务之间的注册与发现，实现负载均衡。但如果不在同一 namespace 下呢？比如这里的<code>diff-ns-service</code>，它与另外两个服务不在同一 namespace。此时我们通过基于 Ribbon 的负载均衡策略。这是因为我们默认了 <code>KubernetesRibbonMode</code> 的模式：POD，就是获取服务提供者的 pod 的 ip 和 port，该 ip 是 kubernetes 集群的内部 ip，只要服务消费者是部署在同一个 kubernetes 集群内就能通过 pod 的 ip 和服务提供者暴露的端口访问。当我们使用当<code>mode</code>为<code>SERVICE</code>时，就是获取服务提供者在 k8s 中的 service 的名称和端口，使用这种模式会导致 Ribbon 的负载均衡失效，转而使用 k8s 的负载均衡。</p><p>所以，如果不使用默认的 Ribbon 来实现负载均衡，可以配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    kubernetes:</span><br><span class="line">      ribbon:</span><br><span class="line">        mode: SERVICE</span><br></pre></td></tr></table></figure><p>这个前提其实还是在同一 namespace 下，但如果不在同一 NS 呢？还是设置为<code>SERVICE</code>模式，但里面还是用 k8s 原生的调用方式：<code>&lt;servicename&gt;.&lt;namespace&gt;.svc.cluster.local***</code>，假设这里需要调用 <code>diff-ns-service</code>,则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;String&gt; responseEntity &#x3D; new RestTemplate().exchange(&quot;http:&#x2F;&#x2F;diff-ns-service-service&#x2F;getservicedetail?servicename&#x3D;cas-server-service&quot;,</span><br><span class="line">HttpMethod.GET, formEntity, String.class);</span><br></pre></td></tr></table></figure><p>访问请求该服务时，发现并未请求到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2021-11-04 09:23:16.830:147 [http-nio2-2001-exec-2] DEBUG org.springframework.web.client.RestTemplate -HTTP GET http:&#x2F;&#x2F;diff-ns-service-service&#x2F;getservicedetail?servicename&#x3D;cas-server-service</span><br><span class="line">2021-11-04 09:23:16.834:147 [http-nio2-2001-exec-2] DEBUG org.springframework.web.client.RestTemplate -Accept&#x3D;[text&#x2F;plain, application&#x2F;json, application&#x2F;*+json, *&#x2F;*]</span><br><span class="line">2021-11-04 09:23:16.859:255 [http-nio2-2001-exec-2] DEBUG org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor -Using &#39;text&#x2F;html&#39;, given [text&#x2F;html, application&#x2F;xhtml+xml, image&#x2F;avif, image&#x2F;webp, image&#x2F;apng, application&#x2F;xml;q&#x3D;0.9, application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9, *&#x2F;*;q&#x3D;0.8] and supported [text&#x2F;plain, *&#x2F;*, text&#x2F;plain, *&#x2F;*, application&#x2F;json, application&#x2F;*+json, application&#x2F;json, application&#x2F;*+json]</span><br><span class="line">2021-11-04 09:23:16.860:91 [http-nio2-2001-exec-2] DEBUG org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor -Writing [&quot;&quot;]</span><br></pre></td></tr></table></figure><p>如果走 mode 为<code>POD</code>的 Ribbon 的负载均衡：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2021-11-04 09:34:32.188:147 [http-nio2-2001-exec-2] DEBUG org.springframework.web.client.RestTemplate -HTTP GET http:&#x2F;&#x2F;diff-ns-service-service&#x2F;getservicedetail?servicename&#x3D;cas-server-service</span><br><span class="line">2021-11-04 09:34:32.193:147 [http-nio2-2001-exec-2] DEBUG org.springframework.web.client.RestTemplate -Accept&#x3D;[text&#x2F;plain, application&#x2F;json, application&#x2F;*+json, *&#x2F;*]</span><br><span class="line">2021-11-04 09:34:32.261:115 [http-nio2-2001-exec-2] INFO  com.netflix.config.ChainedDynamicProperty -Flipping property: diff-ns-service-service.ribbon.ActiveConnectionsLimit to use NEXT property: niws.loadbalancer.availabilityFilteringRule.activeConnectionsLimit &#x3D; 2147483647</span><br><span class="line">2021-11-04 09:34:32.271:197 [http-nio2-2001-exec-2] INFO  com.netflix.loadbalancer.BaseLoadBalancer -Client: diff-ns-service-service instantiated a LoadBalancer: DynamicServerListLoadBalancer:&#123;NFLoadBalancer:name&#x3D;diff-ns-service-service,current list of Servers&#x3D;[],Load balancer stats&#x3D;Zone stats: &#123;&#125;,Server stats: []&#125;ServerList:null</span><br><span class="line">2021-11-04 09:34:32.278:222 [http-nio2-2001-exec-2] INFO  com.netflix.loadbalancer.DynamicServerListLoadBalancer -Using serverListUpdater PollingServerListUpdater</span><br><span class="line">2021-11-04 09:34:32.281:88 [http-nio2-2001-exec-2] WARN  org.springframework.cloud.kubernetes.ribbon.KubernetesEndpointsServerList -Did not find any endpoints in ribbon in namespace [system-server] for name [diff-ns-service-service] and portName [null]</span><br><span class="line">2021-11-04 09:34:32.282:150 [http-nio2-2001-exec-2] INFO  com.netflix.loadbalancer.DynamicServerListLoadBalancer -DynamicServerListLoadBalancer for client diff-ns-service-service initialized: DynamicServerListLoadBalancer:&#123;NFLoadBalancer:name&#x3D;diff-ns-service-service,current list of Servers&#x3D;[],Load balancer stats&#x3D;Zone stats: &#123;&#125;,Server stats: []&#125;ServerList:org.springframework.cloud.kubernetes.ribbon.KubernetesEndpointsServerList@d48bf01</span><br><span class="line">2021-11-04 09:34:32.308:255 [http-nio2-2001-exec-2] DEBUG org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor -Using &#39;text&#x2F;html&#39;, given [text&#x2F;html, application&#x2F;xhtml+xml, image&#x2F;avif, image&#x2F;webp, image&#x2F;apng, application&#x2F;xml;q&#x3D;0.9, application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9, *&#x2F;*;q&#x3D;0.8] and supported [text&#x2F;plain, *&#x2F;*, text&#x2F;plain, *&#x2F;*, application&#x2F;json, application&#x2F;*+json, application&#x2F;json, application&#x2F;*+json]</span><br><span class="line">2021-11-04 09:34:32.309:91 [http-nio2-2001-exec-2] DEBUG org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor -Writing [&quot;&quot;]</span><br><span class="line">2021-11-04 09:34:32.316:1131 [http-nio2-2001-exec-2] DEBUG org.springframework.web.servlet.DispatcherServlet -Completed 200 OK</span><br></pre></td></tr></table></figure><p>此时，给我的感觉就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    kubernetes:</span><br><span class="line">      ribbon:</span><br><span class="line">        #直接走k8s的LB</span><br><span class="line">        mode: SERVICE #POD走ribbon的LB</span><br><span class="line">      discovery:</span><br><span class="line">        all-namespaces: true</span><br></pre></td></tr></table></figure><p>此类配置是无法进行 Service 到应用服务的访问，只能访问到 Service。同时我们看到日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021-11-04 09:34:32.281:88 [http-nio2-2001-exec-2] WARN  org.springframework.cloud.kubernetes.ribbon.KubernetesEndpointsServerList -Did not find any endpoints in ribbon in namespace [system-server] for name [diff-ns-service-service] and portName [null]</span><br></pre></td></tr></table></figure><p>上面给到的是 mode 为 POD 时，走的 Ribbon 的负载均衡后，无法找到当前 pod 对应的 NS 下的 Servcie 为 diff-ns-service-service 的服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021-11-04 09:20:27.109:89 [PollingServerListUpdater-1] WARN  org.springframework.cloud.kubernetes.ribbon.KubernetesServicesServerList -Did not find any service in ribbon in namespace [system-server] for name [diff-ns-service-service] and portName [null]</span><br></pre></td></tr></table></figure><p>同样地，当 mode 为 SERVICE 时，依然无法找到当前 pod 的对应的 NS 的 Servcie 为 diff-ns-service-service 的服务。</p><p>同样会拿不到请求返回信息，这里说明：<code>在不同NS下，Service为ClusterIP，不管如何负载均衡，都无法访问。</code></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h4 id="一、通过-Springcloud-k8s-社区来实现跨-NS-下的服务的相互访问的简单策略"><a href="#一、通过-Springcloud-k8s-社区来实现跨-NS-下的服务的相互访问的简单策略" class="headerlink" title="一、通过 Springcloud k8s 社区来实现跨 NS 下的服务的相互访问的简单策略"></a>一、通过 Springcloud k8s 社区来实现跨 NS 下的服务的相互访问的简单策略</h4><h4 id="二、走-K8s-的原生的负载均衡策略"><a href="#二、走-K8s-的原生的负载均衡策略" class="headerlink" title="二、走 K8s 的原生的负载均衡策略"></a>二、走 K8s 的原生的负载均衡策略</h4><p>从前面的分析可以看到：虽然 spring-cloud-k8s 帮我们发现了 Service，但在底层策略时，不同的NS还是做了隔离，只能通过 k8s 原生的方式来进行服务的发现：<code>&lt;servicename&gt;.&lt;namespace&gt;.svc.cluster.local</code></p><p>PS：<code>同时，我们需要注意的是，此时基于 k8s 负载均衡，我们不能再基于 Ribbon 或其他来进行负载均衡机制了，直接通过 Http 协议来请求 k8s 的 service，实现跨 NS 的 pod 之间的互通。</code></p><br><br><p><span class="suffix" style="display: none;"></span></h6></p><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码:</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;">https://gitee.com/damon_one/spring-cloud-k8s</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">程序猿Damon</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://www.damon8.cn" style="text-decoration: none" title="">Damon | Micro-Service | Containerization | DevOps</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：程序猿Damon"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Unit one --><p><ins class="adsbygoogle"     style="display:inline-block;text-align:center;width:880px;height:150px"     data-ad-client="ca-pub-1354758384344627"     data-ad-slot="8964778819"></ins></p><script>    (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Springcloud Oauth2 HA篇</title>
    <link href="http://www.damon8.cn/2021/10/11/oauth-ha/"/>
    <id>http://www.damon8.cn/2021/10/11/oauth-ha/</id>
    <published>2021-10-11T07:17:58.000Z</published>
    <updated>2021-11-12T01:41:00.381Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 <a href="https://juejin.cn/post/6970882539820941325" target="_blank" rel="noopener">浅谈微服务安全架构设计</a> 一文中，介绍了基于Springcloud 结合了Oauth2分析了其各种模式下的鉴权认证，今天主要分析如何结合k8s作实现鉴权的高可用。</p><p>假设我们的项目中有几个模块：</p><ul><li>鉴权中心：Oauth2服务</li><li>订单系统：客户端A</li><li>用户管理系统：客户端B</li></ul><p>在上面的系统中，每个服务之间的耦合性很低，但是又有着很频繁的调用，这就涉及到UI与其之间的频繁流量交互。如何做到其HA，这里引入k8s的Service方法：</p><p>在 <a href="https://juejin.cn/post/6974562663833534494" target="_blank" rel="noopener">Spring Cloud Kubernetes之实战服务注册与发现</a>一文中，就讲解了k8s的Service方式创建服务，然后可以部署多个pod，同时结合 <a href="https://juejin.cn/post/6977498328153980959" target="_blank" rel="noopener">Spring Cloud Kubernetes之实战网关Gateway</a> 来实现LB，类似通过域名来解析其服务，并根据所定义的规则进行LB。同样，本文则是Oauth2的基础上，结合这些来实现微服务的LB。同时此处利用了k8s来作主要处理，如果是其他语言(Python、Go、Rust等)的客户端服务，则自身可以通过逻辑来控制其鉴权以及获取流量的。</p><p><code>注意点：由于各微服务与鉴权中心有交互，故鉴权中心需要提供HA服务，即先在启动类加入@EnableDiscoveryClient ，后续在注入bean时，@LoadBalanced来实现LB鉴权中心。</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@EnableOAuth2Sso</span><br><span class="line">@Configuration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(basePackages &#x3D; &#123;&quot;com.damon&quot;&#125;)</span><br><span class="line">@EnableConfigurationProperties(EnvConfig.class)</span><br><span class="line">@EnableDiscoveryClient #为LB多节点鉴权中心准备</span><br><span class="line">public class AdminApp &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(AdminApp.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端项目模块中，调用鉴权中心时，需要实现LB：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class BeansConfig &#123;</span><br><span class="line">  @Resource</span><br><span class="line">  private Environment env;</span><br><span class="line"></span><br><span class="line">  @LoadBalanced</span><br><span class="line">  @Bean</span><br><span class="line">  public RestTemplate restTemplate() &#123;</span><br><span class="line">    SimpleClientHttpRequestFactory requestFactory &#x3D; new SimpleClientHttpRequestFactory();</span><br><span class="line">    requestFactory.setReadTimeout(env.getProperty(&quot;client.http.request.readTimeout&quot;, Integer.class, 15000));</span><br><span class="line">    requestFactory.setConnectTimeout(env.getProperty(&quot;client.http.request.connectTimeout&quot;, Integer.class, 3000));</span><br><span class="line">    RestTemplate rt &#x3D; new RestTemplate(requestFactory);</span><br><span class="line">    return rt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外本身在配置交互的时候，需要加上域名等形式来实现LB，这里利用了k8s的Service来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cas-server-url: http:&#x2F;&#x2F;cas-server-service #这里配置成HA地址</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  oauth2: #与cas-server对应的配置</span><br><span class="line">    client:</span><br><span class="line">      client-id: admin-web</span><br><span class="line">      client-secret: admin-web-123</span><br><span class="line">      user-authorization-uri: $&#123;cas-server-url&#125;&#x2F;oauth&#x2F;authorize #是授权码认证方式需要的</span><br><span class="line">      access-token-uri: $&#123;cas-server-url&#125;&#x2F;oauth&#x2F;token #是密码模式需要用到的获取 token 的接口</span><br><span class="line">    resource:</span><br><span class="line">      loadBalanced: true</span><br><span class="line">      id: admin-web</span><br><span class="line">      user-info-uri: $&#123;cas-server-url&#125;&#x2F;api&#x2F;user #指定user info的URI</span><br><span class="line">      prefer-token-info: false</span><br></pre></td></tr></table></figure><p>这样，一个客户端关于鉴权的核心就是如此了，同样需要把消费客户端以service形式提供给UI，此时需要借助 <a href="">Spring Cloud Kubernetes之实战网关Gateway</a> 和nginx代理服务，我们来测试下：<code>curl -X POST -d &quot;username=admin&amp;password=123456&amp;grant_type=password&amp;client_id=admin-web&amp;client_secret=admin-web-123&quot; http://192.168.8.10:5556/cas-server/oauth/token</code></p><p>看到结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;access_token&quot;:&quot;5a7892b0-7483-4f60-89fd-44255a429ff6&quot;,&quot;token_type&quot;:&quot;bearer&quot;,&quot;refresh_token&quot;:&quot;23f2e8ea-f091-4ab0-822c-f28bebc4ec08&quot;,&quot;expires_in&quot;:3599,&quot;scope&quot;:&quot;all&quot;&#125;</span><br></pre></td></tr></table></figure><p>通过获取到的access_token来访问对应的客户端：<code>curl -H &quot;Accept: application/json&quot; -H &quot;Authorization:bearer 5a7892b0-7483-4f60-89fd-44255a429ff6&quot; -X GET http://192.168.8.10:5556/admin-web/api/user/getCurrentUser</code></p><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;authorities&quot;:[&#123;&quot;authority&quot;:&quot;admin&quot;&#125;],&quot;details&quot;:&#123;&quot;remoteAddress&quot;:&quot;10.244.0.196&quot;,&quot;sessionId&quot;:null,&quot;tokenValue&quot;:&quot;5a7892b0-7483-4f60-89fd-44255a429ff6&quot;,&quot;tokenType&quot;:&quot;bearer&quot;,&quot;decodedDetails&quot;:null&#125;,&quot;authenticated&quot;:true,&quot;userAuthentication&quot;:&#123;&quot;authorities&quot;:[&#123;&quot;authority&quot;:&quot;admin&quot;&#125;],&quot;details&quot;:&#123;&quot;authorities&quot;:[&#123;&quot;authority&quot;:&quot;admin&quot;&#125;],&quot;details&quot;:&#123;&quot;remoteAddress&quot;:&quot;10.244.0.201&quot;,&quot;sessionId&quot;:null,&quot;tokenValue&quot;:&quot;5a7892b0-7483-4f60-89fd-44255a429ff6&quot;,&quot;tokenType&quot;:&quot;Bearer&quot;,&quot;decodedDetails&quot;:null&#125;,&quot;authenticated&quot;:true,&quot;userAuthentication&quot;:&#123;&quot;authorities&quot;:[&#123;&quot;authority&quot;:&quot;admin&quot;&#125;],&quot;details&quot;:&#123;&quot;client_secret&quot;:&quot;admin-web-123&quot;,&quot;grant_type&quot;:&quot;password&quot;,&quot;client_id&quot;:&quot;admin-web&quot;,&quot;username&quot;:&quot;admin&quot;&#125;,&quot;authenticated&quot;:true,&quot;principal&quot;:&#123;&quot;password&quot;:null,&quot;username&quot;:&quot;admin&quot;,&quot;authorities&quot;:[&#123;&quot;authority&quot;:&quot;admin&quot;&#125;],&quot;accountNonExpired&quot;:true,&quot;accountNonLocked&quot;:true,&quot;credentialsNonExpired&quot;:true,&quot;enabled&quot;:true&#125;,&quot;credentials&quot;:null,&quot;name&quot;:&quot;admin&quot;&#125;,&quot;oauth2Request&quot;:&#123;&quot;clientId&quot;:&quot;admin-web&quot;,&quot;scope&quot;:[&quot;all&quot;],&quot;requestParameters&quot;:&#123;&quot;grant_type&quot;:&quot;password&quot;,&quot;client_id&quot;:&quot;admin-web&quot;,&quot;username&quot;:&quot;admin&quot;&#125;,&quot;resourceIds&quot;:[],&quot;authorities&quot;:[],&quot;approved&quot;:true,&quot;refresh&quot;:false,&quot;redirectUri&quot;:null,&quot;responseTypes&quot;:[],&quot;extensions&quot;:&#123;&#125;,&quot;grantType&quot;:&quot;password&quot;,&quot;refreshTokenRequest&quot;:null&#125;………</span><br></pre></td></tr></table></figure><p>最后，这里鉴权的高可用通过k8s的service，进行默认的轮询方式的访问鉴权中心，鉴权中心如果鉴权时不管使用redis还是jwt，来管理token，都是可以的。</p><br><br><p><span class="suffix" style="display: none;"></span></h6></p><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码:</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;">https://gitee.com/damon_one/spring-cloud-k8s</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">程序猿Damon</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://www.damon8.cn" style="text-decoration: none" title="">Damon | Micro-Service | Containerization | DevOps</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：程序猿Damon"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Unit one --><p><ins class="adsbygoogle"     style="display:inline-block;text-align:center;width:880px;height:150px"     data-ad-client="ca-pub-1354758384344627"     data-ad-slot="8964778819"></ins></p><script>    (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Jupyter Notebook 的使用</title>
    <link href="http://www.damon8.cn/2021/07/12/jupyter/"/>
    <id>http://www.damon8.cn/2021/07/12/jupyter/</id>
    <published>2021-07-12T09:45:47.000Z</published>
    <updated>2021-07-15T09:17:37.427Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="深度学习编程常用工具"><a href="#深度学习编程常用工具" class="headerlink" title="深度学习编程常用工具"></a>深度学习编程常用工具</h2><p>我们先来看 4 个常用的编程工具：Sublime Text、Vim、Jupyter。虽然我介绍的是 Jupyter，但并不是要求你必须使用它，你也可以根据自己的喜好自由选择。</p><h3 id="Sublime-Text"><a href="#Sublime-Text" class="headerlink" title="Sublime Text"></a>Sublime Text</h3><p>第一个是 Sublime Text，它是一个非常轻量且强大的文本编辑工具，内置了很多快捷的功能，同时还支持很丰富的插件功能，对我们来说非常方便。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfeb7e6743984c8797599c30e4b39c3d~tplv-k3u1fbpfcp-watermark.image" alt="1625538727(1).jpg"></p><p>如上图所示，它可以自动为项目中的类、方法和函数生成索引，我们让我们可以跟踪代码。可以通过它的 goto anything 功能，根据一些关键字查找到项目中的对应的代码行。</p><h3 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h3><p>第二个是 Vim，它是 Linux 系统中的文本编辑工具，方便快捷且强大，我们在项目中经常会使用到。</p><p>在我们的项目中，经常需要登录到服务器上进行开发，而服务器一般都是 Linux 系统，不会有 Sublime Text 与 Pycharm，所以我们可以直接用 Vim 打开代码进行编辑。对于没有接触过 Linux 或者是一直使用 IDE 进行编程开发的同学，一开始可能觉得不是很方便，但 Vim 的快捷键十分丰富，对于 Shell 与 Python 的开发来说非常便捷。</p><p>Vim 的缺点正如刚才所说，有一点点门槛，需要你去学习它的使用方法。只要你学会了，我保证你将对它爱不释手。</p><h3 id="Jupyter-Notebook-amp-Lab"><a href="#Jupyter-Notebook-amp-Lab" class="headerlink" title="Jupyter Notebook &amp; Lab"></a>Jupyter Notebook &amp; Lab</h3><p>最后一个是今天要介绍的 Jupyter Notebook 了，它是一个开源的 Web 应用，能够让你创建、分享包含可执行代码、可视化结构和文字说明的文档。</p><p>Jupyter Notebook 的应用非常广泛，它可以用在数据清理与转换、数字模拟、统计模型、数据可视化、机器学习等方面。</p><p>Jupyter Notebooks 非常活跃于深度学习领域。在项目的实验测试阶段，它相比于用 py 文件来直接编程还是方便一些。在项目结束之后如果要写项目报告，用 Jupyter 也比较合适。</p><p>简单介绍之后，我们接下来就从 Jupyter 的功能、Jupyter 的安装与启动与 Jupyter Lab 的操作这 3 个方面学习 Jupyter。</p><h2 id="Jupyter-Notebook-amp-Lab-的功能"><a href="#Jupyter-Notebook-amp-Lab-的功能" class="headerlink" title="Jupyter Notebook &amp; Lab 的功能"></a>Jupyter Notebook &amp; Lab 的功能</h2><p>Jupyter 主要有以下 3 点的作用：执行代码、数据可视化以及使用 Markdown 功能写报告。</p><ul><li><strong>执行代码</strong>。一般是 Python 程序，也可以添加新的编程语言。</li><li><strong>数据可视化</strong>。设想一下，我们经常在 Linux 环境编程开发，如果需要对数据可视化该怎么办呢？是不是只能把图片保存下来，然后下载到本地进行查看？使用 Jupyter Notebook 就不用多此一举，我们可以直接在页面中查看。如下图所示：</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6209a42f5ae4c3196ca5277525edc86~tplv-k3u1fbpfcp-watermark.image" alt="图片.png"></p><ul><li><strong>使用 Markdown 功能写文档</strong>，或者制作 PPT。这些文档中还包含代码以及代码执行后的结果，非常有助于你书写项目报告。</li></ul><h2 id="Jupyter-Notebook-amp-Lab-的安装与启动"><a href="#Jupyter-Notebook-amp-Lab-的安装与启动" class="headerlink" title="Jupyter Notebook &amp; Lab 的安装与启动"></a>Jupyter Notebook &amp; Lab 的安装与启动</h2><p>了解了 Jupyter 的功能之后，我们来看看具体要如何进行安装与启动。这一节我介绍了 3 种安装和启动的方式，分别是 Anaconda、Docker 和 pip。</p><h3 id="使用-Anaconda-安装与启动"><a href="#使用-Anaconda-安装与启动" class="headerlink" title="使用 Anaconda 安装与启动"></a>使用 Anaconda 安装与启动</h3><p>我们先来看如何使用 Anaconda 来安装与启动。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>最简单的方法是通过安装 Anaconda 来使用 Jupyter Notebook &amp; Lab。Anaconda 已自动安装了 Jupter Notebook 及其他工具，还有 Python 中超过 180 个科学包及其依赖项。你可以通过 Anaconda 的官方网站得到 Anaconda 的下载工具。</p><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>这里我会分 MacOS 系统和 Win 环境来讲解。</p><p>（1）MacOS 系统</p><p>安装完 Anaconda 之后，打开终端后系统会默认进入 base 环境。</p><p>在命令行最前面有个<strong>(base)</strong>的标志则表示代码进入 base 环境了，如果没有就需要通过下面的命令激活 base 环境：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate base</span><br></pre></td></tr></table></figure><p>在 base 环境下执行下面的命令，会自动进入 Jupyte Notebook 的开发环境。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><p>执行下面的命令，则会自动进入到 Jupyter Lab 的开发环境。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter lab</span><br></pre></td></tr></table></figure><p>（2）Win 环境</p><p>Windows 环境中的启动方式与 MacOS 基本一样。</p><p>当你想通过命令 Jupyter Notebook 或 Jupyter Lab 启动时，你需要在 Anaconda Prompt 中执行。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b07bc943d80b4a5e9f11f41403a0973c~tplv-k3u1fbpfcp-watermark.image" alt="图片.png"></p><p>通过 Anaconda Navigator 启动的方式与 MacOS 一样。</p><h3 id="使用-Docker"><a href="#使用-Docker" class="headerlink" title="使用 Docker"></a>使用 Docker</h3><p>通过 Docker 使用 Jupyter 也非常简单，连安装都不需要，但前提是你要有 Docker 相关的知识。</p><h3 id="使用-pip-安装与启动"><a href="#使用-pip-安装与启动" class="headerlink" title="使用 pip 安装与启动"></a>使用 pip 安装与启动</h3><p>了解完 Anaconda 和 Docker 的安装与启动方式后，我们最后来看 pip 是如何安装和启动的。</p><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>通过 pip 安装 Jupyter Notebook：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Jupyter</span><br></pre></td></tr></table></figure><p>通过 pip 安装 Jupyter Lab：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Jupyterlab</span><br></pre></td></tr></table></figure><h4 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h4><p>安装完成后，直接在终端执行 Jupyter Notebok 或 Jupyter Lab 命令启动。</p><p>不管在 MacOS 系统还是在 Windows 系统，通过以上任意一种方式成功启动后，浏览器都会自动打开 Jupyter Notebook 或 Jupyter Lab 的开发环境:</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec1235e0b1004723990c343b6956291d~tplv-k3u1fbpfcp-watermark.image" alt="bd2c4bd7559b0eba46fee22e41eda79.png"></p><h2 id="Jupyter-Lab-的操作"><a href="#Jupyter-Lab-的操作" class="headerlink" title="Jupyter Lab 的操作"></a>Jupyter Lab 的操作</h2><p>Jupyter Lab 是 Jupyter Notebook 的下一代产品，在使用方式上更为灵活、便捷。</p><p>我们在命令行或者 Anaconda Navigator 中启动 Jupyter Lab 之后，浏览器会自动打开如下所示的 Jupyter Lab 界面：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3718f1af4004d68bc385602819b4927~tplv-k3u1fbpfcp-watermark.image" alt="1625538963(1).jpg"></p><p>最左侧显示的是你启动时所在的目录，右侧是你可以使用的一些开发工具。</p><h3 id="Notebook"><a href="#Notebook" class="headerlink" title="Notebook"></a>Notebook</h3><p>点击 Notebook 下面的“Python 3”的图标之后，就会自动新建一个 Notebook。</p><ul><li><p>Jypter Lab 与 Jupyter Notebook 中都会用到这个叫作 Notebook 的编辑工具。</p></li><li><p>Jupyter Lab 与 Jupyter Notebook 不同的地方是 IDE 的界面以及操作方式，这里讲解用的是 Jupyter Lab 的操作。</p></li></ul><p>一个 Notebook 的编辑界面主要由 4 个部分组成：菜单栏、工具栏、单元格（Cell）以及内核。如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/729b1c5e8545477da2a0dd662ac3b51a~tplv-k3u1fbpfcp-watermark.image" alt="图片.png"></p><p>菜单栏与工具栏这里就不详细介绍了。我们先来看单元格（Cell），然后再介绍内核。</p><h4 id="单元格（Cell）"><a href="#单元格（Cell）" class="headerlink" title="单元格（Cell）"></a>单元格（Cell）</h4><p>单元格是我们 Notebook 的主要内容，这里我会介绍两种单元格。</p><ul><li><p>Code 单元格：包含可以在内核运行的代码，并且在单元格下方输出运行结果。</p></li><li><p>Markdown 单元格：包含运用 Markdown 的文档，常用于文档的说明，也是可以运行的单元格。</p></li></ul><p>从 Code 单元格切换到 Markdown 单元格的切换的快捷键是 m；从 Markdown 单元格切换到 Code 单元格的切换的快捷键是 y。</p><p><strong>切换之前需要先按 Esc，从单元格的编辑状态中退出。</strong></p><p>在工具栏中也可以切换，但是还是快捷键方便些。工具栏的位置在下图中红框的位置：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/185623dcc6b54a139822fa5096dab47a~tplv-k3u1fbpfcp-watermark.image" alt="图片.png"></p><p>我们看一个例子。我编辑了下面的 Notebook。第一行是 1 个 Markdown 单元格，是 1 个一级标题，第二行是 1 个 Python 的代码。两行代码都是未运行状态。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1443a77e3a304bdf90f86f0e1bbd663a~tplv-k3u1fbpfcp-watermark.image" alt="图片.png"><br>你注意到左边那个蓝色的竖条了吗？它代表我们所在的单元格。</p><p>我们在编辑这个单元格的时候，左边是绿色的竖条。如果我们按 Esc 退出单元格，它就会变为蓝色。</p><p>退出单元格后，我们可以通过上下键移动选中的单元格。我们移动到第一行，然后开始运行这两个单元格。</p><p>运行单独一个单元格的快捷键 Ctrl+Enter，运行选中单元格并切换到下一个单元格的快捷键是 Shift + Enter。运行结果如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a555c931a70447389c7c75ee2d98506~tplv-k3u1fbpfcp-watermark.image" alt="图片.png"></p><p>Markdown 没有左边的“[]”标签，通过这一点你可以区分 Code 单元格与 Markdown 单元格。</p><p>“[]”中的数字代表单元格被执行的顺序，例子中“[1]”代表第一个被执行的单元格。</p><p>以上就是单元格的内容了。我们接下来看看，单元格中的一些快捷键的使用。</p><p><strong>（1）快捷键</strong></p><p>如果你是用 Jupyter 进行开发，掌握单元格的快捷键能让你的开发速度变得更快，下面我列举了几个常用的快捷键：</p><ul><li>执行单元格 Ctrl+Enter 或 Shift+Enter；</li><li>a 在单元格上方插入新的单元格；</li><li>b 在单元格下方插入新的单元格；</li><li>x 删除单元格；</li><li>z 撤销删除的单元格。</li></ul><p><strong>（2）Magic 命令</strong></p><p>Jupyter Notebook 的前身是 IPython Notebook，所以 Jupyter 也支持 IPython 的 Magic 命令。IPython 是一个比 Python 自带的 Shell 更加灵活方便的 Shell，它主要活跃于数据科学领域。</p><p>Magic 命令分两种：</p><ul><li><p>Line Magics 命令：在命令前面加%，表示只在本行有效</p></li><li><p>Cell Magics 命令：在命令前面加%%，表示在整个 Cell 单元有效。</p></li></ul><p>下面我介绍几个常用的 Magic 命令。</p><ul><li>%lsmagic：用来查看可以使用的 Magic 命令。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b547cab1c4740309b6acaa84e80dbb4~tplv-k3u1fbpfcp-watermark.image" alt="图片.png"></p><ul><li><p>%matplotlib inline：可以在单元格下面直接打印出 matplotlib 的图标，通常要在 matplotlib 模块引入之前使用；使用这个 Magic 命令之后，可以不用 plt.show()。</p></li><li><p>%pwd：查看当前的文件路径。</p></li><li><p>%%writefile：写文件，%%writefile 后面紧跟着文件名，然后下面写文件的内容。</p></li><li><p>%run： 运行一个文件，%run 后面跟着要运行的文件。</p></li><li><p>%load：加载文件。使用%load + 文件名可以把指定的文件加载到单元格内。请看下面的例子，我们要把 temp.py 加载到单元格里，首先是执行前，</p></li></ul><p><strong>（3）Markdown 命令</strong></p><p>了解了 Magic 命令后，我们再来看 Markdown 命令。Markdown 是一种在 Markdown 单元中用于格式化文本的语言，常用于 Notebook 的文档说明，我们列举了几个常用的命令。</p><ul><li>标题：通过井号的数目可以决定标题的大小。</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题：</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 二级标题：</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题：</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 四级标题：</span></span><br><span class="line"></span><br><span class="line"><span class="section">##### 五级标题：</span></span><br></pre></td></tr></table></figure><ul><li>列表：分为无序列表与有序列表。</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## 无序列表</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>项目 1</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>项目 2</span><br><span class="line"></span><br><span class="line"><span class="section">## 有序列表</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>项目 1 (1. 与项目 1 之间有一个空格)</span><br><span class="line"></span><br><span class="line"><span class="bullet">2. </span>项目 2</span><br></pre></td></tr></table></figure><ul><li>字体：可以通过”*”或者_的数目控制强调的内容，即斜体、加粗以及粗斜体。具体的请看下面的例子。<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**加粗**</span></span><br><span class="line"></span><br><span class="line"><span class="strong">***粗斜体**</span>*</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"><span class="emphasis">_斜体_</span></span><br><span class="line"></span><br><span class="line"><span class="strong">__加粗__</span></span><br><span class="line"></span><br><span class="line"><span class="strong">___粗斜体__</span>_</span><br></pre></td></tr></table></figure></li></ul><p><strong>（4）调用系统命令</strong></p><p>最后，在 Notebook 中还可以调用所在操作系统的命令，只需要在命令前加一个“!”就可以了。例如，在 Linux 系统中查看当前路径：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="built_in">pwd</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>云原生微服务架构实践</title>
    <link href="http://www.damon8.cn/2021/05/06/micro-cloud-native/"/>
    <id>http://www.damon8.cn/2021/05/06/micro-cloud-native/</id>
    <published>2021-05-06T12:58:51.000Z</published>
    <updated>2021-06-16T07:44:03.051Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="写作本书的目的"><a href="#写作本书的目的" class="headerlink" title="写作本书的目的"></a><strong>写作本书的目的</strong></h4><p>&emsp;&emsp;微服务架构已经火了很多年了，如：Dubbo、Spring Cloud，再到后来的 Spring Cloud Alibaba，但都是仅限于 Java 语言的瓶颈，如何让各种语言之间的微服务更加有效、快速的通讯，这是当前很多企业需要面临的问题，因为一个企业中，不只是基于单纯的某一种语言开发，这就涉及到多语言服务之间的访问。本书的创作重点，则是在于讲述在巨多语言的情况下，该如何设计微服务架构，以及云原生时代的微服务的高可用、自动化等等。</p><h4 id="如何阅读本书"><a href="#如何阅读本书" class="headerlink" title="如何阅读本书"></a><strong>如何阅读本书</strong></h4><p>&emsp;&emsp;由于本书介绍的一些知识都是比较流行的，最近几年很火的，而且本身其涉及的面还是很广的：<strong>K8s</strong>，大家可以通过其<a href="https://kubernetes.io/" target="_blank" rel="noopener">官网</a>系统的学习其相关技术与实践，以便可以更好的将其发挥于微服务架构设计中。另外，本书中介绍的知识，大家都可以一边实践、一边阅读，以便更深刻的理解其原理。</p><h4 id="扫码关注作者"><a href="#扫码关注作者" class="headerlink" title="扫码关注作者"></a><strong>扫码关注作者</strong></h4><ul><li><p>作者毕业于三流院校，笔名：Damon，拥有七年工作经验，技术爱好者，长期从事 Java 开发、Spring Cloud、Golang 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号：<strong>程序猿Damon</strong>，个站：<strong><a href="http://www.damon8.cn">www.damon8.cn</a></strong>。</p></li><li><p>欢迎扫码回复「入群」加入技术交流群</p></li></ul><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt=""></p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="第一部分-基础知识"><a href="#第一部分-基础知识" class="headerlink" title="第一部分 基础知识"></a>第一部分 基础知识</h4><h5 id="第一章-什么是微服务架构"><a href="#第一章-什么是微服务架构" class="headerlink" title="第一章 什么是微服务架构"></a>第一章 什么是微服务架构</h5><h6 id="1-1-微服务到底是啥"><a href="#1-1-微服务到底是啥" class="headerlink" title="1.1 微服务到底是啥"></a>1.1 微服务到底是啥</h6><h6 id="1-2-微服务的发展史"><a href="#1-2-微服务的发展史" class="headerlink" title="1.2 微服务的发展史"></a>1.2 微服务的发展史</h6><h6 id="1-3-微服务的革命性与重要性"><a href="#1-3-微服务的革命性与重要性" class="headerlink" title="1.3 微服务的革命性与重要性"></a>1.3 微服务的革命性与重要性</h6><h5 id="第二章-微服务的拆分"><a href="#第二章-微服务的拆分" class="headerlink" title="第二章 微服务的拆分"></a>第二章 微服务的拆分</h5><h6 id="2-1-微服务的设计原则"><a href="#2-1-微服务的设计原则" class="headerlink" title="2.1 微服务的设计原则"></a>2.1 微服务的设计原则</h6><h6 id="2-2-微服务划分的粒度"><a href="#2-2-微服务划分的粒度" class="headerlink" title="2.2 微服务划分的粒度"></a>2.2 微服务划分的粒度</h6><h6 id="2-3-不同场景的微服务"><a href="#2-3-不同场景的微服务" class="headerlink" title="2.3 不同场景的微服务"></a>2.3 不同场景的微服务</h6><h5 id="第三章-容器化技术"><a href="#第三章-容器化技术" class="headerlink" title="第三章 容器化技术"></a>第三章 容器化技术</h5><h6 id="3-1-什么是容器"><a href="#3-1-什么是容器" class="headerlink" title="3.1 什么是容器"></a>3.1 什么是容器</h6><h6 id="3-2-容器的发展进程"><a href="#3-2-容器的发展进程" class="headerlink" title="3.2 容器的发展进程"></a>3.2 容器的发展进程</h6><h6 id="3-3-Docker-与-Kubernetes"><a href="#3-3-Docker-与-Kubernetes" class="headerlink" title="3.3 Docker 与 Kubernetes"></a>3.3 Docker 与 Kubernetes</h6><h6 id="3-4-K8s-容器化应用"><a href="#3-4-K8s-容器化应用" class="headerlink" title="3.4 K8s 容器化应用"></a>3.4 K8s 容器化应用</h6><h5 id="第四章-为何借助容器助力微服务"><a href="#第四章-为何借助容器助力微服务" class="headerlink" title="第四章 为何借助容器助力微服务"></a>第四章 为何借助容器助力微服务</h5><h6 id="4-1-微服务的多语言性"><a href="#4-1-微服务的多语言性" class="headerlink" title="4.1 微服务的多语言性"></a>4.1 微服务的多语言性</h6><h6 id="4-2-微服务的高可用"><a href="#4-2-微服务的高可用" class="headerlink" title="4.2 微服务的高可用"></a>4.2 微服务的高可用</h6><h6 id="4-3-微服务的复杂性"><a href="#4-3-微服务的复杂性" class="headerlink" title="4.3 微服务的复杂性"></a>4.3 微服务的复杂性</h6><h4 id="第二部分-原理与应用"><a href="#第二部分-原理与应用" class="headerlink" title="第二部分 原理与应用"></a>第二部分 原理与应用</h4><h5 id="第五章-Kubernetes-介绍"><a href="#第五章-Kubernetes-介绍" class="headerlink" title="第五章 Kubernetes 介绍"></a>第五章 Kubernetes 介绍</h5><h6 id="5-1-Kubernetes-的基本概念与特性"><a href="#5-1-Kubernetes-的基本概念与特性" class="headerlink" title="5.1 Kubernetes 的基本概念与特性"></a>5.1 Kubernetes 的基本概念与特性</h6><h6 id="5-2-部署-Kubernetes-集群"><a href="#5-2-部署-Kubernetes-集群" class="headerlink" title="5.2 部署 Kubernetes 集群"></a>5.2 部署 Kubernetes 集群</h6><h6 id="5-3-Kubernetes-的组件及及负载均衡"><a href="#5-3-Kubernetes-的组件及及负载均衡" class="headerlink" title="5.3 Kubernetes 的组件及及负载均衡"></a>5.3 Kubernetes 的组件及及负载均衡</h6><h5 id="第六章-为什么选择-Kubernetes"><a href="#第六章-为什么选择-Kubernetes" class="headerlink" title="第六章 为什么选择 Kubernetes"></a>第六章 为什么选择 Kubernetes</h5><h6 id="6-1-Kubernetes-与微服务的天生绝配"><a href="#6-1-Kubernetes-与微服务的天生绝配" class="headerlink" title="6.1 Kubernetes 与微服务的天生绝配"></a>6.1 Kubernetes 与微服务的天生绝配</h6><h6 id="6-2-基于-Kubernetes-集群的服务治理"><a href="#6-2-基于-Kubernetes-集群的服务治理" class="headerlink" title="6.2 基于 Kubernetes 集群的服务治理"></a>6.2 基于 Kubernetes 集群的服务治理</h6><h6 id="6-3-基于-Kubernetes-的服务无缝迁移"><a href="#6-3-基于-Kubernetes-的服务无缝迁移" class="headerlink" title="6.3 基于 Kubernetes 的服务无缝迁移"></a>6.3 基于 Kubernetes 的服务无缝迁移</h6><h5 id="第七章-第一个基于-K8s-的多语言微服务架构"><a href="#第七章-第一个基于-K8s-的多语言微服务架构" class="headerlink" title="第七章 第一个基于 K8s 的多语言微服务架构"></a>第七章 第一个基于 K8s 的多语言微服务架构</h5><h6 id="7-1-基于-K8s-的-Java-微服务"><a href="#7-1-基于-K8s-的-Java-微服务" class="headerlink" title="7.1 基于 K8s 的 Java 微服务"></a>7.1 基于 K8s 的 Java 微服务</h6><h6 id="7-2-第一个Golang微服务"><a href="#7-2-第一个Golang微服务" class="headerlink" title="7.2 第一个Golang微服务"></a>7.2 第一个Golang微服务</h6><h6 id="7-3-部署微服务应用"><a href="#7-3-部署微服务应用" class="headerlink" title="7.3 部署微服务应用"></a>7.3 部署微服务应用</h6><br/><br/><br/><br/><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="第一部分-基础知识-1"><a href="#第一部分-基础知识-1" class="headerlink" title="第一部分 基础知识"></a>第一部分 基础知识</h4><h5 id="第一章-什么是微服务架构-1"><a href="#第一章-什么是微服务架构-1" class="headerlink" title="第一章 什么是微服务架构"></a>第一章 什么是微服务架构</h5><h6 id="1-1-微服务的发展史"><a href="#1-1-微服务的发展史" class="headerlink" title="1.1 微服务的发展史"></a>1.1 微服务的发展史</h6><p>&emsp;&emsp;在微服务到来之前，单体应用程序所暴露的缺点主要有：</p><ul><li>复杂性高</li><li>团队协作开发成本高</li><li>扩展性差</li><li>部署效率低下</li><li>系统很差的高可用性</li></ul><p>&emsp;&emsp;复杂性，体现在：随着业务的不断迭代，项目的代码量急剧的增多，项目模块也会随着而增加，整个项目就会变成的非常复杂。</p><p>&emsp;&emsp;开发成本高，体现在：团队开发几十个人在修改代码，然后一起合并到同一地址分支，打包部署，测试阶段只要有一小块功能有问题，就得重新编译打包部署，重新测试，所有相关的开发人员都得参与其中，效率低下，开发成本极高。</p><p>&emsp;&emsp;扩展性差，体现在：在新增功能业务的时候，代码层面会考虑在不影响现有的业务基础上编写代码，提高了代码的复杂性。</p><p>&emsp;&emsp;部署效率低，体现在：当单体应用的代码越来越多，依赖的资源越来越多时，应用编译打包、部署测试一次，需要花费的时间越来越多，导致部署效率低下。</p><p>&emsp;&emsp;高可用差，体现在：由于所有的业务功能最后都部署到同一个文件，一旦某一功能涉及的代码或者资源有问题，那就会影响到整个文件包部署的功能。举个特别鲜明的示例：上世纪八、九十年代，很多的黄页以及延伸到后来的网站中，很多的展示页面与获取数据的后端都是在一个服务模块中。这就造成一个很不好的影响：如果只是修改极小部分的页面展示或图片展示，则需要把整个服务模块进行打包部署，这样会导致时间的严重浪费以及成本的增加。更加糟糕的是，给用户带来非常不好的体验，用户无法理解的是：只是换个网站的某块微小的展示区，导致了整个网站在那一时刻无法正常的访问。当然，也许，对于那个时候互联网的不发达，人们对于这样的体验，已经算是一种幸福的享受了。</p><p>&emsp;&emsp;由于单体应用具有以上的种种缺点，导致了一个新名词、新概念的诞生：微服务。</p><h6 id="1-2-微服务到底是啥"><a href="#1-2-微服务到底是啥" class="headerlink" title="1.2 微服务到底是啥"></a>1.2 微服务到底是啥</h6><p>&emsp;&emsp;其实，从早年间的单体应用，到 2014 年起，得益于以 Docker 为代表的容器化技术的成熟以及 DevOps 文化的兴起，服务化的思想进一步演化，演变为今天我们所熟知的微服务。那么，微服务到底是啥？</p><p>&emsp;&emsp;微服务，英文名：microservice，百度百科上将其定义为：SOA 架构的一种变体。微服务（或微服务架构）是一种将应用程序构造为一组低耦合的服务。</p><p>&emsp;&emsp;微服务有着一些鲜明的特点：</p><ul><li>功能单一</li><li>服务粒度小</li><li>服务间独立性强</li><li>服务间依赖性弱</li><li>服务独立维护</li><li>服务独立部署</li></ul><p>&emsp;&emsp;对于每一个微服务来说，其提供的功能应该是单一的；其粒度很小的；它只会提供某一业务功能涉及到的相关接口。如：电商系统中的订单系统、支付系统、产品系统等，每一个系统服务都只是做该系统独立的功能，不会涉及到不属于它的功能逻辑。</p><p>&emsp;&emsp;微服务之间的依赖性应该是尽量弱的，这样带来的好处是：不会因为单一系统服务的宕机，而导致其它系统无法正常运行，从而影响用户的体验。同样以电商系统为例：用户将商品加入购物车后，提交订单，这时候去支付，发现无法支付，此时，可以将订单进入待支付状态，从而防止订单的丢失和用户体验的不友好。如果订单系统与支付系统的强依赖性，会导致订单系统一直在等待支付系统的回应，这样会导致用户的界面始终处于加载状态，从而导致用户无法进行任何操作。</p><p>&emsp;&emsp;当出现某个微服务的功能需要升级，或某个功能需要修复 bug 时，只需要把当前的服务进行编译、部署即可，不需要一个个打包整个产品业务功能的巨多服务，独立维护、独立部署。</p><p>&emsp;&emsp;上面描述的微服务，其实突出其鲜明特性：<strong>高内聚、低耦合</strong>，问题来了。什么是高内聚，什么是低耦合呢？所谓高内聚：就是说每个服务处于同一个网络或网域下，而且相对于外部，整个的是一个封闭的、安全的盒子。盒子对外的接口是不变的，盒子内部各模块之间的接口也是不变的，但是各模块内部的内容可以更改。模块只对外暴露最小限度的接口，避免强依赖关系。增删一个模块，应该只会影响有依赖关系的相关模块，无关的不应该受影响。</p><p>&emsp;&emsp;所谓低耦合：从小的角度来看，就是要每个 Java 类之间的耦合性降低，多用接口，利用 Java 面向对象编程思想的封装、继承、多态，隐藏实现细节。从模块之间来讲，就是要每个模块之间的关系降低，减少冗余、重复、交叉的复杂度，模块功能划分尽可能单一。</p><h6 id="1-3-微服务的革命性与重要性-1"><a href="#1-3-微服务的革命性与重要性-1" class="headerlink" title="1.3 微服务的革命性与重要性"></a>1.3 微服务的革命性与重要性</h6><p>&emsp;&emsp;上一小节讲述了什么是微服务，微服务的鲜明特性。其实，从单体应用看微服务，就能看出微服务的重要性，它是彻底改革了应用程序的惯性，它的设计理念的出现：让开发人员减少大量的开发成本以及修复成本；让产品的使用者拥有一种舒适的体验感。它解决了单体应用程序的很多难以解决的问题，更具有创新性。它让我们的系统尽可能快地响应变化。</p><p>&emsp;&emsp;微服务将原来耦合在一起的复杂业务拆分为单个服务，规避了原本复杂度无止境的积累，每一个微服务专注于单一功能，并通过定义良好的接口清晰表述服务边界。</p><p>&emsp;&emsp;由于微服务具备独立的运行进程，所以每个微服务可以独立部署。当业务迭代时只需要发布相关服务的迭代即可，降低了测试的工作量同时也降低了服务发布的风险。</p><p>&emsp;&emsp;在微服务架构下，当某一组件发生故障时，故障会被隔离在单个服务中。如通过限流、熔断等方式降低错误导致的危害，保障核心业务的正常运行。</p><h5 id="第二章-微服务的拆分-1"><a href="#第二章-微服务的拆分-1" class="headerlink" title="第二章 微服务的拆分"></a>第二章 微服务的拆分</h5><h6 id="2-1-微服务的设计原则-1"><a href="#2-1-微服务的设计原则-1" class="headerlink" title="2.1 微服务的设计原则"></a>2.1 微服务的设计原则</h6><ul><li>高内聚、低耦合</li></ul><p>&emsp;&emsp;紧密关联的事应该放在一起，每个服务是针对一个单一职责的业务能力的封装，需要专注于做好一件事情。这样避免内容耦合，降低代码的冗余，提高代码的可复用性。</p><p>&emsp;&emsp;避免服务之间的数据库的共享。这样既可以减少数据库的并发操作，又可以避免死锁的出现。通常微服务不会直接共用一个数据库，可以通过主、从表的方式来进行，结合读、写分离，实现数据的共享。</p><p>&emsp;&emsp;微服务之间应该是轻量级的通信方式，主要是为了解耦，降低业务的复杂性，以及服务的负载。一个服务调用另一个服务应该是不受到后者的牵制，如果后者发生宕机，前者应该照样继续运行下去，这才是微服务设计时的合理安排。为了降低前者的不受牵制，这就需要轻量级的通信，比如：异步调用、重试策略等。</p><ul><li>以业务为中心</li></ul><p>&emsp;&emsp;每个服务代表了特定的业务逻辑，不应该掺着其他业务的逻辑，或微不足道的、公共的逻辑。</p><p>&emsp;&emsp;围绕业务开展，主要就当前业务进行扩展。</p><p>&emsp;&emsp;能快速的响应业务的变化，需要做到接口的兼容性，兼容业务场景的变化，这样减少变动太大带来的风险。</p><p>&emsp;&emsp;隔离实现细节，让业务领域可以被重用，需要以封装接口形式来实现业务逻辑，这就涉及到代码的复用性。引用 Java 的原理：封装、继承、多态。</p><ul><li>弹性容错设计</li></ul><p>&emsp;&emsp;设计可容错的系统：拥抱失败，为已知的错误而设计，这主要是为了增强交互。</p><p>&emsp;&emsp;可防御的系统：服务降级、服务隔离、请求限制、防止级联错误等，这也是为了增强交互的友好。</p><ul><li>自治和高可用</li></ul><p>&emsp;&emsp;独立开发和业务扩展，这就涉及到服务随着业务的发展而进行兼容、合理的扩展后的高度自治。</p><p>&emsp;&emsp;独立部署、运行和高可用，避免单点的孤注一掷。</p><ul><li>日志与监控</li></ul><p>&emsp;&emsp;聚合系统日志、数据，从而当遇到问题时，可以深入分析原因。</p><p>&emsp;&emsp;当需要重现问题时，可以根据日志以及监控来复盘。</p><p>&emsp;&emsp;监控主要包括服务状态、请求流量、调用链、API 错误计数，结构化的日志、服务依赖关系可视化等内容，以便发现问题及时修复，实时调整系统负载，必要时进行服务降级，过载保护等等，从而让系统和环境提供高效高质量的服务。</p><ul><li>自动化</li></ul><p>&emsp;&emsp;降低部署和发布的难度，如：在持续集成和持续交付中，自动化编译，测试，安全扫描，打包，集成测试，部署。随着服务越来越多，在发布过程中，需要进一步自动化金丝雀部署。</p><p>&emsp;&emsp;利用 K8s 等进行服务自动弹性伸缩等。</p><h6 id="2-2-微服务划分的粒度-1"><a href="#2-2-微服务划分的粒度-1" class="headerlink" title="2.2 微服务划分的粒度"></a>2.2 微服务划分的粒度</h6><p>&emsp;&emsp;服务的划分，可以从水平的功能划分，也可从垂直的业务划分，粒度的大小，可以根据当前的产品需求来定位，最关键的是要做到：<strong>高内聚、低耦合</strong>。</p><p>&emsp;&emsp;如电商系统为例，如下图：</p><p><img src="https://static001.geekbang.org/infoq/cc/cc086c43f4f5b547f2e3405d26ff7ae8.jpeg" alt=""></p><p>&emsp;&emsp;电商中涉及到业务很可能是最多的，商品、库存、订单、促销、支付、会员、购物车、发票、店铺等等，这个是根据业务的不同来进行模块的划分。微服务划分的粒度一定是要有明确性的，不能因为含糊而新增一个服务模块，这样会导致功能接口的可复用性差。一个好的架构设计，肯定是可复用性很强的结构模式。我喜欢这样的一句话：<strong>微服务的边界 (粒度) 是 “决策”, 而不是个 “标准答案”</strong>。即应该将各微服务划分的方式，深度思考，周全的考量各方面的因素下，所作出的一个”最适合”的架构决策，而不是一个人芸亦芸的”标准答案“。</p><h6 id="2-3-不同场景的微服务-1"><a href="#2-3-不同场景的微服务-1" class="headerlink" title="2.3 不同场景的微服务"></a>2.3 不同场景的微服务</h6><p>&emsp;&emsp;微服务的应用场景也是很多的，电商场景是比较常见的，比如阿里的体系：淘宝、支付宝、钉钉、饿了么、咸鱼、口碑等。电商场景的微服务实相对比较复杂的，所以需要更好的做好微服务的拆分以及扩展。</p><p>&emsp;&emsp;金融系统中也存在微服务的场景，比如：银行系统、证券系统、金融公司、机构。其需要考虑的重点是微服务的安全性、可靠性。</p><h5 id="第三章-容器化技术-1"><a href="#第三章-容器化技术-1" class="headerlink" title="第三章 容器化技术"></a>第三章 容器化技术</h5><h6 id="3-1-什么是容器-1"><a href="#3-1-什么是容器-1" class="headerlink" title="3.1 什么是容器"></a>3.1 什么是容器</h6><p>&emsp;&emsp;什么是容器呢？自然界的解释：容器是指用以容纳物料并以壳体为主的基本装置。但今天讲的容器也是一个容纳物质的载体。那计算机所指的容器(Container)到底是什么呢？容器是镜像（Image）的运行时实例。正如从虚拟机模板上启动 VM 一样，用户也同样可以从单个镜像上启动一个或多个容器。虚拟机和容器最大的区别是容器更快并且更轻量级，与虚拟机运行在完整的操作系统之上相比，容器会共享其所在主机的操作系统/内核。</p><p>&emsp;&emsp;为什么要用容器呢？假设你在使用一台电脑开发一个应用，而且开发环境具有特定的配置。其他开发人员身处的环境配置可能稍有不同。你正在开发的应用不止依赖于您当前的配置，还需要某些特定的库、依赖项和文件。与此同时，你的企业还拥有标准化的开发和生产环境，有着自己的配置和一系列支持文件。你希望尽可能多在本地模拟这些环境，而不产生重新创建服务器环境的开销。这时候，就会需要容器来模拟这些环境。</p><p>&emsp;&emsp;我们常见的容器启动方式是 Docker，Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何 Linux 机器上，也可以实现虚拟化。</p><p><img src="https://static001.geekbang.org/infoq/04/04a9b140ed18d59ceb7ccbeb2155e737.jpeg" alt=""></p><h6 id="3-2-容器的发展进程-1"><a href="#3-2-容器的发展进程-1" class="headerlink" title="3.2 容器的发展进程"></a>3.2 容器的发展进程</h6><p>&emsp;&emsp;2010 年，几个年轻小伙在旧金山成立了一家做 PaaS 平台的公司，起名为”dotCloud”，该公司主要是基于 PaaS 平台为开发者或开发商提供技术服务。他们提供了对多种运行环境支持。但随着市场接受度、规模、加上科技巨头等影响，有一天 dotCloud 的创始人 Solomon Hykes 就召集了公司核心开发人员，商量准备开源 Docker 技术。因此，在 2013 年 3 月，Docker 正式以开源软件形式在 pycon 网站(见下图)首次发布了。正式由于这次开源，让容器领域焕发了第二春。后来在美国，几乎所有的云计算厂商都在拥抱 Docker 这个生态圈。很快 Docker 技术风靡全球，于是，dotCloud 决定改名为 Docker Inc(下面简称”Docker”)，全身心投入到 Docker 的开发中。更名后的 Docker 并于 2014 年 8 月，Docker 宣布把平台即服务的业务 dotCloud 出售给位于德国柏林的平台即服务提供商 cloudControl，自此 dotCloud 和 Docker 分道扬镳。</p><p><img src="https://static001.geekbang.org/infoq/d1/d14c4c065f26b524a66c33b93c7e6529.jpeg" alt=""></p><h6 id="3-3-Docker-与-Kubernetes-1"><a href="#3-3-Docker-与-Kubernetes-1" class="headerlink" title="3.3 Docker 与 Kubernetes"></a>3.3 Docker 与 Kubernetes</h6><p>&emsp;&emsp;Google 多年来一直使用容器作为交付应用程序的一种重要方式，且运行有一款名为 Borg 的编排工具。Google、RedHat 等公司为了对抗以 Docker 公司为核心的容器商业生态，他们一起成立了 CNCF(Cloud Native Computing Foundation)。当谷歌于 2014 年 3 月开始开发 Kubernetes 时，很明智的选择当时最流行的容器，没错，就是 Docker。Kubernetes 对 Docker 容器运行时的支持，迎来了大量的使用用户。Kubernetes 于 2014 年 6 月 6 日首次发布。这便有了容器编排工具 Kubernetes 的诞生。另外，CNCF 的目的是以开源的 K8S 为基础，使得 K8S 能够在容器编排方面能够覆盖更多的场景，提供更强的能力。K8S 必须面临 Swarm 和 Mesos 的挑战。Swarm 的强项是和 Docker 生态的天然无缝集成，Mesos 的强项是大规模集群的管理和调度。K8S 是 Google 基于公司已经使用了十多年的 Borg 项目进行了沉淀和升华才提出的一套框架。它的优点就是有一套完整的全新的设计理念，同时有 Google 的背书，而且在设计上有很强的扩展性，所以，最终 K8S 赢得了胜利，成为了容器生态的行业标准。</p><h6 id="3-4-K8s-容器化应用-1"><a href="#3-4-K8s-容器化应用-1" class="headerlink" title="3.4 K8s 容器化应用"></a>3.4 K8s 容器化应用</h6><p>&emsp;&emsp;前面说了，K8s 是一种编排容器管理容器工具，那么如何通过 K8s 来将服务容器化呢？</p><p>&emsp;&emsp;首先，我们来看看 K8s 如何使用？第一条就是编写配置文件，因为配置文件可以是 YAML 或者 JSON 格式的。为方便阅读与理解，在后面的讲解中，我会统一使用 YAML 文件来指代它们。 Kubernetes 跟 Docker 等很多项目最大的不同，就在于它不推荐你使用命令行的方式直接运行容器（虽然 Kubernetes 项目也支持这种方式，比如：kubectl run），而是希望你用 YAML 文件的方式，即：把容器的定义、参数、配置，统统记录在一个 YAML 文件中，然后用这样一句指令把它运行起来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f xxx.yaml</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样做最直接的一个好处是：你会有一个文件能记录下 K8s 到底 run 了哪些东西。比如下面这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps&#x2F;v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: tomcat-deployment</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: tomcat</span><br><span class="line">  replicas: 2</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: tomcat</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: tomcat</span><br><span class="line">        image: tomcat:10.0.5</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;像这样的一个 YAML 文件，对应到 kubernetes 中，就是一个 API Object（API 对象）。当你为这个对象的各个字段填好值并提交给 Kubernetes 之后，Kubernetes 就会负责创建出这些对象所定义的容器或者其他类型的 API 资源。可以看到，这个 YAML 文件中的 Kind 字段，指定了这个 API 对象的类型（Type），是一个 Deployment。Deployment 是一个定义多副本应用（即多个副本 Pod）的对象。此外，Deployment 还负责在 Pod 定义发生变化时，对每个副本进行滚动更新（Rolling+Update）。</p><p>&emsp;&emsp;在上面这个 Yaml 文件中，我给它定义的 Pod 副本个数 (spec.replicas)是：2。但，这些 Pod 副本长啥样子呢？为此，我们定义了一个 Pod 模版（spec.template），这个模版描述了我想要创建的 Pod 的细节。在上面的例子里，这个 Pod 里只有一个容器，这个容器的镜像（spec.containers.image）是 tomcat=10.0.5，这个容器监听端口（containerPort）是 80。</p><p>&emsp;&emsp;需要注意的是，像这种，使用一种 API 对象（Deployment）管理另一种 API 对象（Pod）的方法，在 Kubernetes 中，叫作“控制器”模式（controller pattern）。在我们的这个 demo 中，Deployment 扮演的正是 Pod 的控制器的角色。而 Pod 是 Kubernetes 世界里的应用；而一个应用，可以由多个容器（container）组成。为了让我们这个 tomcat 服务容器化运行起来，我们只需要执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tom@PK001:~&#x2F;damon$ kubectl create -f tomcat-deployment.yaml</span><br><span class="line">deployment.apps&#x2F;tomcat-deployment created</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行完上面的命令后，你就可以看容器运行情况，此时，只需要执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tom@PK001:~&#x2F;damon$ kubectl get pod -l app&#x3D;tomcat</span><br><span class="line">NAME                                 READY   STATUS              RESTARTS   AGE</span><br><span class="line">tomcat-deployment-799f46f546-7nxrj   1&#x2F;1     Running             0          77s</span><br><span class="line">tomcat-deployment-799f46f546-hp874   0&#x2F;1     Running             0          77s</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;’kubectl get’ 指令的作用，就是从 Kubernetes 里面获取（GET）指定的 API 对象。可以看到，在这里我还加上了一个 -l 参数，即获取所有匹配 app=nginx 标签的 Pod。需要注意的是，在命令行中，所有 key-value 格式的参数，都使用“=”而非“：”表示。 从这条指令返回的结果中，我们可以看到现在有两个 Pod 处于 Running 状态，也就意味着我们这个 Deployment 所管理的 Pod 都处于预期的状态。</p><p>&emsp;&emsp;此外， 你还可以使用 kubectl describe 命令，查看一个 API 对象的细节，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">tom@PK001:~&#x2F;damon$ kubectl describe pod tomcat-deployment-799f46f546-7nxrj</span><br><span class="line">Name:           tomcat-deployment-799f46f546-7nxrj</span><br><span class="line">Namespace:      default</span><br><span class="line">Priority:       0</span><br><span class="line">Node:           ca005&#x2F;10.10.2.5</span><br><span class="line">Start Time:     Thu, 08 Apr 2021 10:41:08 +0800</span><br><span class="line">Labels:         app&#x3D;tomcat</span><br><span class="line">                pod-template-hash&#x3D;799f46f546</span><br><span class="line">Annotations:    cni.projectcalico.org&#x2F;podIP: 20.162.35.234&#x2F;32</span><br><span class="line">Status:         Running</span><br><span class="line">IP:             20.162.35.234</span><br><span class="line">Controlled By:  ReplicaSet&#x2F;tomcat-deployment-799f46f546</span><br><span class="line">Containers:</span><br><span class="line">  tomcat:</span><br><span class="line">    Container ID:   docker:&#x2F;&#x2F;5a734248525617e950b7ce03ad7a19acd4ffbd71c67aacd9e3ec829d051b46d3</span><br><span class="line">    Image:          tomcat:10.0.5</span><br><span class="line">    Image ID:       docker-pullable:&#x2F;&#x2F;tomcat@sha256:2637c2c75e488fb3480492ff9b3d1948415151ea9c503a496c243ceb1800cbe4</span><br><span class="line">    Port:           80&#x2F;TCP</span><br><span class="line">    Host Port:      0&#x2F;TCP</span><br><span class="line">    State:          Running</span><br><span class="line">      Started:      Thu, 08 Apr 2021 10:41:58 +0800</span><br><span class="line">    Ready:          True</span><br><span class="line">    Restart Count:  0</span><br><span class="line">    Environment:    &lt;none&gt;</span><br><span class="line">    Mounts:</span><br><span class="line">      &#x2F;var&#x2F;run&#x2F;secrets&#x2F;kubernetes.io&#x2F;serviceaccount from default-token-2ww52 (ro)</span><br><span class="line">Conditions:</span><br><span class="line">  Type              Status</span><br><span class="line">  Initialized       True</span><br><span class="line">  Ready             True</span><br><span class="line">  ContainersReady   True</span><br><span class="line">  PodScheduled      True</span><br><span class="line">Volumes:</span><br><span class="line">  default-token-2ww52:</span><br><span class="line">    Type:        Secret (a volume populated by a Secret)</span><br><span class="line">    SecretName:  default-token-2ww52</span><br><span class="line">    Optional:    false</span><br><span class="line">QoS Class:       BestEffort</span><br><span class="line">Node-Selectors:  &lt;none&gt;</span><br><span class="line">Tolerations:     node.kubernetes.io&#x2F;not-ready:NoExecute for 300s</span><br><span class="line">                 node.kubernetes.io&#x2F;unreachable:NoExecute for 300s</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age    From               Message</span><br><span class="line">  ----    ------     ----   ----               -------</span><br><span class="line">  Normal  Scheduled  4m17s  default-scheduler  Successfully assigned default&#x2F;tomcat-deployment-799f46f546-7nxrj to ca005</span><br><span class="line">  Normal  Pulling    4m16s  kubelet, ca005     Pulling image &quot;tomcat:10.0.5&quot;</span><br><span class="line">  Normal  Pulled     3m27s  kubelet, ca005     Successfully pulled image &quot;tomcat:10.0.5&quot;</span><br><span class="line">  Normal  Created    3m27s  kubelet, ca005     Created container tomcat</span><br><span class="line">  Normal  Started    3m27s  kubelet, ca005     Started container tomcat</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在 kubectl describe 命令返回的结果中，可以的清楚地看到这个 Pod 的详细信息，比如它的 IP 地址等等。其中，有一个部分值得你特别关注，它就是 Events（事件）。</p><p>&emsp;&emsp;在 Kubernetes 执行的过程中，对 API 对象的所有重要操作，都会被记录在这个对象的 Events 里，并且显示在 kubectl describe 指令返回的结果中。这些 Events 中的信息很重要，可以排查容器是否运行、正常运行的原因。</p><p>&emsp;&emsp;如果你希望升级 tomcat 的版本，那可以直接修改 Yaml 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: tomcat</span><br><span class="line">    image: tomcat:latest</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;修改完 Yaml 文件后，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f tomcat-deployment.yaml</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样的操作方法，是 Kubernetes“声明式 API”所推荐的使用方法。也就是说，作为用户，你不必关心当前的操作是创建，还是更新，你执行的命令始终是 kubectl apply，而 Kubernetes 则会根据 YAML 文件的内容变化，自动进行具体的处理。</p><p>&emsp;&emsp;同时，可以查看容器内的服务的日志情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">tom@PK001:~&#x2F;damon$ kubectl logs -f tomcat-deployment-799f46f546-7nxrj</span><br><span class="line">NOTE: Picked up JDK_JAVA_OPTIONS:  --add-opens&#x3D;java.base&#x2F;java.lang&#x3D;ALL-UNNAMED --add-opens&#x3D;java.base&#x2F;java.io&#x3D;ALL-UNNAMED --add-opens&#x3D;java.base&#x2F;java.util&#x3D;ALL-UNNAMED --add-opens&#x3D;java.base&#x2F;java.util.concurrent&#x3D;ALL-UNNAMED --add-opens&#x3D;java.rmi&#x2F;sun.rmi.transport&#x3D;ALL-UNNAMED</span><br><span class="line">08-Apr-2021 02:41:59.037 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server version name:   Apache Tomcat&#x2F;10.0.5</span><br><span class="line">08-Apr-2021 02:41:59.040 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server built:          Mar 30 2021 08:19:50 UTC</span><br><span class="line">08-Apr-2021 02:41:59.040 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server version number: 10.0.5.0</span><br><span class="line">08-Apr-2021 02:41:59.040 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log OS Name:               Linux</span><br><span class="line">08-Apr-2021 02:41:59.040 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log OS Version:            4.4.0-116-generic</span><br><span class="line">08-Apr-2021 02:41:59.040 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Architecture:          amd64</span><br><span class="line">08-Apr-2021 02:41:59.040 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Java Home:             &#x2F;usr&#x2F;local&#x2F;openjdk-11</span><br><span class="line">08-Apr-2021 02:41:59.040 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log JVM Version:           11.0.10+9</span><br><span class="line">08-Apr-2021 02:41:59.040 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log JVM Vendor:            Oracle Corporation</span><br><span class="line">08-Apr-2021 02:41:59.040 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log CATALINA_BASE:         &#x2F;usr&#x2F;local&#x2F;tomcat</span><br><span class="line">08-Apr-2021 02:41:59.041 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log CATALINA_HOME:         &#x2F;usr&#x2F;local&#x2F;tomcat</span><br><span class="line">08-Apr-2021 02:41:59.051 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens&#x3D;java.base&#x2F;java.lang&#x3D;ALL-UNNAMED</span><br><span class="line">08-Apr-2021 02:41:59.051 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens&#x3D;java.base&#x2F;java.io&#x3D;ALL-UNNAMED</span><br><span class="line">08-Apr-2021 02:41:59.051 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens&#x3D;java.base&#x2F;java.util&#x3D;ALL-UNNAMED</span><br><span class="line">08-Apr-2021 02:41:59.051 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens&#x3D;java.base&#x2F;java.util.concurrent&#x3D;ALL-UNNAMED</span><br><span class="line">08-Apr-2021 02:41:59.052 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens&#x3D;java.rmi&#x2F;sun.rmi.transport&#x3D;ALL-UNNAMED</span><br><span class="line">08-Apr-2021 02:41:59.052 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.util.logging.config.file&#x3D;&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;conf&#x2F;logging.properties</span><br><span class="line">08-Apr-2021 02:41:59.052 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.util.logging.manager&#x3D;org.apache.juli.ClassLoaderLogManager</span><br><span class="line">08-Apr-2021 02:41:59.052 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djdk.tls.ephemeralDHKeySize&#x3D;2048</span><br><span class="line">08-Apr-2021 02:41:59.052 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.protocol.handler.pkgs&#x3D;org.apache.catalina.webresources</span><br><span class="line">08-Apr-2021 02:41:59.052 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dorg.apache.catalina.security.SecurityListener.UMASK&#x3D;0027</span><br><span class="line">08-Apr-2021 02:41:59.052 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dignore.endorsed.dirs&#x3D;</span><br><span class="line">08-Apr-2021 02:41:59.052 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dcatalina.base&#x3D;&#x2F;usr&#x2F;local&#x2F;tomcat</span><br><span class="line">08-Apr-2021 02:41:59.052 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dcatalina.home&#x3D;&#x2F;usr&#x2F;local&#x2F;tomcat</span><br><span class="line">08-Apr-2021 02:41:59.052 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.io.tmpdir&#x3D;&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;temp</span><br><span class="line">08-Apr-2021 02:41:59.056 INFO [main] org.apache.catalina.core.AprLifecycleListener.lifecycleEvent Loaded Apache Tomcat Native library [1.2.27] using APR version [1.6.5].</span><br><span class="line">08-Apr-2021 02:41:59.056 INFO [main] org.apache.catalina.core.AprLifecycleListener.lifecycleEvent APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true], UDS [true].</span><br><span class="line">08-Apr-2021 02:41:59.059 INFO [main] org.apache.catalina.core.AprLifecycleListener.initializeSSL OpenSSL successfully initialized [OpenSSL 1.1.1d  10 Sep 2019]</span><br><span class="line">08-Apr-2021 02:41:59.312 INFO [main] org.apache.coyote.AbstractProtocol.init Initializing ProtocolHandler [&quot;http-nio-8080&quot;]</span><br><span class="line">08-Apr-2021 02:41:59.331 INFO [main] org.apache.catalina.startup.Catalina.load Server initialization in [441] milliseconds</span><br><span class="line">08-Apr-2021 02:41:59.369 INFO [main] org.apache.catalina.core.StandardService.startInternal Starting service [Catalina]</span><br><span class="line">08-Apr-2021 02:41:59.370 INFO [main] org.apache.catalina.core.StandardEngine.startInternal Starting Servlet engine: [Apache Tomcat&#x2F;10.0.5]</span><br><span class="line">08-Apr-2021 02:41:59.377 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;http-nio-8080&quot;]</span><br><span class="line">08-Apr-2021 02:41:59.392 INFO [main] org.apache.catalina.startup.Catalina.start Server startup in [61] milliseconds</span><br></pre></td></tr></table></figure><h5 id="第四章-为何借助容器助力微服务-1"><a href="#第四章-为何借助容器助力微服务-1" class="headerlink" title="第四章 为何借助容器助力微服务"></a>第四章 为何借助容器助力微服务</h5><h6 id="4-1-微服务的多语言性-1"><a href="#4-1-微服务的多语言性-1" class="headerlink" title="4.1 微服务的多语言性"></a>4.1 微服务的多语言性</h6><p>&emsp;&emsp;微服务可以说是越来越火了：那么对于语言场景，从 Java 中的 Spring MVC，到后面的 SOA、Dubbo、Spring Cloud、Spring cloud Alibaba 等。这是单纯 Java 语言的微服务的发展史，那么对于 Python、Go 呢？其实也是有其微服务设计理念的，比如 Golang 的 beego、gin 等。</p><p>&emsp;&emsp;这么多的微服务框架，都是独立、限制于自己的体系，撇开其它技术不说，Java 可以自成生态体系，Golang 亦是。其实微服务不应该受某种语言的限制，各种语言的服务之间应该可以互通：这在云原生时代设计中，它们都被称为 Service。后面会介绍对于不同语言的服务（Service）如何在云原生中互通。</p><h6 id="4-2-微服务的高可用-1"><a href="#4-2-微服务的高可用-1" class="headerlink" title="4.2 微服务的高可用"></a>4.2 微服务的高可用</h6><p>&emsp;&emsp;微服务出现后，同样面临着一个重要的话题：高可用。所谓<strong>高可用</strong>：英文缩写 HA(High Availability)，是指当某个服务或服务所在节点出现故障时，其对外的功能可以转移到该服务其他的副本或该服务在其他节点的副本，从而在减少停工时间的前提下，满足业务的持续性，这两个或多个服务构成了服务高可用。同时，这种高可用需要考虑到服务的性能压力，即服务的负载均衡。</p><p>&emsp;&emsp;我们知道对于服务的高可用，或者说服务的负载来说，有很多方式来解决这些问题。比如：</p><ul><li>主从方式，其工作原理是：主机处于工作状态，备机处于监控、准备状态，当主机出现宕机的情况下，备机可以接管主机的一切工作，等到主机恢复正常后，将会手动或自动的方式将服务切换到主机上运行，数据的一致性通过共享存储来实现。</li><li>集群方式，其工作原理是：多台机器同时运行一个或几个服务，当其中的某个节点出现宕机时，这时该节点的服务将无法提供业务功能，可以选择根据一定的机制，将服务请求转移到该服务所在的其他节点上，这样可以让逻辑持续的执行下去，即消除软件单点故障。这其实就涉及到负载均衡策略。</li></ul><p>&emsp;&emsp;对于微服务的<strong>高可用</strong>，涉及到的其中一个就是其服务的负载均衡。在微服务中，负载均衡的前提是，同一个服务需要被发现多个，或者说多个副本，这样才能实现负载均衡以及服务的高可用。那么，怎么让服务被发现呢？我们来看一张图：</p><p><img src="https://static001.geekbang.org/infoq/26/2670441bb586695aa5eea48a910f1447.png" alt=""><br>&emsp;&emsp;在上图中，我们可以看到：</p><ul><li>1.各微服务先往注册中心 Eureka 注册服务。</li><li>2.各微服务保持与注册中心心跳。</li><li>3.注册中心发现各微服务。</li><li>4.注册中心根据配置规则定期获取心跳，超时即认为节点无效。</li><li>5.根据规则来定期清理无效节点。</li></ul><p>&emsp;&emsp;这是基于注册中心 Eureka 的服务注册与发现，同样，基于其他的注册中心实现原理基本类似。如：Eureka、Zookeeper、Consul、etcd、nacos 等。其实，在云原生 K8s 中，也存在着服务的注册与发现，这在后面章节中会讲解。</p><p>&emsp;&emsp;服务发现后，其实面临的是一个主要的问题就是应该访问哪一个？因为发现了某个服务的多个实例，最终只会访问其中某一个，这就涉及到服务的负载均衡了。</p><p>&emsp;&emsp;负载均衡在微服务中是一个很常见的话题，实现负载均衡的插件也越来越多。netflix 开源的 Zuul、Gateway 等等，其实 K8s 中也存在着负载均衡器：kube-dns、kube-proxy。</p><p>&emsp;&emsp;在实现服务注册与发现、负载均衡后，其实高可用还涉及很多：高并发、缓存等。先讲讲<strong>高并发</strong>：</p><ul><li>幂等性</li><li>接口代码的规范性</li><li>操作 DB 的性能</li><li>读写分离操作</li><li>服务的横向扩展</li><li>服务的健壮性（缓存、限流、熔灾）</li></ul><p>&emsp;&emsp;其中，幂等性：就是说一次和多次请求某一个资源时对于资源本身应该具有同样的结果（网络超时等问题除外）。也就是说，其任意次执行所产生的效果和返回的结果都是一样的。这种场景是一个很有效的实现高并发的情景，设想，用户充值某个会员，在并发情况下，用户由于误操作，或者由于网络、时间等问题导致重试机制的发生时，可能会触发触发多次交易的扣费，这样给用户一个很不好的体验。此时，就需要接口幂等性来解决这类问题。</p><p>&emsp;&emsp;幂等性解决方案有以下几种：</p><ul><li>token 机制</li><li>接口逻辑实现幂等性</li><li>数据库层处理实现幂等性</li></ul><p>&emsp;&emsp;token 机制：数据提交时携带 token，token 放到 redis，token 有效时间，提交后台后校验 token，同时删除 token，生成新的 token 并返回。</p><p>&emsp;&emsp;接口的幂等性：常见的接口幂等性，是定义接口时，加上参数序列号、来源等，序列号与请求来源联合唯一索引，这样可以有效判断本次请求方与请求的序列号，防止重复的请求。</p><p>&emsp;&emsp;数据库处理：DB 层处理有多种方式：1. 悲观锁，2. 乐观锁，3. 唯一索引、组合唯一索引，4. 分布式锁。</p><p>&emsp;&emsp;悲观锁：所谓悲观锁，是指存在危机意识，事先(查询时)加锁处理，防止事情发生。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from xxx where id&#x3D; 1 for update</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;乐观锁：是指存在乐观心理，只在更新时加锁，乐观锁通常用 version 版本号来控制如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update xxx set name&#x3D;#name#,version&#x3D;version+1 where version&#x3D;#version#</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;也可以通过条件限制，这里就使用了组合唯一索引来处理，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update xxx set name&#x3D;#name#,version&#x3D;version+1 where id&#x3D;#id# and version&#x3D;#version#</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;分布式锁：通过 redis、zookeeper 来设置分布式锁，当插入或更新数据时，获取分布式锁，然后做操作，之后释放锁。</p><p>&emsp;&emsp;接口的规范性：接口的性能如何，最终还是跟接口的实现逻辑有关，比如代码规范，逻辑实现等，尤其是业务逻辑复杂的情况下，这点需要注意的。</p><p>&emsp;&emsp;操作 DB：对于业务的持久层，用的比较多的就是 mybatis、hibernate，还有可能是 JPA，无论是哪个，最终都是通过工厂类注入 bean，最后执行 SQL 来操作 DB。所以这里尤为重要的是 SQL 的写法，SQL 的优化决定着操作 DB 的时间以及效果，如果写得不好的话，则会导致死循环，或死锁，或内存溢出。另外测试时，使用真实、规范的数据进行测试，并在测试时不要局限于相同的数据，最后就是并发压测了。</p><p>&emsp;&emsp;读写分离：当服务足够多，数据足够多时，有可能读与写的占比为：10:1，此时读写应该分离，这样可以有效减少因为读的频繁操作导致的写的性能下降。常见的读写分离的方法有：采用 mycat 中间件方式、amoeba 直接实现读写分离、手动修改 mysql 操作类直接实现读写分离和随机实现的负载均衡，权限独立分配、mysql-proxy（还是测试版本，时间消耗有点高）。</p><p>&emsp;&emsp;服务的横向扩展：对于服务的请求越来越多时，此时需要对服务进行多节点部署，这样减少单机带来的服务负载压力。</p><p>&emsp;&emsp;服务的健壮性：服务的健壮性包括缓存、限流、熔灾。</p><p>&emsp;&emsp;对于缓存，大家都知道，有常见的许多中间件如：redis、kafka、RabbitMq、zookeeper。对于一些 session 等常用 redis 来缓存、共享。对于一些大一点的数据如果嫌弃加载慢，也可以采用缓存机制来解决。</p><p>&emsp;&emsp;什么叫限流呢？很好理解，就是限制节点的流量，限制服务的请求数。那么如何做到限流呢？常用的限流算法比如有计数器算法、令牌桶算法、漏桶算法。有几种方式：利用 springcloud 组件 zuul 来对请求进行限流，主要是通过谷歌提供的 RateLimiter 结合一些限流算法来限流比较常用。利用 redis 同样可以做限流算法的，甚至可以利用 nginx 直接作计数限流，可以对请求速率进行限制、对每个 ip 连接数量进行限制、对每个服务的连接数量进行限制。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#对请求速率进行限制</span><br><span class="line">limit_req_zone $binary_remote_addr zone&#x3D;req_one:20m rate&#x3D;12r&#x2F;s;</span><br><span class="line">limit_conn_zone $binary_remote_addr zone&#x3D;addr:10m;</span><br><span class="line">#对每个ip连接数量进行限制</span><br><span class="line">limit_conn_zone $server_name zone&#x3D;perserver:20m;</span><br><span class="line">#对每个服务的连接数量进行限制</span><br><span class="line">server&#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;ip:port;</span><br><span class="line">    limit_req zone&#x3D;req_one burst&#x3D; 80 nodelay;</span><br><span class="line">    limit_conn addr 20;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其实在 Springboot2.x 中，推出自己的 Spring-Cloud-Gateway 来作网关，同时 Spring-Cloud-Gateway 中提供了基于 Redis 的实现来达到限流的目的。对于其它框架，都有加入限流的插件功能。</p><p>&emsp;&emsp;对于熔灾，或者说熔断，这个在实际的业务当中是很有必要的。比如：用户在某一商城秒杀某一件物品，或在某米商城上抢购某一部手机，在准点抢购时，发现人很多，请求很多，这时，主要是需要有限流机制，同时也需要有熔灾（熔断），给用户留下一个很好的体验的感觉。当用户在点击抢购按钮后，如果当前的请求数很多，需要用户等待，这是需要给一个友好的界面让用户去等待，而不是直接给用户提示请求失败，或者报异常，这样的红色抛出是一个非常不好的事情，用户可能会骂街的，下次也不会逛了。</p><p>&emsp;&emsp;Spring-Cloud-Gateway 作网关时，过滤器时使用 HystrixGatewayFilterFactory 来创建一个 Filter 实现基于 Route 级别的熔断功能。</p><p>&emsp;&emsp;对于缓存问题，随着系统用户的越来愈多，所有的服务压力也会指数型递增，这时候缓存是一个很好的减轻服务压力的方式。这样可以有效缓冲请求对服务的负载压力。常见的缓存可能是 Redis、MQ(RabbitMQ、RocketMQ)、Kafka、ZooKeeper 等。</p><p>&emsp;&emsp;Redis 一般主要做 session 或用户信息的缓存，实现多机中 session 的共享。也会用来作分布式锁，在分布式高并发下实现锁的功能，例如实现秒杀、抢单等功能。还会被用作一些订单信息的缓存，防止大量的订单信息被积压而导致服务器的负载很高。总之，Redis 常被用来作为一种缓冲剂使用。</p><p>&emsp;&emsp;MQ 常见的有 RabbitMQ、RocketMQ、ActiveMQ、Kafka 等，以下是各种之间的对比：</p><table cellspacing="0"><tbody><tr style="height:17px;"><td width="68" valign="top" style="padding: 8px 14px;border-width: 1px;border-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">特性</span></p></td><td width="101" valign="top" style="padding: 8px 14px;border-left: none;border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top-width: 1px;border-top-color: rgb(192, 192, 192);border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">ActiveMQ</span></p></td><td width="119" valign="top" style="padding: 8px 14px;border-left: none;border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top-width: 1px;border-top-color: rgb(192, 192, 192);border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">RabbitMQ</span></p></td><td width="148" valign="top" style="padding: 8px 14px;border-left: none;border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top-width: 1px;border-top-color: rgb(192, 192, 192);border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">RocketMQ</span></p></td><td width="136.33333333333334" valign="top" style="padding: 8px 14px;border-left: none;border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top-width: 1px;border-top-color: rgb(192, 192, 192);border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">Kafka</span></p></td></tr><tr style="height:72px;"><td width="68" valign="top" style="padding: 8px 14px;border-left-width: 1px;border-left-color: rgb(192, 192, 192);border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top: none;border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">单机吞吐量</span></p></td><td width="101" valign="top" style="padding: 8px 14px;border-left: none;border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top: none;border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">万级，吞吐量比RocketMQ<span style="font-family:pingfang sc;">和</span><span style="font-family:Trebuchet MS;">Kafka</span><span style="font-family:pingfang sc;">要低了一个数量级</span></span></p></td><td width="119" valign="top" style="padding: 8px 14px;border-left: none;border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top: none;border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">万级，吞吐量比RocketMQ<span style="font-family:pingfang sc;">和</span><span style="font-family:Trebuchet MS;">Kafka</span><span style="font-family:pingfang sc;">要低了一个数量级</span></span></p></td><td width="148" valign="top" style="padding: 8px 14px;border-left: none;border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top: none;border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">10<span style="font-family:pingfang sc;">万级，</span><span style="font-family:Trebuchet MS;">RocketMQ</span><span style="font-family:pingfang sc;">也是可以支撑高吞吐的一种</span><span style="font-family:Trebuchet MS;">MQ</span></span></p></td><td width="171" valign="top" style="padding: 8px 14px;border-left: none;border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top: none;border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">10<span style="font-family:pingfang sc;">万级别，这是</span><span style="font-family:Trebuchet MS;">kafka</span><span style="font-family:pingfang sc;">最大的优点，就是吞吐量高。</span>一般配合大数据类的系统来进行实时数据计算、日志采集等场景</span></p></td></tr><tr style="height:41px;"><td width="68" valign="top" style="padding: 8px 14px;border-left-width: 1px;border-left-color: rgb(192, 192, 192);border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top: none;border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">时效性</span></p></td><td width="101" valign="top" style="padding: 8px 14px;border-left: none;border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top: none;border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">ms级</span></p></td><td width="119" valign="top" style="padding: 8px 14px;border-left: none;border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top: none;border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);word-break: break-all;"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">微秒级</span></p></td><td width="148" valign="top" style="padding: 8px 14px;border-left: none;border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top: none;border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">ms级</span></p></td><td width="171" valign="top" style="padding: 8px 14px;border-left: none;border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top: none;border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">延迟在ms<span style="font-family:pingfang sc;">级以内</span></span></p></td></tr><tr style="height:76px;"><td width="68" valign="top" style="padding: 8px 14px;border-left-width: 1px;border-left-color: rgb(192, 192, 192);border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top: none;border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">可用性</span></p></td><td width="101" valign="top" style="padding: 8px 14px;border-left: none;border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top: none;border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">高，基于主从架构实现高可用性</span></p></td><td width="119" valign="top" style="padding: 8px 14px;border-left: none;border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top: none;border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">高，基于主从架构实现高可用性</span></p></td><td width="148" valign="top" style="padding: 8px 14px;border-left: none;border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top: none;border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">非常高，分布式架构</span></p></td><td width="171" valign="top" style="padding: 8px 14px;border-left: none;border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top: none;border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">非常高，kafka<span style="font-family:pingfang sc;">是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</span></span></p></td></tr><tr style="height:71px;"><td width="68" valign="top" style="padding: 8px 14px;border-left-width: 1px;border-left-color: rgb(192, 192, 192);border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top: none;border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">消息可靠性</span></p></td><td width="101" valign="top" style="padding: 8px 14px;border-left: none;border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top: none;border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">有较低的概率丢失数据</span></p></td><td width="119" valign="top" style="padding: 8px 14px;border-left: none;border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top: none;border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><br></td><td width="148" valign="top" style="padding: 8px 14px;border-left: none;border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top: none;border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">经过参数优化配置，可以做到0<span style="font-family:pingfang sc;">丢失</span></span></p></td><td width="171" valign="top" style="padding: 8px 14px;border-left: none;border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top: none;border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">经过参数优化配置，消息可以做到0<span style="font-family:pingfang sc;">丢失</span></span></p></td></tr><tr style="height:101px;"><td width="68" valign="top" style="padding: 8px 14px;border-left-width: 1px;border-left-color: rgb(192, 192, 192);border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top: none;border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">功能支持</span></p></td><td width="101" valign="top" style="padding: 8px 14px;border-left: none;border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top: none;border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">MQ<span style="font-family:pingfang sc;">领域的功能极其完备</span></span></p></td><td width="119" valign="top" style="padding: 8px 14px;border-left: none;border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top: none;border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">基于erlang<span style="font-family:pingfang sc;">开发，所以并发能力很强，性能极其好，延时很低</span></span></p></td><td width="148" valign="top" style="padding: 8px 14px;border-left: none;border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top: none;border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">MQ<span style="font-family:pingfang sc;">功能较为完善，还是分布式的，扩展性好</span></span></p></td><td width="171" valign="top" style="padding: 8px 14px;border-left: none;border-right-width: 1px;border-right-color: rgb(192, 192, 192);border-top: none;border-bottom-width: 1px;border-bottom-color: rgb(192, 192, 192);background: rgb(238, 238, 238);word-break: break-all;"><p style="font-family: 10px 0;text-indent: 0;"><span style="color: rgb(0, 0, 0);letter-spacing: 0;font-size: 10px;">功能较为简单，主要支持简单的MQ<span style="font-family:pingfang sc;">功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</span></span></p></td></tr></tbody></table><p>&emsp;&emsp;ZooKeeper 也是经常会存储海量数据，例如 Hadoop 中，在使用 YARN 作资源调度时，采用 ZooKeeper 来存储海量的状态机状态以及任务的信息（包括历史信息）。</p><h6 id="4-3-微服务的复杂性-1"><a href="#4-3-微服务的复杂性-1" class="headerlink" title="4.3 微服务的复杂性"></a>4.3 微服务的复杂性</h6><p>&emsp;&emsp;说起微服务，使用 DDD 划分微服务的好处的时候，经常会说 DDD 能够让相关的业务逻辑更加内聚，并且降低服务之间的耦合性，从而最终实现达到降解系统的复杂性。但是在这里，不论是高内聚，低耦合，甚至我们经常说的系统复杂性，我们有没有一个客观的可以量化的指标来衡量这些概念。由于无法量化，所以就没法度量，这样当团队在讨论一个系统是否复杂，有多复杂这些问题的时候，就很容易陷入各种主观直觉的争论中。</p><p>&emsp;&emsp;互联网时代，这些巨多的系统在细节上不一样，但是如果从抽象层面来看有很多共性，一个微服务系统由很多个微服务组成，这些微服务的行为产生出复杂的行为模式。整个微服务系统会通过 API 利用内部或外部的信号，同时在系统内部也是通过服务之间的接口进行信息传递。一个微服务系统并不是静态的，而是会不断适应业务变化，改变系统的 API 或者系统内部的组织方式来增加生存的机会。</p><p>&emsp;&emsp;微服务的复杂，不仅仅在于其系统本身，还需要考虑的是：高可用、服务自治、服务并发、服务限流、熔灾等。</p><p>&emsp;&emsp;服务的高可用在上一节中已经说明了，服务自治，目的其实是在对其修改时对其他部分造成尽可能小的影响；自治服务运营时也不会对其他服务的功能造成影响。服务几乎总是要依赖其他服务提供的数据。例如，网上商城都有一个购物车微服务，一些其他服务必须能向购物车添加商品，还必须能访问购物车内的商品并下单和配送。现在问题是，如何在保持服务尽可能自治的前提下实现对接。那需要遵循一定的模式：交互、信息传递。</p><p>&emsp;&emsp;交互模式：Request-Reply 还是 Publish-Subscribe</p><ul><li>Request-Reply（请求-应答）意味着一个服务处理信息的特定请求或者执行一些动作并返回一个应答。发起调用的服务需要知道去哪儿请求以及请求些什么？这种模式仍然可以被实现为异步执行，并且你还可以做一些抽象使服务调用方不需要知道被调用服务的物理地址，不能逃避的一点是服务必须明确的要求一个特定的信息和功能（或者执行动作）并等待应答。</li><li>Publish-Subscribe（发布-订阅） 这种模式下的服务将自己注册为对特定的信息感兴趣，或者能够处理特定的请求，相关的信息和请求将被交付给它，并且它可以决定怎么处理这些信息和请求。本文假定有一些中间件能够处理交付或者发布消息给订阅这些消息服务。</li></ul><p>&emsp;&emsp;信息传递：Events 还是 Queries/Commands</p><ul><li>Events（事件）是没有争议的事实，比如订单号 123 的订单已经创建，事件只陈述发生了什么事，不描述这样一个事件会导致什么事情发生。</li><li>Queries/Commands（查询/命令）两者都传达了什么事情会发生，查询是对信息的特定请求，命令是要求一个服务执行一些动作的特定请求。</li></ul><p>&emsp;&emsp;上面的四种即可作为微服务间对接的四种方式：<strong>REQUEST-REPLY WITH EVENTS</strong>、<strong>REQUEST-REPLY WITH COMMANDS/QUERIES</strong>、<strong>PUBLISH-SUBSCRIBE WITH EVENTS</strong>、<strong>PUBLISH-SUBSCRIBE WITH COMMANDS/QUERIES</strong>。</p><ul><li><p>REQUEST-REPLY WITH EVENTS，在这种模式下，一个服务请求另一个导致事件发生的特定服务，这意味着这两种服务之间有很强的依赖。配送服务必须知道要连接那个服务来获得订单相关的事件，这也导致了运行时依赖，因为配送服务只有在订单服务可用的时候才能配送新订单。</p><blockquote><blockquote><p>  既然配送服务只接收事件，它基于事件里的信息自己决定何时一个订单可以被配送，订单服务不需要知道配送服务的任何信息，它只是简单的提供事件表明当其他服务请求时订单进行怎样的处理，把响应事件的职责完全交给请求事件的服务。</p></blockquote></blockquote></li><li><p>REQUEST-REPLY WITH COMMANDS/QUERIES，如：订单服务将请求配送服务来配送一个订单，这意味着强烈的依赖，因为订单服务明确的请求一个特定的服务来处理配送，现在订单服务必须决定何时一个订单准备好配送，它意识到配送服务的存在，甚至知道怎样与配送服务交互，在订单配送前需要考虑是否有其他因素关联到订单（比如客户信用卡状态），订单服务在请求配送服务来配送订单前也需要考虑这一点。现在业务处理被混到了架构里，因此架构不能被简单的修改。这也是运行时依赖，因为订单服务必须确保配送请求成功交付给了配送服务。</p></li><li><p>PUBLISH-SUBSCRIBE WITH EVENTS，配送服务注册自己对订单相关的事件感兴趣，注册后，配送服务会收到订单的所有事件而不需要关心订单事件的来源，这是对订单事件来源的松散耦合，配送服务需要保留接收到事件的副本，这样就可以决定何时订单准备好配送。订单服务需要对配送无关，如果多个服务提供包含配送服务需要的相关数据的订单相关事件，配送服务应该不可识别，如果一个提供订单事件的服务宕机，配送服务也应该不知道，只是收到的事件变少了，配送服务不会因此阻塞。</p></li><li><p>PUBLISH-SUBSCRIBE WITH COMMANDS/QUERIES，配送服务自己注册为能够配送货物的服务，接受所有想要配送货物的命令，配送服务不需要意识到配送命令的来源，同样订单服务业不知道那些服务将处理配送，在这个意义上说，他们是松散耦合的，不过，订单服务知道既然发送了配送命令，订单必须被配送的事实，这确实让耦合更强了。</p></li></ul><p>&emsp;&emsp;两种 Request-Reply 模式都意味着两个服务的运行时耦合和强耦合，两种 Command/Queries 模式意味着一个服务知道另一个服务应该做的事，这也意味着强耦合，但是这一次在功能级别。留下了一个选项：PUBLISH-SUBSCRIBE WITH EVENTS，这种情况下，两种服务从运行时和功能的角度都没有意识到彼此的存在。</p><p>&emsp;&emsp;<strong>但是，我们需要考虑更多的因素，一直使用这种方式交互是有代价的，例如，数据被复制、事件丢失、事件驱动的架构增加更多基础设施的需求、额外的延迟。</strong></p><h4 id="第二部分-原理与应用-1"><a href="#第二部分-原理与应用-1" class="headerlink" title="第二部分 原理与应用"></a>第二部分 原理与应用</h4><h5 id="第五章-Kubernetes-介绍-1"><a href="#第五章-Kubernetes-介绍-1" class="headerlink" title="第五章 Kubernetes 介绍"></a>第五章 Kubernetes 介绍</h5><h6 id="5-1-Kubernetes-的基本概念与特性-1"><a href="#5-1-Kubernetes-的基本概念与特性-1" class="headerlink" title="5.1 Kubernetes 的基本概念与特性"></a>5.1 Kubernetes 的基本概念与特性</h6><p>&emsp;&emsp;在前面的章节中介绍了 Kubernetes 的由来，那么 Kubernetes 到底是干嘛的呢？这就涉及到 Kubernetes 的定义以及其特性，本节来描述下 Kubernetes 的特性以及应用场景。</p><p>&emsp;&emsp;Kubernetes，简称 K8s，是把 8 代替了 8 个字符“ubernete”而成的缩写。K8s 是一个一个开源的，用于管理云平台中多个主机上的容器化的应用编排工具。它的目标是让部署容器化的应用简单且高效，Kubernetes 提供了应用部署，规划，更新，维护的一种机制。</p><p>&emsp;&emsp;Kubernetes 是 Google 开源的一个容器编排引擎，支持自动化部署、大规模可伸缩、应用容器化管理。在生产环境中部署一个应用程序时，通常要部署该应用的多个实例以便对应用请求进行负载均衡。在 Kubernetes 中，我们可以创建多个容器，每个容器里面运行一个应用实例，然后通过内置的负载均衡策略，实现对这一组应用实例的管理、发现、访问，而这些细节都不需要运维人员去进行复杂的手工配置和处理。</p><p>&emsp;&emsp;特性：</p><ul><li>可移植: 支持公有云，私有云，混合云</li><li>可扩展: 模块化，插件化，可挂载，可组合</li><li>自动化: 自动部署，自动重启，自动复制，自动弹性伸缩</li></ul><p>&emsp;&emsp;可移植，意味着可以穿梭任何系统，不受系统的限制，也不受任何语言的限制，支持任何的其他的服务形式。</p><p>&emsp;&emsp;可扩展，是指 K8s 的各个模块之间是解耦合的，可以增加插件来丰富其功能，也可以替换其组件来达到想要的效果。</p><p>&emsp;&emsp;自动部署和回滚，K8s 采用滚动更新策略更新应用，一次更新一个 Pod，而不是同时删除所有 Pod，如果更新过程中出现问题，将回滚更改，确保升级不受影响业务。</p><p>&emsp;&emsp;弹性伸缩，使用命令、UI 或者基于 CPU 使用情况自动快速扩容和缩容应用程序实例，保证应用业务高峰并发时的高可用性；业务低峰时回收资源，以最小成本运行服务。</p><p>&emsp;&emsp;自动重启，是说在集群节点宕机、机器重启后，其 K8s 集群具有自动重启的功能，同时，会拉起集群中所有的应用服务，这就是其编排能力的一个体现。</p><p>&emsp;&emsp;自动复制，是指所有相关的数据，可以被备份到 etcd 或其它插件中，以便 K8s 可以通过 controllers、scheduler 来很好的编排。</p><p>&emsp;&emsp;可挂载，是指存储编排，挂载外部存储系统，无论是来自本地存储，公有云（如 AWS），还是网络存储（如 NFS、GlusterFS、Ceph）都作为集群资源的一部分使用，极大提高存储使用灵活性。</p><p>&emsp;&emsp;自我修复，在节点故障时重新启动失败的容器，替换和重新部署，保证预期的副本数量；杀死健康检查失败的容器，并且在未准备好之前不会处理客户端请求，确保线上服务不中断。</p><h6 id="5-2-部署-Kubernetes-集群-1"><a href="#5-2-部署-Kubernetes-集群-1" class="headerlink" title="5.2 部署 Kubernetes 集群"></a>5.2 部署 Kubernetes 集群</h6><p>&emsp;&emsp;如果想要了解 K8s 的一些特性，并且将其应运的很好，那就需要动手部署一个 K8s 集群。下面讲解下 K8s 集群部署流程。</p><h6 id="单机版-K8s"><a href="#单机版-K8s" class="headerlink" title="单机版 K8s"></a>单机版 K8s</h6><p>&emsp;&emsp;<strong>环境：</strong></p><ul><li>Ubuntu 16.04</li><li>GPU 驱动 418.56</li><li>Docker 18.06</li><li>K8s 1.13.5</li></ul><p>以上的环境，针对的是高版本的 K8s，而且 Docker 的版本必须要注意。另外 GPU 驱动的话，如果大家是非 GPU 机器的话，可以考虑不用。如果含有 GPU 机器的话，需要安装驱动，并且驱动版本不能过低喔。</p><h4 id="设置环境"><a href="#设置环境" class="headerlink" title="设置环境"></a>设置环境</h4><p>在配置环境前，首先备份一下源配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.cp</span><br></pre></td></tr></table></figure><p>然后我们重新写一份配置，编辑内容，加上阿里源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br><span class="line"></span><br><span class="line">deb-src http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu xenial main restricted</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial main restricted</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial main restricted multiverse universe</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates main restricted</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates main restricted multiverse universe</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial universe</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates universe</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F;xenial-backports main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;archive.canonical.com&#x2F;ubuntu xenial partner</span><br><span class="line">deb-src http:&#x2F;&#x2F;archive.canonical.com&#x2F;ubuntu xenial partner</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security main restricted</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security main restricted multiverse universe</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security universe</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security multiverse</span><br></pre></td></tr></table></figure><p>添加好后，可以执行如下命令，更新一下源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure><p>如果出现问题，可以执行如下命令来自动修复安装出现 broken 的 package：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt --fix-broken install</span><br></pre></td></tr></table></figure><p>执行升级命令时，注意：对于 GPU 机器可不执行，否则可能升级 GPU 驱动导致问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get upgrade</span><br></pre></td></tr></table></figure><p>由于 K8s 安装要求，需要关闭防火墙：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ufw disable</span><br></pre></td></tr></table></figure><p>安装 SELinux：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install selinux-utils</span><br></pre></td></tr></table></figure><p>SELinux 防火墙配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br><span class="line"></span><br><span class="line">vim&#x2F;etc&#x2F;selinux&#x2F;conifg</span><br><span class="line"></span><br><span class="line">SELINUX&#x3D;disabled</span><br></pre></td></tr></table></figure><p>设置网络，将桥接的 IPV4 流量传递到 iptables 的链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tee &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables &#x3D; 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables &#x3D; 1</span><br><span class="line">net.ipv4.ip_forward &#x3D; 1</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>为了防止下面执行的会报错，可以先执行一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe br_netfilter</span><br></pre></td></tr></table></figure><p>最后，查看 IPV4 与 v6 配置是否生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl --system</span><br></pre></td></tr></table></figure><p>配置 iptables：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line"></span><br><span class="line">vim &#x2F;etc&#x2F;rc.local</span><br><span class="line">&#x2F;usr&#x2F;sbin&#x2F;iptables -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure><p>需要永久关闭 swap 分区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#39;s&#x2F;.*swap.*&#x2F;#&amp;&#x2F;&#39; &#x2F;etc&#x2F;fstab</span><br></pre></td></tr></table></figure><p>以上为 K8s 系统的环境配置，这个条件是硬性的，必须要处理。接下来就是安装需要的配套工具了。</p><h4 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h4><p>设置环境，在 Docker 安装前设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt-get install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"></span><br><span class="line">curl -fsSL https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu&#x2F;gpg | apt-key add -</span><br><span class="line"></span><br><span class="line">add-apt-repository &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu $(lsb_release -cs) stable&quot; apt-get update</span><br></pre></td></tr></table></figure><p>删除已经存在的低版本 Docker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get purge docker-ce docker docker-engine docker.io  &amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;docker</span><br><span class="line"></span><br><span class="line">apt-get autoremove docker-ce docker docker-engine docker.io</span><br></pre></td></tr></table></figure><p>安装指定版本的 Docker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install -y docker-ce&#x3D;18.06.3~ce~3-0~ubuntu</span><br></pre></td></tr></table></figure><p>启动 Docker 并设置开机自重启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker &amp;&amp; systemctl start docker</span><br></pre></td></tr></table></figure><p>安装好 Docker 后，需要配置一下 Docker 以让其生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line">&#123;</span><br><span class="line"> &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line"> &quot;log-opts&quot;: &#123;</span><br><span class="line">   &quot;max-size&quot;: &quot;100m&quot;,</span><br><span class="line">   &quot;max-file&quot;: &quot;10&quot;</span><br><span class="line"> &#125;,</span><br><span class="line"> &quot;insecure-registries&quot;: [&quot;http:&#x2F;&#x2F;k8s.gcr.io&quot;],</span><br><span class="line"> &quot;data-root&quot;: &quot;&quot;,</span><br><span class="line"> &quot;default-runtime&quot;: &quot;nvidia&quot;,</span><br><span class="line"> &quot;runtimes&quot;: &#123;</span><br><span class="line">     &quot;nvidia&quot;: &#123;</span><br><span class="line">         &quot;path&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;nvidia-container-runtime&quot;,</span><br><span class="line">         &quot;runtimeArgs&quot;: []</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是含 GPU 的配置，如果你的机器不含 GPU，可按照下面来配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;:[</span><br><span class="line">&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;</span><br><span class="line">],</span><br><span class="line">&quot;storage-driver&quot;:&quot;overlay2&quot;,</span><br><span class="line">&quot;log-driver&quot;:&quot;json-file&quot;,</span><br><span class="line">&quot;log-opts&quot;:&#123;</span><br><span class="line">&quot;max-size&quot;:&quot;100m&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;exec-opts&quot;:[</span><br><span class="line">&quot;native.cgroupdriver&#x3D;systemd&quot;</span><br><span class="line">],</span><br><span class="line">&quot;insecure-registries&quot;:[&quot;http:&#x2F;&#x2F;k8s.gcr.io&quot;],</span><br><span class="line">&quot;live-restore&quot;:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们重启 Docker 服务并设置开机自动重启，重启后可以看到 Docker 的相关信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload &amp;&amp; systemctl restart docker &amp;&amp; docker info</span><br></pre></td></tr></table></figure><h4 id="安装-K8s"><a href="#安装-K8s" class="headerlink" title="安装 K8s"></a>安装 K8s</h4><p>在安装 K8s 之前，我们需要设置一下环境，以便很快的拉取相关的镜像，这里选择了阿里源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y apt-transport-https curl</span><br><span class="line"></span><br><span class="line">curl -s https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;apt&#x2F;doc&#x2F;apt-key.gpg | apt-key add -</span><br><span class="line"></span><br><span class="line">tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;kubernetes.list &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;apt kubernetes-xenial main</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>配置完阿里源后，我们更新一下资源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure><p>更新完后，先摒弃不可用或损坏的 K8s 组件 kubectl、kubeadm、kubelet 的残留：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get purge kubelet&#x3D;1.13.5-00 kubeadm&#x3D;1.13.5-00 kubectl&#x3D;1.13.5-00</span><br><span class="line">apt-get autoremove kubelet&#x3D;1.13.5-00 kubeadm&#x3D;1.13.5-00 kubectl&#x3D;1.13.5-00</span><br></pre></td></tr></table></figure><p>重新更新、安装一份指定版本的 K8s 组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install -y kubelet&#x3D;1.13.5-00 kubeadm&#x3D;1.13.5-00 kubectl&#x3D;1.13.5-00</span><br><span class="line">apt-mark hold kubelet&#x3D;1.13.5-00 kubeadm&#x3D;1.13.5-00 kubectl&#x3D;1.13.5-00</span><br></pre></td></tr></table></figure><p>这里的三大组件 kubectl、kubeadm、kubelet，都是比较重要的，下面简单介绍下：</p><ul><li>kubectl 是 K8s 集群的命令行工具，通过 kubectl 能够对集群本身进行管理，并能够在集群上进行容器化应用的安装部署。</li><li>kubeadm 是部署、安装 K8s 的一种命令工具。它提供了 <code>kubeadm init</code> 以及 <code>kubeadm join</code> 这两个命令作为快速创建 Kubernetes 集群的最佳实践。</li><li>关于 kubelet，在 K8s 集群中，在每个 Node 上都会启动一个 kubelet 服务的进程。该进程用于处理 Master 下发到本节点的任务，管理 Pod 及 Pod 中的容器。每个 kubelet 进程都会在 API Server 上注册节点自身的信息，定期向 Master 汇报节点资源的使用情况，并通过 cAdvisor 监控容器和节点资源。</li></ul><p>接下来启动服务并设置开机自动重启:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable kubelet &amp;&amp; sudo systemctl start kubelet</span><br></pre></td></tr></table></figure><p>组件安装好了，接下来安装 K8s 相关镜像，由于 gcr.io 网络访问不了，从 registry.cn-hangzhou.aliyuncs.com 镜像地址下载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com&#x2F;gg-gcr-io&#x2F;kube-apiserver:v1.13.5</span><br><span class="line"></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com&#x2F;gg-gcr-io&#x2F;kube-controller-manager:v1.13.5</span><br><span class="line"></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com&#x2F;gg-gcr-io&#x2F;kube-scheduler:v1.13.5</span><br><span class="line"></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com&#x2F;gg-gcr-io&#x2F;kube-proxy:v1.13.5</span><br><span class="line"></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com&#x2F;kuberimages&#x2F;pause:3.1</span><br><span class="line"></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com&#x2F;kuberimages&#x2F;etcd:3.2.24</span><br><span class="line"></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com&#x2F;kuberimages&#x2F;coredns:1.2.6</span><br></pre></td></tr></table></figure><p>注意：每个镜像的版本要注意，而且对应的 CoreDNS、Etcd 版本也要对应，每个版本的 K8s 对应的不一样的。否则，可能会出问题的。</p><p>拉取镜像后，我们需要打标签，因为 <code>kubeadm init</code> 的时候，标签是固定的，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com&#x2F;gg-gcr-io&#x2F;kube-apiserver:v1.13.5 k8s.gcr.io&#x2F;kube-apiserver:v1.13.5</span><br><span class="line"></span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com&#x2F;gg-gcr-io&#x2F;kube-controller-manager:v1.13.5 k8s.gcr.io&#x2F;kube-controller-manager:v1.13.5</span><br><span class="line"></span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com&#x2F;gg-gcr-io&#x2F;kube-scheduler:v1.13.5 k8s.gcr.io&#x2F;kube-scheduler:v1.13.5</span><br><span class="line"></span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com&#x2F;gg-gcr-io&#x2F;kube-proxy:v1.13.5 k8s.gcr.io&#x2F;kube-proxy:v1.13.5</span><br><span class="line"></span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com&#x2F;kuberimages&#x2F;pause:3.1 k8s.gcr.io&#x2F;pause:3.1</span><br><span class="line"></span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com&#x2F;kuberimages&#x2F;etcd:3.2.24 k8s.gcr.io&#x2F;etcd:3.2.24</span><br><span class="line"></span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com&#x2F;kuberimages&#x2F;coredns:1.2.6 k8s.gcr.io&#x2F;coredns:1.2.6</span><br></pre></td></tr></table></figure><h4 id="kubeadm-初始化"><a href="#kubeadm-初始化" class="headerlink" title="kubeadm 初始化"></a>kubeadm 初始化</h4><p>上面的操作步骤走完后，接下来就是利用 kubeadm 初始化 K8s，其中主机 IP 根据自己的实际情况输入，通过 <code>kubeadm init [flags]</code> 形式可以启动一个 master 节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --kubernetes-version&#x3D;v1.13.5 --pod-network-cidr&#x3D;10.244.0.0&#x2F;16 --service-cidr&#x3D;10.16.0.0&#x2F;16 --apiserver-advertise-address&#x3D;$&#123;masterIp&#125; | tee kubeadm-init.log</span><br></pre></td></tr></table></figure><p>此时，如果未知主机 IP，也可利用 yaml 文件动态初始化，我们通过 hosts 来进行动态加载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;hosts</span><br><span class="line">10.10.5.100 k8s.api.server</span><br><span class="line"></span><br><span class="line">vi kube-init.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: kubeadm.k8s.io&#x2F;v1beta1</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: v1.13.5</span><br><span class="line">imageRepository: registry.aliyuncs.com&#x2F;google_containers</span><br><span class="line">apiServer:</span><br><span class="line">  certSANs:</span><br><span class="line">  - &quot;k8s.api.server&quot;</span><br><span class="line">controlPlaneEndpoint: &quot;k8s.api.server:6443&quot;</span><br><span class="line">networking:</span><br><span class="line">  serviceSubnet: &quot;10.1.0.0&#x2F;16&quot;</span><br><span class="line">  podSubnet: &quot;10.244.0.0&#x2F;16&quot;</span><br></pre></td></tr></table></figure><p>设置 Etcd HA 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: kubeadm.k8s.io&#x2F;v1beta1</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: v1.13.5</span><br><span class="line">imageRepository: registry.aliyuncs.com&#x2F;google_containers</span><br><span class="line">apiServer:</span><br><span class="line">  certSANs:</span><br><span class="line">  - &quot;api.k8s.com&quot;</span><br><span class="line">controlPlaneEndpoint: &quot;api.k8s.com:6443&quot;</span><br><span class="line">etcd:</span><br><span class="line">    external:</span><br><span class="line">        endpoints:</span><br><span class="line">        - https:&#x2F;&#x2F;ETCD_0_IP:2379</span><br><span class="line">        - https:&#x2F;&#x2F;ETCD_1_IP:2379</span><br><span class="line">        - https:&#x2F;&#x2F;ETCD_2_IP:2379</span><br><span class="line">networking:</span><br><span class="line">  serviceSubnet: 10.1.0.0&#x2F;16</span><br><span class="line">  podSubnet: 10.244.0.0&#x2F;16</span><br></pre></td></tr></table></figure><p>注意：apiVersion 中用 kubeadm，因为需要用 kubeadm 来初始化，最后执行下面来初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --config&#x3D;kube-init.yaml</span><br></pre></td></tr></table></figure><p>请耐心等几分钟直到结束。</p><p>出现问题，解决后，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm reset</span><br></pre></td></tr></table></figure><p>如果需要更多，可执行下面来查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm --help</span><br></pre></td></tr></table></figure><p>部署如果没问题，查看当前的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubelet --version</span><br></pre></td></tr></table></figure><h4 id="部署出现问题"><a href="#部署出现问题" class="headerlink" title="部署出现问题"></a>部署出现问题</h4><p>先删除 node 节点（集群版）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl drain &lt;node name&gt; --delete-local-data --force --ignore-daemonsets</span><br><span class="line"></span><br><span class="line">kubectl delete node &lt;node name&gt;</span><br></pre></td></tr></table></figure><p>清空 init 配置在需要删除的节点上执行（注意，当执行 init 或者 join 后出现任何错误，都可以使用此命令返回）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm reset</span><br></pre></td></tr></table></figure><h4 id="查问题"><a href="#查问题" class="headerlink" title="查问题"></a>查问题</h4><p>初始化后出现问题，可以通过以下命令先查看其容器状态以及网络情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sudo docker ps -a | grep kube | grep -v pause</span><br><span class="line"></span><br><span class="line">sudo docker logs CONTAINERID</span><br><span class="line"></span><br><span class="line">sudo docker images &amp;&amp; systemctl status -l kubelet</span><br><span class="line"></span><br><span class="line">netstat -nlpt</span><br><span class="line"></span><br><span class="line">kubectl describe ep kubernetes</span><br><span class="line"></span><br><span class="line">kubectl describe svc kubernetes</span><br><span class="line"></span><br><span class="line">kubectl get svc kubernetes</span><br><span class="line"></span><br><span class="line">kubectl get ep</span><br><span class="line"></span><br><span class="line">netstat -nlpt | grep apiser</span><br><span class="line"></span><br><span class="line">vi &#x2F;var&#x2F;log&#x2F;syslog</span><br></pre></td></tr></table></figure><h4 id="给当前用户配置-K8s-apiserver-访问公钥"><a href="#给当前用户配置-K8s-apiserver-访问公钥" class="headerlink" title="给当前用户配置 K8s apiserver 访问公钥"></a>给当前用户配置 K8s apiserver 访问公钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p $HOME&#x2F;.kube</span><br><span class="line"></span><br><span class="line">sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config</span><br><span class="line"></span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config</span><br></pre></td></tr></table></figure><h4 id="网络插件"><a href="#网络插件" class="headerlink" title="网络插件"></a>网络插件</h4><p>在上面的步骤后，如果查看节点情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure><p>查看 nodes 状态信息，看到 node 节点的状态为 NotReady，这是因为缺少容器网络的配置。</p><p>接下来需要部署网络插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;docs.projectcalico.org&#x2F;v3.3&#x2F;getting-started&#x2F;kubernetes&#x2F;installation&#x2F;hosted&#x2F;rbac-kdd.yaml</span><br><span class="line"></span><br><span class="line">wget https:&#x2F;&#x2F;docs.projectcalico.org&#x2F;v3.3&#x2F;getting-started&#x2F;kubernetes&#x2F;installation&#x2F;hosted&#x2F;kubernetes-datastore&#x2F;calico-networking&#x2F;1.7&#x2F;calico.yaml</span><br><span class="line"></span><br><span class="line">vi calico.yaml</span><br><span class="line"></span><br><span class="line">- name: CALICO_IPV4POOL_IPIP</span><br><span class="line"> value:&quot;off&quot;</span><br><span class="line">- name: CALICO_IPV4POOL_CIDR</span><br><span class="line"> value: &quot;10.244.0.0&#x2F;16</span><br><span class="line"></span><br><span class="line">kubectl apply -f calico.yaml</span><br></pre></td></tr></table></figure><p>单机下允许 master 节点部署 pod 命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes --all node-role.kubernetes.io&#x2F;master-</span><br></pre></td></tr></table></figure><p>禁止 master 部署 pod：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes k8s node-role.kubernetes.io&#x2F;master&#x3D;true:NoSchedule</span><br></pre></td></tr></table></figure><p>以上单机版部署结束，如果你的项目中，交付的是软硬件结合的一体机，那么到此就结束了。记得单机下要允许 master 节点部署哟！</p><h3 id="K8s-集群版实战"><a href="#K8s-集群版实战" class="headerlink" title="K8s 集群版实战"></a>K8s 集群版实战</h3><p>以上面部署的机器为例，作为 master 节点，我们备份一些配置到节点机器，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scp &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $nodeUser@$nodeIp:&#x2F;home&#x2F;$nodeUser</span><br><span class="line"></span><br><span class="line">scp &#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;* $nodeUser@$nodeIp:&#x2F;home&#x2F;$nodeUser&#x2F;etcd</span><br><span class="line"></span><br><span class="line">kubeadm token generate</span><br><span class="line"></span><br><span class="line">kubeadm token create $token_name --print-join-command --ttl&#x3D;0</span><br><span class="line"></span><br><span class="line">kubeadm join $masterIP:6443 --token  $token_name --discovery-token-ca-cert-hash $hash</span><br></pre></td></tr></table></figure><p>注意，这个 token 24 小时后会失效，如果后面有其他节点要加入的话，处理方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubeadm token generate</span><br><span class="line"></span><br><span class="line">kubeadm token list</span><br><span class="line"></span><br><span class="line">openssl x509 -pubkey -in &#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;ca.crt | openssl rsa -pubin -outform der 2&gt;&#x2F;dev&#x2F;null | openssl dgst -sha256 -hex | sed &#39;s&#x2F;^.* &#x2F;&#x2F;&#39;</span><br></pre></td></tr></table></figure><p>然后拿到 token 和一个 sha256 密钥后执行下面即可加入集群：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join $masterIP:6443 --token  $token_name --discovery-token-ca-cert-hash $hash</span><br></pre></td></tr></table></figure><p>Node 机器执行时，如果需要 Cuda，可以参考以下资料：</p><ul><li><a href="https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html#ubuntu-installation" target="_blank" rel="noopener">https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html#ubuntu-installation</a></li><li><a href="https://blog.csdn.net/u012235003/article/details/54575758" target="_blank" rel="noopener">https://blog.csdn.net/u012235003/article/details/54575758</a></li><li><a href="https://blog.csdn.net/qq_39670011/article/details/90404111" target="_blank" rel="noopener">https://blog.csdn.net/qq_39670011/article/details/90404111</a></li></ul><p>正式执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;modprobe.d&#x2F;blacklist-nouveau.conf</span><br><span class="line"></span><br><span class="line">blacklist nouveau</span><br><span class="line">options nouveau modeset&#x3D;0</span><br><span class="line">update-initramfs -u</span><br></pre></td></tr></table></figure><p>重启 Ubuntu 查看是否禁用成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep nouveau</span><br><span class="line"></span><br><span class="line">apt-get remove --purge nvidia*</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;developer.nvidia.com&#x2F;cuda-downloads</span><br><span class="line"></span><br><span class="line">sudo apt-get install freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev libgl1-mesa-glx libglu1-mesa libglu1-mesa-dev</span><br></pre></td></tr></table></figure><p>安装 Cuda：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">accept</span><br><span class="line"></span><br><span class="line">select &quot;Install&quot; &#x2F; Enter</span><br><span class="line"></span><br><span class="line">select &quot;Yes&quot;</span><br><span class="line"></span><br><span class="line">sh cuda_10.1.168_418.67_linux.run</span><br><span class="line"></span><br><span class="line">echo &#39;export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;cuda-10.1&#x2F;bin:$PATH&#39; &gt;&gt; ~&#x2F;.bashrc</span><br><span class="line"></span><br><span class="line">echo &#39;export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;cuda-10.1&#x2F;NsightCompute-2019.3:$PATH&#39; &gt;&gt; ~&#x2F;.bashrc</span><br><span class="line"></span><br><span class="line">echo &#39;export LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;cuda-10.1&#x2F;lib64:$LD_LIBRARY_PATH&#39; &gt;&gt; ~&#x2F;.bashrc</span><br><span class="line"></span><br><span class="line">source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure><p>重启机器，检查 Cuda 是否安装成功。</p><p>查看是否有 nvidia* 的设备：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;dev &amp;&amp; ls -al</span><br></pre></td></tr></table></figure><p>如果没有，创建一个 nv.sh：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">vi nv.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash &#x2F;sbin&#x2F;modprobe nvidia</span><br><span class="line">if [ &quot;$?&quot; -eq 0 ];</span><br><span class="line">then</span><br><span class="line">NVDEVS&#x3D;&#96;lspci |</span><br><span class="line"> grep -i NVIDIA</span><br><span class="line">&#96;</span><br><span class="line">N3D&#x3D;&#96;</span><br><span class="line">echo</span><br><span class="line">&quot;$NVDEVS&quot;</span><br><span class="line">| grep &quot;3D controller&quot; |</span><br><span class="line"> wc -l</span><br><span class="line">&#96;</span><br><span class="line">NVGA&#x3D;&#96;</span><br><span class="line">echo</span><br><span class="line">&quot;$NVDEVS&quot;</span><br><span class="line">| grep &quot;VGA compatible controller&quot; |</span><br><span class="line"> wc -l</span><br><span class="line">&#96;</span><br><span class="line">N&#x3D;&#96;</span><br><span class="line">expr $N3D + $NVGA -</span><br><span class="line">1</span><br><span class="line">&#96;</span><br><span class="line">for i in &#96;</span><br><span class="line">seq</span><br><span class="line">0</span><br><span class="line"> $N</span><br><span class="line">&#96;; do</span><br><span class="line">    mknod -m 666 &#x2F;dev&#x2F;nvidia$i c 195 $i</span><br><span class="line">done</span><br><span class="line">    mknod -m 666 &#x2F;dev&#x2F;nvidiactl c 195 255</span><br><span class="line">else</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">chmod +x nv.sh &amp;&amp; bash nv.sh</span><br></pre></td></tr></table></figure><p>再次重启机器查看 Cuda 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;cuda-10.1&#x2F;samples &amp;&amp;  make</span><br><span class="line"></span><br><span class="line">cd  &#x2F;usr&#x2F;local&#x2F;cuda-10.1&#x2F;samples&#x2F;bin&#x2F;x86_64&#x2F;linux&#x2F;release .&#x2F;deviceQuery</span><br></pre></td></tr></table></figure><p>以上如果输出“Result = PASS”，代表 Cuda 安装成功。</p><p>安装 nvdocker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line">&#123;</span><br><span class="line">&quot;runtimes&quot;:&#123;</span><br><span class="line">    &quot;nvidia&quot;:&#123;</span><br><span class="line">         &quot;path&quot;:&quot;nvidia-container-runtime&quot;,</span><br><span class="line">          &quot;runtimeArgs&quot;:[]</span><br><span class="line">     &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;registry-mirrors&quot;:[&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;],</span><br><span class="line">&quot;storage-driver&quot;:&quot;overlay2&quot;,</span><br><span class="line">&quot;default-runtime&quot;:&quot;nvidia&quot;,</span><br><span class="line">&quot;log-driver&quot;:&quot;json-file&quot;,</span><br><span class="line">&quot;log-opts&quot;:&#123;</span><br><span class="line"> &quot;max-size&quot;:&quot;100m&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;exec-opts&quot;: [&quot;native.cgroupdriver&#x3D;systemd&quot;],</span><br><span class="line">&quot;insecure-registries&quot;: [$harborRgistry],</span><br><span class="line">&quot;live-restore&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启 Docker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload &amp;&amp; sudo systemctl restart docker &amp;&amp; docker info</span><br></pre></td></tr></table></figure><p>检查 nvidia-docker 安装是否成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --runtime&#x3D;nvidia --rm nvidia&#x2F;cuda:9.0-base nvidia-smi</span><br></pre></td></tr></table></figure><p>在节点机器进入 su 模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su $nodeUser</span><br></pre></td></tr></table></figure><p>给当前节点用户配置 K8s apiserver 访问公钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME&#x2F;.kube</span><br><span class="line"></span><br><span class="line">cp -i  admin.conf $HOME&#x2F;.kube&#x2F;config</span><br><span class="line"></span><br><span class="line">chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config</span><br><span class="line"></span><br><span class="line">mkdir -p $HOME&#x2F;etcd</span><br><span class="line"></span><br><span class="line">sudo rm -rf &#x2F;etc&#x2F;kubernetes</span><br><span class="line"></span><br><span class="line">sudo mkdir -p &#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd</span><br><span class="line"></span><br><span class="line">sudo cp &#x2F;home&#x2F;$nodeUser&#x2F;etcd&#x2F;* &#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd</span><br><span class="line"></span><br><span class="line">sudo kubeadm join $masterIP:6443 --token  $token_name --discovery-token-ca-cert-hash $hash</span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo kubeadm join 192.168.8.116:6443 --token vyi4ga.foyxqr2iz9i391q3 --discovery-token-ca-cert-hash sha256:929143bcdaa3e23c6faf20bc51ef6a57df02edf9df86cedf200320a9b4d3220a</span><br></pre></td></tr></table></figure><p>检查 node 是否加入 master：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get node</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;到此，K8s 单机、集群版部署流程就结束了，后面我们会将 K8s 与微服务结合一起来分析 K8s 的组件的特性。</p><h6 id="5-3-Kubernetes-的组件及负载均衡"><a href="#5-3-Kubernetes-的组件及负载均衡" class="headerlink" title="5.3 Kubernetes 的组件及负载均衡"></a>5.3 Kubernetes 的组件及负载均衡</h6><p>&emsp;&emsp;上面介绍了 K8s 的由来、概念以及特性，接下来，我们看看 K8s 的组件。K8s 的组件分为 Master 组件、Node 组件。</p><h5 id="Master-组件"><a href="#Master-组件" class="headerlink" title="Master 组件"></a>Master 组件</h5><p>1、kube-apiserver</p><p>&emsp;&emsp;Kubernetes API 服务器的主要实现是 kube-apiserver。 kube-apiserver 设计上考虑了水平伸缩，也就是说，它可通过部署多个实例进行伸缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。</p><p>2、etcd</p><p>&emsp;&emsp;etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。通常，集群的 etcd 数据库通常需要有个备份计划。</p><p>3、kube-controller-manager</p><p>&emsp;&emsp;在主节点上运行控制器的组件。</p><p>4、cloud-controller-manager</p><p>&emsp;&emsp;cloud-controller-manager 仅运行特定于云平台的控制回路。 如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的环境中不需要云控制器管理器。</p><p>5、kube-scheduler</p><p>&emsp;&emsp;控制平面组件，负责监视新创建的、未指定运行节点（node）的 Pods，选择节点让 Pod 在上面运行。调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。</p><h5 id="Node-组件"><a href="#Node-组件" class="headerlink" title="Node 组件"></a>Node 组件</h5><p>&emsp;&emsp;节点组件在每个节点上运行，维护运行的 Pod 并提供 Kubernetes 运行环境。如果 Master 也被设置允许为工作节点，则节点组件同样运行在 Master 上。</p><p>1、kubelet</p><p>&emsp;&emsp;一个在集群中每个节点（node）上运行的代理。 它保证容器（containers）都 运行在 Pod 中。</p><p>2、kube-proxy</p><p>&emsp;&emsp;kube-proxy 是集群中每个节点上运行的网络代理， 实现 Kubernetes 服务（Service） 概念的一部分。kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p><ul><li>1.kube-proxy 主要是处理集群外部通过 nodePort 访问集群内服务，通过 iptables 规则，解析 cluterIP 到 PodIp 的过程，并提供服务的负载均衡能力。</li><li>2.kube-proxy 还可以提供集群内部服务间通过 clusterIP 访问，也会经过 kube-proxy 负责转发。</li><li>3.kube-dns 主要在 Pod 内通过 serviceName 访问其他服务，找到服务对应的 clusterIP 的关系，和一些基本的域名解析功能。</li><li>4.kube-dns 是和 kube-proxy 协同工作的，前者通过 servicename 找到指定 clusterIP，后者完成通过 clusterIP 到 PodIP 的过程。</li><li>这里，K8s 通过虚拟出一个集群 IP，利用 kube-proxy 为 service 提供 cluster 内的服务发现和负载均衡。</li></ul><p>3、Container Runtime</p><p>&emsp;&emsp;容器运行环境是负责运行容器的软件。Kubernetes 支持多个容器运行环境: Docker、 containerd、CRI-O 以及任何实现 Kubernetes CRI (容器运行环境接口)。</p><p>4、插件 Addons</p><p>&emsp;&emsp;插件使用 Kubernetes 资源（DaemonSet、 Deployment 等）实现集群功能。 因为这些插件提供集群级别的功能，插件中命名空间域的资源属于 kube-system 命名空间。</p><p>5、DNS</p><p>&emsp;&emsp;尽管其他插件都并非严格意义上的必需组件，但几乎所有 Kubernetes 集群都应该 有集群 DNS， 因为很多示例都需要 DNS 服务。</p><p>6、Dashboard</p><p>&emsp;&emsp;Dashboard 是 Kubernetes 集群的通用的、基于 Web 的用户界面。 它使用户可以管理集群中运行的应用程序以及集群本身并进行故障排除。</p><p><img src="https://static001.geekbang.org/infoq/b5/b5662d4d56083e5a500dd73eb9d1244f.png" alt=""></p><h5 id="K8s如何实现服务注册与发现"><a href="#K8s如何实现服务注册与发现" class="headerlink" title="K8s如何实现服务注册与发现"></a>K8s如何实现服务注册与发现</h5><p>&emsp;&emsp;上面介绍了K8s的各种组件，接下来，我们看看K8s是如何实现服务的注册与发现，然后如何做到服务的转发、实现负载均衡的能力。</p><p>&emsp;&emsp;服务在K8s中，也定义了一种资源：Service，Service，顾名思义是一个服务，什么样的服务呢？它是定义了一个服务的多种 pod 的逻辑合集以及一种访问 pod 的策略。</p><p>service 的类型有四种：</p><ul><li>ExternalName：创建一个 DNS 别名指向 service name，这样可以防止 service name 发生变化，但需要配合 DNS 插件使用。</li><li>ClusterIP：默认的类型，用于为集群内 Pod 访问时，提供的固定访问地址,默认是自动分配地址,可使用 ClusterIP 关键字指定固定 IP。</li><li>NodePort：基于 ClusterIp，用于为集群外部访问 Service 后面 Pod 提供访问接入端口。</li><li>LoadBalancer：它是基于 NodePort。</li></ul><p>从上面讲的 Service，我们可以看到一种场景：所有的微服务在一个局域网内，或者说在一个 K8s 集群下，那么可以通过 Service 用于集群内 Pod 的访问，这就是 Service 默认的一种类型 ClusterIP，ClusterIP 这种的默认会自动分配地址。</p><p>&emsp;&emsp;那么问题来了，既然可以通过上面的 ClusterIp 来实现集群内部的服务访问，那么如何注册服务呢？其实 K8s 并没有引入任何的注册中心，使用的就是 K8s 的 kube-dns 组件。然后 K8s 将 Service 的名称当做域名注册到 kube-dns 中，每一个Service在kube-dns中都有一条DNS记录，同时，如果有服务的ip更换，kube-dns自动会同步，对服务来说是不需要改动的。通过 Service 的名称就可以访问其提供的服务。那么问题又来了，如果一个服务的 pod 对应有多个，那么如何实现 LB？其实，最终通过 kube-proxy，实现负载均衡。也就是说kube-dns通过 servicename 找到指定 clusterIP，kube-proxy完成通过 clusterIP 到 PodIP 的过程。</p><p>说到这，我们来看下 Service 的服务发现与负载均衡的策略，Service 负载分发策略有两种：</p><ul><li>RoundRobin：轮询模式，即轮询将请求转发到后端的各个 pod 上，其为默认模式。</li><li>SessionAffinity：基于客户端 IP 地址进行会话保持的模式，类似 IP Hash 的方式，来实现服务的负载均衡。</li></ul><p>下面写一个很简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: cas-server-service</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: cas-server01</span><br><span class="line">    port: 2000</span><br><span class="line">    targetPort: cas-server01</span><br><span class="line">  selector:</span><br><span class="line">    app: cas-server</span><br></pre></td></tr></table></figure><p>可以看到执行 kubectl apply -f service.yaml 后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ kubectl get svc</span><br><span class="line">NAME                          TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)              AGE</span><br><span class="line">admin-web-service             ClusterIP   10.16.129.24    &lt;none&gt;        2001&#x2F;TCP              84d</span><br><span class="line">cas-server-service            ClusterIP   10.16.230.167   &lt;none&gt;        2000&#x2F;TCP               67d</span><br><span class="line">cloud-admin-service-service   ClusterIP   10.16.25.178    &lt;none&gt;        1001&#x2F;TCP         190d</span><br></pre></td></tr></table></figure><p>这样，我们可以看到默认的类型是 ClusterIP，用于为集群内 Pod 访问时，可以先通过域名来解析到多个服务地址信息，然后再通过 LB 策略来选择其中一个作为请求的对象。</p><h5 id="K8s-如何处理微服务中常用的配置"><a href="#K8s-如何处理微服务中常用的配置" class="headerlink" title="K8s 如何处理微服务中常用的配置"></a>K8s 如何处理微服务中常用的配置</h5><p>&emsp;&emsp;接下来我们看看微服务中场景的居多配置该如何来利用K8s实现统一管理。其实，在K8s中，定义了一种资源：ConfigMap，我们来看看这种资源。</p><p>&emsp;&emsp;ConfigMap，看到这个名字可以理解：它是用于保存配置信息的键值对，可以用来保存单个属性，也可以保存配置文件。对于一些非敏感的信息，比如应用的配置信息，则可以使用 ConfigMap。</p><p>创建一个 ConfigMap 有多种方式如下。</p><ol><li><p>key-value 字符串创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap test-config --from-literal&#x3D;baseDir&#x3D;&#x2F;usr</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的命令创建了一个名为 test-config，拥有一条 key 为 baseDir，value 为 “/usr” 的键值对数据。</p></li><li><p>根据 yml 描述文件创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: test-config</span><br><span class="line">data:</span><br><span class="line">  baseDir: &#x2F;usr</span><br></pre></td></tr></table></figure><p>也可以这样，创建一个 yml 文件，选择不同的环境配置不同的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">kind: ConfigMap</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: cas-server</span><br><span class="line">data:</span><br><span class="line">  application.yaml: |-</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the World</span><br><span class="line">    ---</span><br><span class="line">    spring:</span><br><span class="line">      profiles: dev</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Dev</span><br><span class="line">    spring:</span><br><span class="line">      profiles: test</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Test</span><br><span class="line">    spring:</span><br><span class="line">      profiles: prod</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Prod</span><br></pre></td></tr></table></figure><p>注意点：</p></li></ol><ul><li>ConfigMap 必须在 Pod 使用其之前创建。</li><li>Pod 只能使用同一个命名空间的 ConfigMap。</li></ul><p>&emsp;&emsp;当然，还有其他更多用途，具体可以参考官网(<a href="https://kubernetes.io/zh/docs/concepts/configuration/configmap/)。" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/concepts/configuration/configmap/)。</a></p><p>前面讲述了几种创建ConfigMap的方式，其中有一种在 Java 中常常用到：通过创建 yml 文件来实现配置管理。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">kind: ConfigMap</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: cas-server</span><br><span class="line">data:</span><br><span class="line">  application.yaml: |-</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the World</span><br><span class="line">    ---</span><br><span class="line">    spring:</span><br><span class="line">      profiles: dev</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Dev</span><br><span class="line">    spring:</span><br><span class="line">      profiles: test</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Test</span><br><span class="line">    spring:</span><br><span class="line">      profiles: prod</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Prod</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样，当我们启动容器时，通过 –spring.profiles.active=dev 来指定当前容器的活跃环境，即可获取 ConfigMap 中对应的配置。是不是感觉跟 Java 中的 Config 配置多个环境的配置有点类似呢？但是，我们不用那么复杂，这些统统可以交给 K8s 来处理。只需要你启动这一命令即可，是不是很简单？</p><h5 id="第六章-为什么选择-Kubernetes-1"><a href="#第六章-为什么选择-Kubernetes-1" class="headerlink" title="第六章 为什么选择 Kubernetes"></a>第六章 为什么选择 Kubernetes</h5><h6 id="6-1-Kubernetes-与微服务的天生绝配-1"><a href="#6-1-Kubernetes-与微服务的天生绝配-1" class="headerlink" title="6.1 Kubernetes 与微服务的天生绝配"></a>6.1 Kubernetes 与微服务的天生绝配</h6><p>&emsp;&emsp;其实，为什么我们需要 K8s，它到底能做什么呢？</p><p>&emsp;&emsp;容器是打包和运行应用程序的好方式。在生产环境中，你需要管理运行应用程序的容器，并确保不会停机。 例如，如果一个容器发生故障，则需要启动另一个容器。如果系统处理此行为，会不会更容易？这就是 Kubernetes 来解决这些问题的方法！ Kubernetes 为你提供了一个可弹性运行分布式系统的框架。 Kubernetes 会满足你的扩展要求、故障转移、部署模式等。 例如，Kubernetes 可以轻松管理系统的 Canary 部署。</p><p>Kubernetes 会提供：</p><ul><li>服务发现和负载均衡，Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</li><li>自动部署和回滚，你可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态更改为期望状态。例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。</li><li>自我修复，Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。</li><li>存储编排，Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。</li><li>自动完成装箱计算，Kubernetes 允许你指定每个容器所需 CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。</li><li>密钥与配置管理，Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</li></ul><p>&emsp;&emsp;那么对于 K8s 提供的这些功能，其实对于微服务来讲，都是很好的一个平台提供。换句话说，对于微服务来说，如果使用 K8s 的话，可以不用考虑语言上的限制，更不用考虑各种开发语言的框架的限制；对于各种语言来说，在前面也介绍过，都有很多不同的框架，那如果运用这些框架时，就需要考虑不同服务之间如果属于不同的语言，那么该如何来实现微服务的架构呢？从这一角度来分析，微服务与 K8s 属于天作之合，它们的结合可以说是天衣无缝、完美至极。在后面章节中，将会介绍它们的天衣无缝：自治与无缝迁移。</p><h6 id="6-2-基于-Kubernetes-集群的服务治理-1"><a href="#6-2-基于-Kubernetes-集群的服务治理-1" class="headerlink" title="6.2 基于 Kubernetes 集群的服务治理"></a>6.2 基于 Kubernetes 集群的服务治理</h6><p>&emsp;&emsp;其实，做微服务架构设计，我们希望得到什么呢？看下图：<br><img src="https://static001.geekbang.org/infoq/5c/5c17301931632913b47422c2262931c4.png" alt=""></p><p>&emsp;&emsp;从上面这张图中可以看到，微服务的解耦、封装，从而简化开发人员的开发。调用方便，主要体现在sdk或者说client的提供者很容易被调用，这就体现了K8s的服务注册与发现。安全性考虑，基于K8s集群的保障，可以让微服务们处于一个堡垒中，这样避免外部的干扰。同时，服务之间直接走内部网络，可以大大提升性能。</p><p>&emsp;&emsp;说到这些，其实服务的自动化才是一个重点，自治能力体现了系统的健壮性。在前面章节中说到了K8s具有自动修复的能力，可以将失败或出现问题的容器进行重新编排、启动。容器本身的健康检查会被监视，当不响应用户定义的运行检查的容器就会被杀死。</p><p>&emsp;&emsp;同时，K8s提供自动部署能力，可以通过简单的命令来执行即可发挥K8s的作用。同时，K8s会根据用户的节点选择，将pod分配到对应的节点，这样对于运维人员来说，即使出现节点宕机，pod可以迅速的在其他节点被启动。</p><h6 id="6-3-基于-Kubernetes-的服务无缝迁移-1"><a href="#6-3-基于-Kubernetes-的服务无缝迁移-1" class="headerlink" title="6.3 基于 Kubernetes 的服务无缝迁移"></a>6.3 基于 Kubernetes 的服务无缝迁移</h6><p>&emsp;&emsp;在K8s集群中的服务，如果想要被迁移到其他的机器或其他集群。在传统的实现中，可能需要考虑到很多点：服务包的转移、共享，配置的转移，数据库的转移等等。但对于容器化来说，这些都被打包成image，而这些image可以被上传到一个仓库Habor，当需要迁移环境的时候，这些服务的镜像其实都可以不动，运维人员将要做的是：将开发人员编写的基于K8s的yaml文件在对应的集群中进行部署即可。运维人员无需关心任何其他事情，只需要在部署前，将需要的相关配置处理好即可。这将大大减少开发人员、运维的成本，让他们专注于部署，而不用关心其他的琐碎的事情。因为K8s是可以跨平台、跨系统的。主要存在K8s集群，服务都可以无缝的进行迁移过去。这也是微服务基于K8s的一个优势。下图为K8s基于Habor的架构图。</p><p><img src="https://static001.geekbang.org/infoq/e8/e847a9866cc308fc964fad04cd808c16.png" alt=""></p><ul><li>通过kubectl命令工具发起资源创建kubectl create -f xxx.yaml</li><li>k8s处理相关请求后kube-scheduler服务为pod寻找一个合适的“家”node2并创建pod。</li><li>node2上的kubelet处理相关资源，使用docker拉取相关镜像并运行。</li></ul><p>&emsp;&emsp;从上面的流程操作来看，将微服务从一个K8s集群，迁移到另一个集群，其操作是可以无缝对接的，可以同配置、同环境参数的无缝的迁移，这就是云原生下K8s带来的优势。也是需要企业现在一直推荐属性docker、K8s等技术的一个关键性要素。</p><h5 id="第七章-第一个基于-K8s-的多语言微服务架构-1"><a href="#第七章-第一个基于-K8s-的多语言微服务架构-1" class="headerlink" title="第七章 第一个基于 K8s 的多语言微服务架构"></a>第七章 第一个基于 K8s 的多语言微服务架构</h5><h6 id="7-1-基于-K8s-的-Java-微服务-1"><a href="#7-1-基于-K8s-的-Java-微服务-1" class="headerlink" title="7.1 基于 K8s 的 Java 微服务"></a>7.1 基于 K8s 的 Java 微服务</h6><p>&emsp;&emsp;前面很多的都是在说K8s为什么可以实现配置化，为什么可以提供负载均衡能力，接下来，我们举个电商系统来实现体验下K8s带来的效果，手写Java代码。</p><p>&emsp;&emsp;如下图，我们简单的画了一个系统图，从客户端到网关，再到订单服务、后台管理系统以及鉴权中心的流程。<br><img src="https://static001.geekbang.org/infoq/36/36548234c9acc7889fc9fd12fb0866e8.png" alt=""></p><h5 id="认证中心"><a href="#认证中心" class="headerlink" title="认证中心"></a>认证中心</h5><p>&emsp;&emsp;基于Java现在许多比较流行的框架，作者选择了SpringCloud，因为很多基础特性SpringCloud都具备了，接下来我们看如何实现鉴权。</p><p>环境：</p><ul><li>Ubuntu 16.04</li><li>Docker 18.06</li><li>K8s 1.13.5</li><li>springboot 2.3.8.RELEASE</li><li>springcloud Hoxton.SR9</li></ul><p>首先新建一个Java项目：</p><p><img src="https://static001.geekbang.org/infoq/35/35b9ebb2d04125500128008d6f41a50f.png" alt=""></p><p>引入依赖配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-actuator-autoconfigure&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-kubernetes-config&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.jsonwebtoken&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jjwt&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.9.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.hutool&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hutool-all&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.6.3&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;19.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;commons-lang3&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-collections&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- mybatis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.1.1&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;$&#123;mysql.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- datasource pool--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.3&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>新建服务启动类：</p><p><img src="https://static001.geekbang.org/infoq/ef/ef481f8fb27ab610a568214f61f0cb2e.png" alt=""></p><p>常见的配置文件bootstrap.yml、application.yml，主要是配置服务启动时，需要加载的参数、配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">management:</span><br><span class="line">  endpoint:</span><br><span class="line">    restart:</span><br><span class="line">      enabled: true</span><br><span class="line">    health:</span><br><span class="line">      enabled: true</span><br><span class="line">    info:</span><br><span class="line">      enabled: true</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cas-server</span><br><span class="line">  cloud:</span><br><span class="line">    kubernetes:</span><br><span class="line">      config:</span><br><span class="line">        sources:</span><br><span class="line">         - name: $&#123;spring.application.name&#125;</span><br><span class="line">           namespace: system-server</span><br><span class="line">      discovery:</span><br><span class="line">        all-namespaces: true</span><br><span class="line">      reload:</span><br><span class="line">        #自动更新配置的开关设置为打开</span><br><span class="line">        enabled: true</span><br><span class="line">        #更新配置信息的模式：polling是主动拉取，event是事件通知</span><br><span class="line">        mode: polling</span><br><span class="line">        #主动拉取的间隔时间是500毫秒</span><br><span class="line">        period: 500</span><br><span class="line"></span><br><span class="line">  redis: #redis相关配置</span><br><span class="line">    database: 8</span><br><span class="line">    host: 10.10.3.15 #localhost</span><br><span class="line">    port: 6379</span><br><span class="line">    password: xxxxx  #有密码时设置</span><br><span class="line">    jedis:</span><br><span class="line">      pool:</span><br><span class="line">        max-active: 8</span><br><span class="line">        max-idle: 8</span><br><span class="line">        min-idle: 0</span><br><span class="line">    timeout: 10000ms</span><br><span class="line"></span><br><span class="line">  http:</span><br><span class="line">    encoding:</span><br><span class="line">      charset: UTF-8</span><br><span class="line">      enabled: true</span><br><span class="line">      force: true</span><br><span class="line">  mvc:</span><br><span class="line">    throw-exception-if-no-handler-found: true</span><br><span class="line">  main:</span><br><span class="line">    allow-bean-definition-overriding: true</span><br><span class="line"></span><br><span class="line">logging:</span><br><span class="line">  path: &#x2F;data&#x2F;$&#123;spring.application.name&#125;&#x2F;logs</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第一个配置中，介绍了该服务的信息，以及springboot2结合K8s的一个特性：自动刷新、加载配置，该模式有两种：</p><ul><li>主动拉取：polling，每隔一定时间拉取，自定义设置。</li><li>事件通知，event</li></ul><p>&emsp;&emsp;这里主要用主动拉取模式。后面就是配置一些插件redis、日志配置。</p><p>&emsp;&emsp;第二个配置文件可以设置一些环境、mybatis配置以及设置http协议的超时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 2000</span><br><span class="line">  undertow:</span><br><span class="line">    accesslog:</span><br><span class="line">      enabled: false</span><br><span class="line">      pattern: combined</span><br><span class="line">  servlet:</span><br><span class="line">    session:</span><br><span class="line">      timeout: PT120M</span><br><span class="line"></span><br><span class="line">client:</span><br><span class="line">  http:</span><br><span class="line">    request:</span><br><span class="line">      connectTimeout: 8000</span><br><span class="line">      readTimeout: 30000</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  mapperLocations: classpath:mapper&#x2F;*.xml</span><br><span class="line">  typeAliasesPackage: com.damon.*.model</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由于我们可以设置<strong>spring.profiles.active=dev</strong>，所以可以设置几个不同环境的文件来设置日志的级别。当然，你也可以直接在启动服务时，设置参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- spring.profiles.active&#x3D;dev --logging.level.org.springframework.web&#x3D;INFO --logging.level.com.damon&#x3D;INFO</span><br></pre></td></tr></table></figure><p>到目前为止，一些基础配置都已经写完了，接下来，我们看看鉴权的核心逻辑了。首先我们来写一个认证服务器配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">package com.damon.config;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.core.env.Environment;</span><br><span class="line">import org.springframework.security.authentication.AuthenticationManager;</span><br><span class="line">import org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line">import org.springframework.security.oauth2.config.annotation.builders.ClientDetailsServiceBuilder;</span><br><span class="line">import org.springframework.security.oauth2.config.annotation.builders.InMemoryClientDetailsServiceBuilder;</span><br><span class="line">import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;</span><br><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;</span><br><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;</span><br><span class="line">import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;</span><br><span class="line">import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;</span><br><span class="line">import org.springframework.security.oauth2.provider.error.WebResponseExceptionTranslator;</span><br><span class="line">import org.springframework.security.oauth2.provider.token.TokenEnhancer;</span><br><span class="line">import org.springframework.security.oauth2.provider.token.TokenEnhancerChain;</span><br><span class="line">import org.springframework.security.oauth2.provider.token.TokenStore;</span><br><span class="line">import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;</span><br><span class="line"></span><br><span class="line">import com.damon.component.JwtTokenEnhancer;</span><br><span class="line">import com.damon.login.service.LoginService;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *</span><br><span class="line"> * 认证服务器配置</span><br><span class="line"> * @author Damon</span><br><span class="line"> * @date 2020年1月13日 下午3:03:30</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">@EnableAuthorizationServer</span><br><span class="line">public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private LoginService loginService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    &#x2F;&#x2F;@Qualifier(&quot;jwtTokenStore&quot;)</span><br><span class="line">    @Qualifier(&quot;redisTokenStore&quot;)</span><br><span class="line">    private TokenStore tokenStore;</span><br><span class="line">    &#x2F;*@Autowired</span><br><span class="line">    private JwtAccessTokenConverter jwtAccessTokenConverter;</span><br><span class="line">    @Autowired</span><br><span class="line">    private JwtTokenEnhancer jwtTokenEnhancer;*&#x2F;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Environment env;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private WebResponseExceptionTranslator userOAuth2WebResponseExceptionTranslator;</span><br><span class="line"></span><br><span class="line">   &#x2F;* @Override</span><br><span class="line">    public void configure(AuthorizationServerEndpointsConfigurer endpoints) &#123;</span><br><span class="line">        TokenEnhancerChain enhancerChain &#x3D; new TokenEnhancerChain();</span><br><span class="line">        List&lt;TokenEnhancer&gt; delegates &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        delegates.add(jwtTokenEnhancer); &#x2F;&#x2F;配置JWT的内容增强器</span><br><span class="line">        delegates.add(jwtAccessTokenConverter);</span><br><span class="line">        enhancerChain.setTokenEnhancers(delegates);</span><br><span class="line">        endpoints.authenticationManager(authenticationManager)&#x2F;&#x2F;支持 password 模式</span><br><span class="line">                .userDetailsService(loginService)</span><br><span class="line">                .tokenStore(tokenStore) &#x2F;&#x2F;配置令牌存储策略</span><br><span class="line">                .accessTokenConverter(jwtAccessTokenConverter)</span><br><span class="line">                .tokenEnhancer(enhancerChain);</span><br><span class="line">    &#125;*&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * redis token 方式</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F;验证时发生的情况处理</span><br><span class="line">        endpoints.authenticationManager(authenticationManager) &#x2F;&#x2F;支持 password 模式</span><br><span class="line">        .exceptionTranslator(userOAuth2WebResponseExceptionTranslator)&#x2F;&#x2F;自定义异常处理类添加到认证服务器配置</span><br><span class="line">                .userDetailsService(loginService)</span><br><span class="line">                .tokenStore(tokenStore);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 客户端配置（给谁发令牌）</span><br><span class="line">     * 不同客户端配置不同</span><br><span class="line">     *</span><br><span class="line">     * authorizedGrantTypes 可以包括如下几种设置中的一种或多种：</span><br><span class="line">authorization_code：授权码类型。需要redirect_uri</span><br><span class="line">implicit：隐式授权类型。需要redirect_uri</span><br><span class="line">password：资源所有者（即用户）密码类型。</span><br><span class="line">client_credentials：客户端凭据（客户端ID以及Key）类型。</span><br><span class="line">refresh_token：通过以上授权获得的刷新令牌来获取新的令牌。</span><br><span class="line"></span><br><span class="line">   accessTokenValiditySeconds：token 的有效期</span><br><span class="line">   scopes：用来限制客户端访问的权限，在换取的 token 的时候会带上 scope 参数，只有在 scopes 定义内的，才可以正常换取 token。</span><br><span class="line">     * @param clients</span><br><span class="line">     * @throws Exception</span><br><span class="line">     * @author Damon</span><br><span class="line">     * @date 2020年1月13日</span><br><span class="line">     *</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                .withClient(&quot;admin-web&quot;)</span><br><span class="line">                .secret(passwordEncoder.encode(&quot;admin-web-123&quot;))</span><br><span class="line">                .accessTokenValiditySeconds(3600)</span><br><span class="line">                .refreshTokenValiditySeconds(864000)&#x2F;&#x2F;配置刷新token的有效期</span><br><span class="line">                .autoApprove(true) &#x2F;&#x2F;自动授权配置</span><br><span class="line">                .scopes(&quot;all&quot;)&#x2F;&#x2F;配置申请的权限范围</span><br><span class="line">                .authorizedGrantTypes(&quot;password&quot;, &quot;authorization_code&quot;, &quot;client_credentials&quot;, &quot;refresh_token&quot;)&#x2F;&#x2F;配置授权模式</span><br><span class="line">                .redirectUris(&quot;http:&#x2F;&#x2F;localhost:2001&#x2F;login&quot;)&#x2F;&#x2F;授权码模式开启后必须指定</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .withClient(&quot;order-service&quot;)</span><br><span class="line">                .secret(passwordEncoder.encode(&quot;order-service-123&quot;))</span><br><span class="line">                .accessTokenValiditySeconds(3600)</span><br><span class="line">                .refreshTokenValiditySeconds(864000)&#x2F;&#x2F;配置刷新token的有效期</span><br><span class="line">                .autoApprove(true) &#x2F;&#x2F;自动授权配置</span><br><span class="line">                .scopes(&quot;all&quot;)</span><br><span class="line">                .authorizedGrantTypes(&quot;password&quot;, &quot;authorization_code&quot;, &quot;client_credentials&quot;, &quot;refresh_token&quot;)&#x2F;&#x2F;配置授权模式</span><br><span class="line">                .redirectUris(&quot;http:&#x2F;&#x2F;localhost:2003&#x2F;login&quot;)&#x2F;&#x2F;授权码模式开启后必须指定</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .withClient(&quot;customer-service&quot;)</span><br><span class="line">                .secret(passwordEncoder.encode(&quot;customer-service-123&quot;))</span><br><span class="line">                .accessTokenValiditySeconds(3600)</span><br><span class="line">                .refreshTokenValiditySeconds(864000)&#x2F;&#x2F;配置刷新token的有效期</span><br><span class="line">                .autoApprove(true) &#x2F;&#x2F;自动授权配置</span><br><span class="line">                .scopes(&quot;all&quot;)</span><br><span class="line">                .authorizedGrantTypes(&quot;password&quot;, &quot;authorization_code&quot;, &quot;client_credentials&quot;, &quot;refresh_token&quot;)&#x2F;&#x2F;配置授权模式</span><br><span class="line">                .redirectUris(&quot;http:&#x2F;&#x2F;localhost:6000&#x2F;login&quot;)&#x2F;&#x2F;授权码模式开启后必须指定</span><br><span class="line">                ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(AuthorizationServerSecurityConfigurer security) &#123;</span><br><span class="line">    security.allowFormAuthenticationForClients();&#x2F;&#x2F;是允许客户端访问 OAuth2 授权接口，否则请求 token 会返回 401</span><br><span class="line">    security.checkTokenAccess(&quot;isAuthenticated()&quot;);&#x2F;&#x2F;是允许已授权用户访问 checkToken 接口</span><br><span class="line">        security.tokenKeyAccess(&quot;isAuthenticated()&quot;); &#x2F;&#x2F; security.tokenKeyAccess(&quot;permitAll()&quot;);获取密钥需要身份认证，使用单点登录时必须配置，是允许已授权用户获取 token 接口</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个配置中，我们redis来记录token，自定义了登录认证的逻辑LoginService，自定义异常处理类添加到认证服务器配置。同时函数<strong>configure</strong>加载了居多需要认证的客户端服务，配置了授权模式：”password”、”authorization_code”、”client_credentials”、”refresh_token”，配置刷新token的有效期。</p><p>&emsp;&emsp;我们先来看看自定义的认证逻辑，先来看看接口类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package com.damon.login.service;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">import org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line">import org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line">import org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"></span><br><span class="line">import com.damon.commons.Response;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author  Damon</span><br><span class="line"> * @date 2018年11月15日 上午11:59:24</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">public interface LoginService extends UserDetailsService &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *</span><br><span class="line"> * Spring Security默认函数</span><br><span class="line"> * @param username</span><br><span class="line"> * @return</span><br><span class="line"> * @throws UsernameNotFoundException</span><br><span class="line"> * @author Damon</span><br><span class="line"> * @date 2020年1月13日</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;以下自定义</span><br><span class="line"></span><br><span class="line">Response&lt;Object&gt; login(String username, String password);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *</span><br><span class="line"> * 校验token合法性</span><br><span class="line"> * @param request</span><br><span class="line"> * @param token</span><br><span class="line"> * @return</span><br><span class="line"> * @author Damon</span><br><span class="line"> * @date 2019年8月15日</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">Response&lt;Object&gt; verify(HttpServletRequest request, String token);</span><br><span class="line"></span><br><span class="line">Response&lt;Object&gt; updatePwd(HttpServletRequest req, String username, String oldPwd, String newPwd);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Response&lt;Object&gt; logout(HttpServletRequest req, HttpServletResponse res);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在Spring Security中，有默认的函数<strong>loadUserByUsername</strong>来实现鉴权逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Auth</span><br><span class="line">     * 登录认证</span><br><span class="line">     * 实际中从数据库获取信息</span><br><span class="line">     * 这里为了做演示，把用户名、密码和所属角色都写在代码里了，正式环境中，这里应该是从数据库或者其他地方根据用户名将加密后的密码及所属角色查出来的。账号 damon ，</span><br><span class="line">     * 密码123456，稍后在换取 token 的时候会用到。并且给这个用户设置 &quot;ROLE_ADMIN&quot; 角色。</span><br><span class="line">     *</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;</span><br><span class="line">    logger.info(&quot;clientIp is: &#123;&#125; ,username: &#123;&#125;&quot;, IpUtil.getClientIp(req), username);</span><br><span class="line">logger.info(&quot;serverIp is: &#123;&#125;&quot;, IpUtil.getCurrentIp());</span><br><span class="line">&#x2F;&#x2F; 查询数据库操作</span><br><span class="line">SysUser user &#x3D; userMapper.getUserByUsername(username);</span><br><span class="line">if (user &#x3D;&#x3D; null) &#123;</span><br><span class="line">logger.error(&quot;user not exist&quot;);</span><br><span class="line">throw new UsernameNotFoundException(&quot;username is not exist&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">&#x2F;&#x2F; 用户角色也应在数据库中获取，这里简化</span><br><span class="line">String role &#x3D; &quot;&quot;;</span><br><span class="line">if(user.getIsAdmin() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">role &#x3D; &quot;admin&quot;;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;SimpleGrantedAuthority&gt; authorities &#x3D; Lists.newArrayList();</span><br><span class="line">authorities.add(new SimpleGrantedAuthority(role));</span><br><span class="line">&#x2F;&#x2F;String password &#x3D; passwordEncoder.encode(&quot;123456&quot;);&#x2F;&#x2F; 123456是密码</span><br><span class="line">&#x2F;&#x2F;return new User(username, password, authorities);</span><br><span class="line">&#x2F;&#x2F; 线上环境应该通过用户名查询数据库获取加密后的密码</span><br><span class="line">return new User(username, user.getPassword(), authorities);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到通过用户信息获取用户的权限，然后记录用户信息。这里使用redis来记录用户信息以及token信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.damon.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line">import org.springframework.security.oauth2.provider.token.TokenStore;</span><br><span class="line">import org.springframework.security.oauth2.provider.token.store.redis.RedisTokenStore;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 使用redis存储token的配置</span><br><span class="line"> * @author Damon</span><br><span class="line"> * @date 2020年1月13日 下午3:03:19</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">public class RedisTokenStoreConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisConnectionFactory redisConnectionFactory;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public TokenStore redisTokenStore ()&#123;</span><br><span class="line">        &#x2F;&#x2F;return new RedisTokenStore(redisConnectionFactory);</span><br><span class="line">    return new MyRedisTokenStore(redisConnectionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同时，我们自定义了异常处理类，统一处理异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">package com.damon.config;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import org.springframework.http.HttpHeaders;</span><br><span class="line">import org.springframework.http.HttpStatus;</span><br><span class="line">import org.springframework.http.ResponseEntity;</span><br><span class="line">import org.springframework.security.access.AccessDeniedException;</span><br><span class="line">import org.springframework.security.core.AuthenticationException;</span><br><span class="line">import org.springframework.security.oauth2.common.DefaultThrowableAnalyzer;</span><br><span class="line">import org.springframework.security.oauth2.common.exceptions.InsufficientScopeException;</span><br><span class="line">import org.springframework.security.oauth2.common.exceptions.OAuth2Exception;</span><br><span class="line">import org.springframework.security.oauth2.provider.error.WebResponseExceptionTranslator;</span><br><span class="line">import org.springframework.security.web.util.ThrowableAnalyzer;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.web.HttpRequestMethodNotSupportedException;</span><br><span class="line"></span><br><span class="line">import com.damon.exception.UserOAuth2Exception;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *</span><br><span class="line"> * 自定义异常转换类</span><br><span class="line"> * @author Damon</span><br><span class="line"> * @date 2020年2月27日 上午10:28:19</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">@Component(&quot;userOAuth2WebResponseExceptionTranslator&quot;)</span><br><span class="line">public class UserOAuth2WebResponseExceptionTranslator implements WebResponseExceptionTranslator &#123;</span><br><span class="line">    private ThrowableAnalyzer throwableAnalyzer &#x3D; new DefaultThrowableAnalyzer();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ResponseEntity&lt;OAuth2Exception&gt; translate(Exception e) throws Exception &#123;</span><br><span class="line">        Throwable[] causeChain &#x3D; this.throwableAnalyzer.determineCauseChain(e);</span><br><span class="line">        Exception ase &#x3D; (OAuth2Exception)this.throwableAnalyzer.getFirstThrowableOfType(OAuth2Exception.class, causeChain);</span><br><span class="line">        &#x2F;&#x2F;异常链中有OAuth2Exception异常</span><br><span class="line">        if (ase !&#x3D; null) &#123;</span><br><span class="line">            return this.handleOAuth2Exception((OAuth2Exception)ase);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;身份验证相关异常</span><br><span class="line">        ase &#x3D; (AuthenticationException)this.throwableAnalyzer.getFirstThrowableOfType(AuthenticationException.class, causeChain);</span><br><span class="line">        if (ase !&#x3D; null) &#123;</span><br><span class="line">            return this.handleOAuth2Exception(new UserOAuth2WebResponseExceptionTranslator.UnauthorizedException(e.getMessage(), e));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;异常链中包含拒绝访问异常</span><br><span class="line">        ase &#x3D; (AccessDeniedException)this.throwableAnalyzer.getFirstThrowableOfType(AccessDeniedException.class, causeChain);</span><br><span class="line">        if (ase instanceof AccessDeniedException) &#123;</span><br><span class="line">            return this.handleOAuth2Exception(new UserOAuth2WebResponseExceptionTranslator.ForbiddenException(ase.getMessage(), ase));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;异常链中包含Http方法请求异常</span><br><span class="line">        ase &#x3D; (HttpRequestMethodNotSupportedException)this.throwableAnalyzer.getFirstThrowableOfType(HttpRequestMethodNotSupportedException.class, causeChain);</span><br><span class="line">        if(ase instanceof HttpRequestMethodNotSupportedException)&#123;</span><br><span class="line">            return this.handleOAuth2Exception(new UserOAuth2WebResponseExceptionTranslator.MethodNotAllowed(ase.getMessage(), ase));</span><br><span class="line">        &#125;</span><br><span class="line">        return this.handleOAuth2Exception(new UserOAuth2WebResponseExceptionTranslator.ServerErrorException(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase(), e));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ResponseEntity&lt;OAuth2Exception&gt; handleOAuth2Exception(OAuth2Exception e) throws IOException &#123;</span><br><span class="line">        int status &#x3D; e.getHttpErrorCode();</span><br><span class="line">        HttpHeaders headers &#x3D; new HttpHeaders();</span><br><span class="line">        headers.set(&quot;Cache-Control&quot;, &quot;no-store&quot;);</span><br><span class="line">        headers.set(&quot;Pragma&quot;, &quot;no-cache&quot;);</span><br><span class="line">        if (status &#x3D;&#x3D; HttpStatus.UNAUTHORIZED.value() || e instanceof InsufficientScopeException) &#123;</span><br><span class="line">            headers.set(&quot;WWW-Authenticate&quot;, String.format(&quot;%s %s&quot;, &quot;Bearer&quot;, e.getSummary()));</span><br><span class="line">        &#125;</span><br><span class="line">        UserOAuth2Exception exception &#x3D; new UserOAuth2Exception(e.getMessage(),e);</span><br><span class="line">        ResponseEntity&lt;OAuth2Exception&gt; response &#x3D; new ResponseEntity(exception, headers, HttpStatus.valueOf(status));</span><br><span class="line">        return response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static class MethodNotAllowed extends OAuth2Exception &#123;</span><br><span class="line">        public MethodNotAllowed(String msg, Throwable t) &#123;</span><br><span class="line">            super(msg, t);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public String getOAuth2ErrorCode() &#123;</span><br><span class="line">            return &quot;method_not_allowed&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public int getHttpErrorCode() &#123;</span><br><span class="line">            return 405;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class UnauthorizedException extends OAuth2Exception &#123;</span><br><span class="line">        public UnauthorizedException(String msg, Throwable t) &#123;</span><br><span class="line">            super(msg, t);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public String getOAuth2ErrorCode() &#123;</span><br><span class="line">            return &quot;unauthorized&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public int getHttpErrorCode() &#123;</span><br><span class="line">            return 401;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class ServerErrorException extends OAuth2Exception &#123;</span><br><span class="line">        public ServerErrorException(String msg, Throwable t) &#123;</span><br><span class="line">            super(msg, t);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public String getOAuth2ErrorCode() &#123;</span><br><span class="line">            return &quot;server_error&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public int getHttpErrorCode() &#123;</span><br><span class="line">            return 500;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class ForbiddenException extends OAuth2Exception &#123;</span><br><span class="line">        public ForbiddenException(String msg, Throwable t) &#123;</span><br><span class="line">            super(msg, t);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public String getOAuth2ErrorCode() &#123;</span><br><span class="line">            return &quot;access_denied&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public int getHttpErrorCode() &#123;</span><br><span class="line">            return 403;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;前面是对认证服务进行配置的详解，接下来，我们看看对于资源服务的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.damon.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;</span><br><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *</span><br><span class="line"> * 资源服务器配置</span><br><span class="line"> * @author Damon</span><br><span class="line"> * @date 2020年1月13日 下午3:03:48</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">@EnableResourceServer</span><br><span class="line">public class ResourceServerConfig extends ResourceServerConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">    public void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.csrf().disable()</span><br><span class="line"></span><br><span class="line">                .exceptionHandling()</span><br><span class="line">        .authenticationEntryPoint(new AuthenticationEntryPointHandle())</span><br><span class="line">        &#x2F;&#x2F;.authenticationEntryPoint((request, response, authException) -&gt; response.sendError(HttpServletResponse.SC_UNAUTHORIZED))</span><br><span class="line">        .and()</span><br><span class="line"></span><br><span class="line">                .requestMatchers().antMatchers(&quot;&#x2F;api&#x2F;**&quot;)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(&quot;&#x2F;api&#x2F;**&quot;).authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .httpBasic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里也配置了对于资源拦截的统一处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.damon.config;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">import org.springframework.http.HttpStatus;</span><br><span class="line">import org.springframework.security.core.AuthenticationException;</span><br><span class="line">import org.springframework.security.web.AuthenticationEntryPoint;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.damon.commons.Response;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *</span><br><span class="line"> * 统一结果处理</span><br><span class="line"> *</span><br><span class="line"> * @author Damon</span><br><span class="line"> * @date 2020年1月16日 上午11:11:44</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">public class AuthenticationEntryPointHandle implements AuthenticationEntryPoint &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line"> *</span><br><span class="line"> * @author Damon</span><br><span class="line"> * @date 2020年1月16日</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public void commence(HttpServletRequest request, HttpServletResponse response,</span><br><span class="line">AuthenticationException authException) throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;response.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">&#x2F;&#x2F;response.setStatus(HttpStatus.OK.value());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);  &#x2F;&#x2F;gateway已加，无需再加</span><br><span class="line">        &#x2F;&#x2F;response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;token&quot;);</span><br><span class="line">        &#x2F;&#x2F;解决低危漏洞点击劫持 X-Frame-Options Header未配置</span><br><span class="line">        response.setHeader(&quot;X-Frame-Options&quot;, &quot;SAMEORIGIN&quot;);</span><br><span class="line">        response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        response.setContentType(&quot;application&#x2F;json; charset&#x3D;utf-8&quot;);</span><br><span class="line"></span><br><span class="line">response.getWriter()</span><br><span class="line">.write(JSON.toJSONString(Response.ok(response.getStatus(), -2, authException.getMessage(), null)));</span><br><span class="line">&#x2F;*response.getWriter()</span><br><span class="line">.write(JSON.toJSONString(Response.ok(200, -2, &quot;Internal Server Error&quot;, authException.getMessage())));*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以上就是认证中心的核心代码了，这里有一些需要注意的地方：有2个拦截器，鉴权服务配置、资源权限配置，鉴权时可以通过几种模式来进行。授权码模式交互比较多，密码模式比较常见应用。</p><p>&emsp;&emsp;接下来，我们新建一个电商系统的订单服务，作为鉴权的客户端，我们来看看代码。</p><h5 id="订单服务客户端"><a href="#订单服务客户端" class="headerlink" title="订单服务客户端"></a>订单服务客户端</h5><p>&emsp;&emsp;订单系统我们考虑到系统的高可用，以及系统的TPS，我们采用负载均衡手段，加上一些中间件来处理，使得服务更加具有代表性。</p><p>&emsp;&emsp;订单系统的环境这就不介绍了，这里主要还是看依赖K8s的组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-actuator-autoconfigure&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-kubernetes-config&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- springcloud-k8s-discovery --&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-commons&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-kubernetes-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-kubernetes-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-kubernetes-ribbon&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的依赖是K8s对于Java的sdk-client，接下来配置一些环境使其生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: order-service</span><br><span class="line">  #redis: #redis相关配置</span><br><span class="line">    #password: 123456 #有密码时设置</span><br><span class="line">  cloud:</span><br><span class="line">    kubernetes:</span><br><span class="line">      config:</span><br><span class="line">        sources:</span><br><span class="line">         - name: $&#123;spring.application.name&#125;</span><br><span class="line">           namespace: system-server</span><br><span class="line">      discovery:</span><br><span class="line">        all-namespaces: true</span><br><span class="line">      reload:</span><br><span class="line">        #自动更新配置的开关设置为打开</span><br><span class="line">        enabled: true</span><br><span class="line">        #更新配置信息的模式：polling是主动拉取，event是事件通知</span><br><span class="line">        mode: polling</span><br><span class="line">        #主动拉取的间隔时间是500毫秒</span><br><span class="line">        period: 500</span><br><span class="line">  http:</span><br><span class="line">    encoding:</span><br><span class="line">      charset: UTF-8</span><br><span class="line">      enabled: true</span><br><span class="line">      force: true</span><br><span class="line">  mvc:</span><br><span class="line">    throw-exception-if-no-handler-found: true</span><br><span class="line">  main:</span><br><span class="line">    allow-bean-definition-overriding: true # 当遇到同样名称时，是否允许覆盖注册</span><br><span class="line"></span><br><span class="line">logging:</span><br><span class="line">  path: &#x2F;data&#x2F;$&#123;spring.application.name&#125;&#x2F;logs</span><br><span class="line"></span><br><span class="line">cas-server-url: http:&#x2F;&#x2F;cas-server-service #http:&#x2F;&#x2F;localhost:2000#设置可以访问的地址</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  oauth2: #与cas-server对应的配置</span><br><span class="line">    client:</span><br><span class="line">      client-id: order-service</span><br><span class="line">      client-secret: order-service-123</span><br><span class="line">      user-authorization-uri: $&#123;cas-server-url&#125;&#x2F;oauth&#x2F;authorize #是授权码认证方式需要的</span><br><span class="line">      access-token-uri: $&#123;cas-server-url&#125;&#x2F;oauth&#x2F;token #是密码模式需要用到的获取 token 的接口</span><br><span class="line">    resource:</span><br><span class="line">      loadBalanced: true</span><br><span class="line">      #jwt: #jwt存储token时开启</span><br><span class="line">        #key-uri: $&#123;cas-server-url&#125;&#x2F;oauth&#x2F;token_key</span><br><span class="line">        #key-value: test_jwt_sign_key</span><br><span class="line">      id: order-service</span><br><span class="line">      #指定用户信息地址</span><br><span class="line">      user-info-uri: $&#123;cas-server-url&#125;&#x2F;api&#x2F;user #指定user info的URI，原生地址后缀为&#x2F;auth&#x2F;user</span><br><span class="line">      prefer-token-info: false</span><br><span class="line">      #token-info-uri:</span><br><span class="line">    authorization:</span><br><span class="line">      check-token-access: $&#123;cas-server-url&#125;&#x2F;oauth&#x2F;check_token #当此web服务端接收到来自UI客户端的请求后，需要拿着请求中的 token 到认证服务端做 token 验证，就是请求的这个接口</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最上面是配置了加载服务的环境变量，采用K8s的ConfigMap实现，不再使用复杂的各种大厂提供的插件。下面是订单服务接入鉴权时需要的鉴权配置。这里为了鉴权的健壮性，采用了分布式部署：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cas-server-url: http:&#x2F;&#x2F;cas-server-service</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过K8s的Service来进行及安全认证，实现服务的高可用。接下来是订单服务的各种模式的支持，这里主要是授权码模式、密码模式。同时，开启了订单服务的负载均衡策略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.damon;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.SpringBootConfiguration;</span><br><span class="line">import org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line">import org.springframework.boot.autoconfigure.security.oauth2.client.EnableOAuth2Sso;</span><br><span class="line">import org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line">import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;</span><br><span class="line">import org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line">import org.springframework.cloud.netflix.hystrix.EnableHystrix;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">import com.damon.config.EnvConfig;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author Damon</span><br><span class="line"> * @date 2020年1月13日 下午3:23:06</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">@EnableOAuth2Sso</span><br><span class="line">@Configuration&#x2F;&#x2F;@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(basePackages &#x3D; &#123;&quot;com.damon&quot;&#125;)</span><br><span class="line">@EnableConfigurationProperties(EnvConfig.class)</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableCircuitBreaker&#x2F;&#x2F;@EnableHystrix</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@RibbonClients针对多个服务源进行策略的指定 ,这里注意这种方式时，RibbonConfiguration类不能被包含在@ComponentScan的扫描包中</span><br><span class="line">&#x2F;*@RibbonClients(value &#x3D; &#123;</span><br><span class="line">@RibbonClient(name&#x3D;&quot;cas-server-service&quot;, configuration &#x3D; RibbonConfiguration.class),</span><br><span class="line">@RibbonClient(name&#x3D;&quot;admin-web-service&quot;, configuration &#x3D; RibbonConfiguration.class)</span><br><span class="line">&#125;)*&#x2F;</span><br><span class="line">public class OrderApp &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(OrderApp.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来，我们看下客户端的资源配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.damon.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;</span><br><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * @author Damon</span><br><span class="line"> * @date 2020年1月16日 下午6:28:35</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">@EnableResourceServer</span><br><span class="line">public class ResourceServerConfig extends ResourceServerConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.csrf().disable()</span><br><span class="line"></span><br><span class="line">                .exceptionHandling()</span><br><span class="line">        .authenticationEntryPoint(new AuthenticationEntryPointHandle())</span><br><span class="line">        &#x2F;&#x2F;.authenticationEntryPoint((request, response, authException) -&gt; response.sendError(HttpServletResponse.SC_UNAUTHORIZED))</span><br><span class="line">        .and()</span><br><span class="line"></span><br><span class="line">                .requestMatchers().antMatchers(&quot;&#x2F;api&#x2F;**&quot;)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(&quot;&#x2F;api&#x2F;**&quot;).authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .httpBasic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里加了一个统一结果处理类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">package com.damon.config;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">import org.springframework.security.core.AuthenticationException;</span><br><span class="line">import org.springframework.security.web.AuthenticationEntryPoint;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.damon.commons.Response;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *</span><br><span class="line"> * 统一结果处理</span><br><span class="line"> *</span><br><span class="line"> * @author Damon</span><br><span class="line"> * @date 2020年1月16日 上午11:11:44</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">public class AuthenticationEntryPointHandle implements AuthenticationEntryPoint &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line"> *</span><br><span class="line"> * @author Damon</span><br><span class="line"> * @date 2020年1月16日</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public void commence(HttpServletRequest request, HttpServletResponse response,</span><br><span class="line">AuthenticationException authException) throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;response.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">&#x2F;&#x2F;response.setStatus(HttpStatus.OK.value());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);  &#x2F;&#x2F;gateway已加，无需再加</span><br><span class="line">        &#x2F;&#x2F;response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;token&quot;);</span><br><span class="line">        &#x2F;&#x2F;解决低危漏洞点击劫持 X-Frame-Options Header未配置</span><br><span class="line">        response.setHeader(&quot;X-Frame-Options&quot;, &quot;SAMEORIGIN&quot;);</span><br><span class="line">        response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        response.setContentType(&quot;application&#x2F;json; charset&#x3D;utf-8&quot;);</span><br><span class="line"></span><br><span class="line">response.getWriter()</span><br><span class="line">.write(JSON.toJSONString(Response.ok(response.getStatus(), -2, authException.getMessage(), null)));</span><br><span class="line">&#x2F;*response.getWriter()</span><br><span class="line">.write(JSON.toJSONString(Response.ok(200, -2, &quot;Internal Server Error&quot;, authException.getMessage())));*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*@Override</span><br><span class="line">    public void commence(HttpServletRequest request,</span><br><span class="line">                         HttpServletResponse response,</span><br><span class="line">AuthenticationException authException) throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">response.setContentType(&quot;application&#x2F;json; charset&#x3D;utf-8&quot;);</span><br><span class="line">response.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">response.getWriter()</span><br><span class="line">.write(JSON.toJSONString(Response.ok(200, -2, &quot;Internal Server Error&quot;, authException.getMessage())));</span><br><span class="line">&#125;*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;前面说增加了负载均衡策略，此处我们引入的是Ribbon作为负载均衡器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 2003</span><br><span class="line">  undertow:</span><br><span class="line">    accesslog:</span><br><span class="line">      enabled: false</span><br><span class="line">      pattern: combined</span><br><span class="line">  servlet:</span><br><span class="line">    session:</span><br><span class="line">      timeout: PT120M</span><br><span class="line">      cookie:</span><br><span class="line">        name: ORDER-SERVICE-SESSIONID #防止Cookie冲突，冲突会导致登录验证不通过</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client:</span><br><span class="line">  http:</span><br><span class="line">    request:</span><br><span class="line">      connectTimeout: 8000</span><br><span class="line">      readTimeout: 30000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">backend:</span><br><span class="line">  ribbon:</span><br><span class="line">    eureka:</span><br><span class="line">      enabled: false</span><br><span class="line">    client:</span><br><span class="line">      enabled: true</span><br><span class="line">    ServerListRefreshInterval: 5000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ribbon:</span><br><span class="line">  ConnectTimeout: 2000</span><br><span class="line">  ReadTimeout: 3000</span><br><span class="line">  eager-load:</span><br><span class="line">    enabled: true</span><br><span class="line">    clients: cas-server-service,admin-web-service</span><br><span class="line">  MaxAutoRetries: 1 #对第一次请求的服务的重试次数</span><br><span class="line">  MaxAutoRetriesNextServer: 1 #要重试的下一个服务的最大数量（不包括第一个服务）</span><br><span class="line">  #listOfServers: localhost:5556,localhost:5557</span><br><span class="line">  #ServerListRefreshInterval: 2000</span><br><span class="line">  OkToRetryOnAllOperations: true</span><br><span class="line">  NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule #com.damon.config.RibbonConfiguration #自定义策略类</span><br><span class="line"></span><br><span class="line">hystrix:</span><br><span class="line">  command:</span><br><span class="line">    BackendCall: #default or commandKey的值</span><br><span class="line">      execution:</span><br><span class="line">        isolation:</span><br><span class="line">          thread:</span><br><span class="line">            timeoutInMilliseconds: 5000</span><br><span class="line">  threadpool:</span><br><span class="line">    BackendCallThread:</span><br><span class="line">      coreSize: 5</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同时，这里采用的是默认的轮训策略，当然可以自定义一种策略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package com.damon.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line">import com.netflix.client.config.IClientConfig;</span><br><span class="line">import com.netflix.loadbalancer.IPing;</span><br><span class="line">import com.netflix.loadbalancer.IRule;</span><br><span class="line">import com.netflix.loadbalancer.PingUrl;</span><br><span class="line">import com.netflix.loadbalancer.RoundRobinRule;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author Damon</span><br><span class="line"> * @date 2019年10月30日 下午5:03:54</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">public class RibbonConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 检查服务是否可用的实例，</span><br><span class="line">     * 此地址返回的响应的返回码如果是200表示服务可用</span><br><span class="line">     * @param config</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    public IPing ribbonPing(IClientConfig config)&#123;</span><br><span class="line">        return new PingUrl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 轮询规则</span><br><span class="line">     * @param config</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    public IRule ribbonRule(IClientConfig config)&#123;</span><br><span class="line">&#x2F;&#x2F;return new AvailabilityFilteringRule();</span><br><span class="line">        return new RoundRobinRule();&#x2F;&#x2F;轮询</span><br><span class="line">        &#x2F;&#x2F;return new RetryRule();&#x2F;&#x2F;重试</span><br><span class="line">&#x2F;&#x2F;return new RandomRule();&#x2F;&#x2F;这里配置策略，和配置文件对应</span><br><span class="line">&#x2F;&#x2F;return new WeightedResponseTimeRule();&#x2F;&#x2F;这里配置策略，和配置文件对应</span><br><span class="line">        &#x2F;&#x2F;return new BestAvailableRule();&#x2F;&#x2F;选择一个最小的并发请求的server</span><br><span class="line">        &#x2F;&#x2F;return new MyProbabilityRandomRule();&#x2F;&#x2F;自定义</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上面的策略函数<strong>ribbonRule</strong>中，实现自定义策略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package com.damon.config;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import com.netflix.loadbalancer.BaseLoadBalancer;</span><br><span class="line">import com.netflix.loadbalancer.ILoadBalancer;</span><br><span class="line">import com.netflix.loadbalancer.IRule;</span><br><span class="line">import com.netflix.loadbalancer.Server;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 实现自定义负载均衡策略</span><br><span class="line"> * @author Damon</span><br><span class="line"> * @date 2019年10月30日 上午9:08:49</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">public class MyProbabilityRandomRule implements IRule &#123;</span><br><span class="line"></span><br><span class="line">Logger log &#x3D; LoggerFactory.getLogger(MyProbabilityRandomRule.class);</span><br><span class="line"></span><br><span class="line">ILoadBalancer balancer &#x3D; new BaseLoadBalancer();</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Server choose(Object key) &#123;</span><br><span class="line">List&lt;Server&gt; allServers &#x3D; balancer.getAllServers();</span><br><span class="line">Random random &#x3D; new Random();</span><br><span class="line">final int number &#x3D; random.nextInt(10);</span><br><span class="line">if (number &lt; 7) &#123;</span><br><span class="line">return findServer(allServers,8091);</span><br><span class="line">&#125;</span><br><span class="line">return findServer(allServers,8092);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Server findServer(List&lt;Server&gt; allServers, int port) &#123;</span><br><span class="line">for (Server server : allServers) &#123;</span><br><span class="line">if (server.getPort() &#x3D;&#x3D; port) &#123;</span><br><span class="line">return server;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">log.info(&quot;NULL port&#x3D;&quot;+port);</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setLoadBalancer(ILoadBalancer lb) &#123;</span><br><span class="line">this.balancer &#x3D; lb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public ILoadBalancer getLoadBalancer() &#123;</span><br><span class="line">return this.balancer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;到此，关于客户端的配置全部解决完了，接下来简单写一个API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;getCurrentOrderUser&quot;)</span><br><span class="line">@PreAuthorize(&quot;hasAuthority(&#39;admin&#39;)&quot;)</span><br><span class="line">public Object getCurrentOrderUser(Authentication authentication) &#123;</span><br><span class="line">logger.info(&quot;test password&quot;);</span><br><span class="line">return authentication;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;@PreAuthorize(&quot;hasAuthority(&#39;admin&#39;)&quot;)</span><br><span class="line">@PreAuthorize(&quot;hasAuthority(&#39;admin1&#39;)&quot;)</span><br><span class="line">@GetMapping(&quot;&#x2F;auth&#x2F;admin&quot;)</span><br><span class="line">public Object adminAuth() &#123;</span><br><span class="line">logger.info(&quot;aAaqsqwsw&quot;);</span><br><span class="line">return &quot;Has admin auth!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们简单的实现了一个客户端的代码，以及鉴权认证。</p><h5 id="基于Java阐述K8s的服务发现"><a href="#基于Java阐述K8s的服务发现" class="headerlink" title="基于Java阐述K8s的服务发现"></a>基于Java阐述K8s的服务发现</h5><p>&emsp;&emsp;前面从K8s组件以及资源的角度，来分析了K8s的服务注册与发现的缘由。接下来，我们看看基于Java，K8s如何提供该项功能。</p><p>&emsp;&emsp;在pom.xml中，有对spring-cloud-kubernetes框架的依赖配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-cloud-kubernetes-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>我们看下这个依赖的源码：</p><p><img src="https://static001.geekbang.org/infoq/36/3695035fe29b6bca5a1215a52633e8f8.png" alt=""></p><p>&emsp;&emsp;spring容器启动时，会找到classpath下的spring.factories文件，spring.factories文件中有两个类：KubernetesDiscoveryClientAutoConfiguration和KubernetesDiscoveryClientConfigClientBootstrapConfiguration都会被实例化；</p><p>&emsp;&emsp;再看KubernetesDiscoveryClientAutoConfiguration源码，注意<strong>kubernetesDiscoveryClient</strong>方法，这里面实例化了DiscoveryController所需的DiscoveryClient接口实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@ConditionalOnMissingBean</span><br><span class="line">@ConditionalOnProperty(name &#x3D; &quot;spring.cloud.kubernetes.discovery.enabled&quot;, matchIfMissing &#x3D; true)</span><br><span class="line">public KubernetesDiscoveryClient kubernetesDiscoveryClient(KubernetesClient client,</span><br><span class="line">KubernetesDiscoveryProperties properties,</span><br><span class="line">KubernetesClientServicesFunction kubernetesClientServicesFunction,</span><br><span class="line">DefaultIsServicePortSecureResolver isServicePortSecureResolver) &#123;</span><br><span class="line">  return new KubernetesDiscoveryClient(client, properties,</span><br><span class="line">                                       kubernetesClientServicesFunction, isServicePortSecureResolver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其实最终是向kubernetes的API Server发起http请求，获取service资源的数据列表；在K8s的API Server收到请求后，<strong>由API Server从etcd中取得service的数据返回</strong>。</p><p><img src="https://static001.geekbang.org/infoq/25/2574415575c013a810fa2bbb0ac04720.png" alt=""></p><p>&emsp;&emsp;可见 spring-cloud-kubernetes 的 DiscoveryClient 服务将 kubernetes 中的”service”资源与 SpringCloud 中的服务对应起来了，有了这个 DiscoveryClient，我们在 kubernetes 环境就不需要 eureka 来做注册发现了，而是直接使用 kubernetes 的服务机制，此时不得不感慨 SpringCloud 的对 DiscoveryClient 的设计是如此的精妙。</p><h6 id="7-2-手写第一个Golang微服务"><a href="#7-2-手写第一个Golang微服务" class="headerlink" title="7.2 手写第一个Golang微服务"></a>7.2 手写第一个Golang微服务</h6><p>&emsp;&emsp;现在有不少的Golang框架：Beego、Gin等，今天为了简单起见，我们直接使用Beego。</p><h6 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h6><ul><li>GoLand 2020.3.2</li><li>Golang 1.12+</li></ul><p>第一个Golang的main函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;github.com&#x2F;astaxie&#x2F;beego&quot;</span><br><span class="line">&quot;github.com&#x2F;astaxie&#x2F;beego&#x2F;logs&quot;</span><br><span class="line">&quot;github.com&#x2F;spf13&#x2F;pflag&quot;</span><br><span class="line">_ &quot;pay-service&#x2F;routers&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">logs.SetLogFuncCall(true)</span><br><span class="line">logs.SetLogFuncCallDepth(3)</span><br><span class="line">logs.SetLogger(logs.AdapterFile, &#96;&#123;&quot;filename&quot;:&quot;&#x2F;data&#x2F;pay-service&#x2F;log&#x2F;pay-service.log&quot;,&quot;level&quot;:7,&quot;daily&quot;:true,&quot;maxdays&quot;:7,&quot;color&quot;:true&#125;&#96;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var logFlushFreq &#x3D; pflag.Duration(&quot;log-flush-frequency&quot;, 5*time.Second, &quot;Maximum number of seconds between log flushes&quot;)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F;先在先执行，后者不再执行</span><br><span class="line"></span><br><span class="line">&#x2F;*http.HandleFunc(&quot;&#x2F;health&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">fmt.Fprintf(w, fmt.Sprintf(&quot;%v&quot;, true))</span><br><span class="line">&#125;)</span><br><span class="line">http.ListenAndServe(&quot;:38080&quot;, nil)*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">beego.Run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;cache health</span><br><span class="line">&#x2F;&#x2F;var configFile &#x3D; flag.String(&quot;config&quot;, &quot;conf&#x2F;config-dev.yaml&quot;, &quot;the config file of pay service&quot;)</span><br><span class="line">&#x2F;*flag.Parse()</span><br><span class="line"></span><br><span class="line">go wait.Until(glog.Flush, *logFlushFreq, wait.NeverStop)</span><br><span class="line">defer glog.Flush()</span><br><span class="line"></span><br><span class="line">config, err :&#x3D; config.ParseFromYaml(*configFile)</span><br><span class="line">if config.ProcessNum &gt; 0 &#123;</span><br><span class="line">runtime.GOMAXPROCS(config.ProcessNum)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class="line">&#125;</span><br><span class="line">runtime.NumCPU()</span><br><span class="line"></span><br><span class="line">cache :&#x3D; cache.New(&amp;cache.Config&#123;&#125;)</span><br><span class="line">done :&#x3D; make(chan struct&#123;&#125;)</span><br><span class="line">cache.Run(done)</span><br><span class="line">&lt;-done*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里启动时，很简单，就是beego的线程启动，当然，如果你需要添加一些其他的，可以在<strong>init</strong>函数中添加逻辑。</p><p>&emsp;&emsp;接下来，我们新建一个routers目录，新建router文件来设置路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; @APIVersion V1.0.0</span><br><span class="line">&#x2F;&#x2F; @Title 支付服务 API</span><br><span class="line">&#x2F;&#x2F; @Description 提供支付服务相关的API集合.</span><br><span class="line">package routers</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;github.com&#x2F;astaxie&#x2F;beego&quot;</span><br><span class="line">&quot;pay-service&#x2F;api&quot;</span><br><span class="line">&quot;common-core&#x2F;common&#x2F;check&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">ns :&#x3D; beego.NewNamespace(&quot;&#x2F;api&#x2F;v1&quot;,</span><br><span class="line">beego.NSRouter(&quot;&#x2F;healthz&quot;, &amp;api.ProbeHealthAPI&#123;&#125;),</span><br><span class="line">beego.NSRouter(&quot;&#x2F;pay&#x2F;:orderId&quot;, &amp;api.PayDetailAPI&#123;&#125;),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">beego.InsertFilter(&quot;&#x2F;api&#x2F;v1&#x2F;*&quot;, beego.BeforeRouter, check.CheckAuth)</span><br><span class="line">beego.AddNamespace(ns)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的路由包括两个接口，一个是服务自身的健康检测healthz，还有一个基于订单号查询支付服务信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package api</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">base_api &quot;common-core&#x2F;common&#x2F;api&quot;</span><br><span class="line">&quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">type PayDetailAPI struct &#123;</span><br><span class="line">base_api.BaseAPI</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (pd *PayDetailAPI) Get() &#123;</span><br><span class="line">orderId :&#x3D; strings.TrimSpace(pd.GetString(&quot;:orderId&quot;))</span><br><span class="line">pd.RespSucc(&quot;success: &quot; + orderId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里由于API需要集成Beego的控制类，所以新建一个common目录，提供基础功能，包括api：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package api</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;common-core&#x2F;common&#x2F;handler&quot;</span><br><span class="line">&quot;common-core&#x2F;common&#x2F;res&quot;</span><br><span class="line">&quot;encoding&#x2F;json&quot;</span><br><span class="line">&quot;github.com&#x2F;astaxie&#x2F;beego&quot;</span><br><span class="line">&quot;github.com&#x2F;astaxie&#x2F;beego&#x2F;logs&quot;</span><br><span class="line">&quot;io&#x2F;ioutil&quot;</span><br><span class="line">&quot;net&#x2F;http&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">type BaseAPI struct &#123;</span><br><span class="line">beego.Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (ba *BaseAPI) GetBody(body interface&#123;&#125;) error &#123;</span><br><span class="line">bodyByte, err :&#x3D; ioutil.ReadAll(ba.Ctx.Request.Body)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">logs.Error(err.Error())</span><br><span class="line">return handler.NewBadReqError(handler.ComErrorCodeInvalidPara, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if err :&#x3D; json.Unmarshal(bodyByte, body); err !&#x3D; nil &#123;</span><br><span class="line">return handler.NewBadReqError(handler.ComErrorCodeInvalidPara, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ba *BaseAPI) RespSucc(body interface&#123;&#125;) &#123;</span><br><span class="line">ba.Resp(http.StatusOK, (&amp;res.DefaultResponse&#123;&#125;).Succ(body))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ba *BaseAPI) RespError(err error) &#123;</span><br><span class="line">if handler.IsBadRequestError(err) &#123;</span><br><span class="line">ba.Resp(http.StatusBadRequest, (&amp;res.DefaultResponse&#123;&#125;).Fail(err))</span><br><span class="line">&#125; else &#123;</span><br><span class="line">ba.Resp(http.StatusInternalServerError, (&amp;res.DefaultResponse&#123;&#125;).Fail(err))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ba *BaseAPI) RespSuccError(err error) &#123;</span><br><span class="line">if handler.IsBadRequestError(err) &#123;</span><br><span class="line">ba.Resp(http.StatusOK, (&amp;res.DefaultResponse&#123;&#125;).Fail(err))</span><br><span class="line">&#125; else &#123;</span><br><span class="line">ba.Resp(http.StatusOK, (&amp;res.DefaultResponse&#123;&#125;).Fail(err))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ba *BaseAPI) Resp(httpStatus int, res res.Response) &#123;</span><br><span class="line">ba.Data[&quot;json&quot;] &#x3D; res</span><br><span class="line">ba.Ctx.Output.SetStatus(httpStatus)</span><br><span class="line">ba.ServeJSON()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同时，提供了一些异常处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">package handler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">&#x2F;&#x2F;公共错误码 0-100</span><br><span class="line">ComErrorCodeSuccess     &#x3D; 0</span><br><span class="line">ComErrorCodeNoVistAuth  &#x3D; 1</span><br><span class="line">ComErrorCodeInvalidPara &#x3D; 2</span><br><span class="line">ComErrorCodeUnknown &#x3D; 3</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">badRequestType &#x3D; &quot;[bad request]&quot;</span><br><span class="line">innerErrorType &#x3D; &quot;[inner error]&quot;</span><br><span class="line">successType    &#x3D; &quot;[success]&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type ExceptionHandler struct &#123;</span><br><span class="line">Code      int    &#96;json:&quot;code&quot;&#96;</span><br><span class="line">ErrorType string &#96;json:&quot;-&quot;&#96;</span><br><span class="line">Msg       string &#96;json:&quot;msg&quot;&#96;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ec ExceptionHandler) Error() string &#123;</span><br><span class="line">return ec.Msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewBadReqError(code int, format string, paras ...interface&#123;&#125;) error &#123;</span><br><span class="line">return newError(code, badRequestType, format, paras...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewInnerError(code int, format string, paras ...interface&#123;&#125;) error &#123;</span><br><span class="line">return newError(code, innerErrorType, format, paras...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewSuccess(format string, paras ...interface&#123;&#125;) error &#123;</span><br><span class="line">return newError(ComErrorCodeSuccess, successType, format, paras...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewUnkownError(format string, paras ...interface&#123;&#125;) error &#123;</span><br><span class="line">return newError(ComErrorCodeUnknown, innerErrorType, format, paras...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func IsInnerError(err error) bool &#123;</span><br><span class="line">if errCustom, ok :&#x3D; err.(ExceptionHandler); ok &#123;</span><br><span class="line">return errCustom.ErrorType &#x3D;&#x3D; innerErrorType</span><br><span class="line">&#125;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func IsBadRequestError(err error) bool &#123;</span><br><span class="line">if errCustom, ok :&#x3D; err.(ExceptionHandler); ok &#123;</span><br><span class="line">return errCustom.ErrorType &#x3D;&#x3D; badRequestType</span><br><span class="line">&#125;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func IsSuccess(err error) bool &#123;</span><br><span class="line">if err &#x3D;&#x3D; nil &#123;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if errCustom, ok :&#x3D; err.(*ExceptionHandler); ok &#123;</span><br><span class="line">return errCustom.ErrorType &#x3D;&#x3D; successType</span><br><span class="line">&#125;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewError(code int, format string, paras ...interface&#123;&#125;) *ExceptionHandler &#123;</span><br><span class="line">return &amp;ExceptionHandler&#123;Code: code, Msg: fmt.Sprintf(format, paras...)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func newError(code int, errorType string, format string, paras ...interface&#123;&#125;) error &#123;</span><br><span class="line">return &amp;ExceptionHandler&#123;Code: code, ErrorType: errorType, Msg: fmt.Sprintf(format, paras...)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;返回响应体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package res</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&#x2F;&#x2F; http client driver</span><br><span class="line">&quot;github.com&#x2F;astaxie&#x2F;beego&#x2F;logs&quot;</span><br><span class="line">&quot;common-core&#x2F;common&#x2F;handler&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Response interface &#123;</span><br><span class="line">Succ(body interface&#123;&#125;) Response</span><br><span class="line">Fail(err error) Response</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type DefaultResponse struct &#123;</span><br><span class="line">Status handler.ExceptionHandler &#96;json:&quot;status&quot;&#96;</span><br><span class="line">Data   interface&#123;&#125;             &#96;json:&quot;data&quot;&#96;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (dr *DefaultResponse) Succ(body interface&#123;&#125;) Response &#123;</span><br><span class="line">success, _ :&#x3D; handler.NewSuccess(&quot;success&quot;).(*handler.ExceptionHandler)</span><br><span class="line">dr.Status &#x3D; *success</span><br><span class="line">dr.Data &#x3D; body</span><br><span class="line">return dr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (dr *DefaultResponse) Fail(err error) Response &#123;</span><br><span class="line">errCustom, ok :&#x3D; err.(*handler.ExceptionHandler)</span><br><span class="line">if !ok &#123;</span><br><span class="line">logs.Error(&quot;error type invalid, please use custom error&quot;)</span><br><span class="line">unkownError, _ :&#x3D; handler.NewUnkownError(err.Error()).(*handler.ExceptionHandler)</span><br><span class="line">dr.Status &#x3D; *unkownError</span><br><span class="line">&#125; else &#123;</span><br><span class="line">dr.Status &#x3D; *errCustom</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return dr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;到此，一个简单的微服务就写完了，如果需要借助一些缓存，或插件来实现一些功能，可以自行添加。</p><p>启动微服务，可以运行<strong>main</strong>函数，输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021&#x2F;04&#x2F;13 16:51:38.785 [I] [app.go:214]  http server Running on http:&#x2F;&#x2F;:8080</span><br></pre></td></tr></table></figure><p>通过在浏览器输入请求地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;api&#x2F;v1&#x2F;healthz</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;api&#x2F;v1&#x2F;pay&#x2F;232</span><br></pre></td></tr></table></figure><p>如果增加鉴权认证，则会返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;status&quot;:&#123;&quot;code&quot;:1,&quot;msg&quot;:&quot;no token&quot;&#125;,&quot;data&quot;:null&#125;</span><br></pre></td></tr></table></figure><h6 id="7-3-部署微服务应用-1"><a href="#7-3-部署微服务应用-1" class="headerlink" title="7.3 部署微服务应用"></a>7.3 部署微服务应用</h6><h6 id="部署服务"><a href="#部署服务" class="headerlink" title="部署服务"></a>部署服务</h6><p>&emsp;&emsp;这里引入了部署框架，具体内容将在后续公开，现在先来看看如何部署cas-server：</p><h6 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h6><ul><li><p>git clone <a href="https://gitee.com/damon_one/microservice-k8s.git" target="_blank" rel="noopener">https://gitee.com/damon_one/microservice-k8s.git</a></p></li><li><p>kubectl create namespace system-server</p></li><li><p>在microservice-k8s目录下</p></li></ul><ol><li><p>sh install_requirement.sh</p></li><li><p>cd build</p></li><li><p>修改对应的配置</p></li></ol><ul><li>vi ../deployment/quick-start/quick-start-AIO-example.yaml</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">default:</span><br><span class="line">  cluster_id: singlebox</span><br><span class="line">  gpu_version: 440.31</span><br><span class="line">  mysql_password: ssswsw</span><br><span class="line">cluster_server:</span><br><span class="line">  default:</span><br><span class="line">    ssh-username: damon #机器用户名</span><br><span class="line">    ssh-password: wwwww #机器密码</span><br><span class="line">    gpu:</span><br><span class="line">      type: debug</span><br><span class="line">      count: 2</span><br><span class="line">    cpu: 24</span><br><span class="line">    mem: 187</span><br><span class="line">  master:</span><br><span class="line">  - ip: 10.12.3.17</span><br><span class="line">    hostname: damon</span><br><span class="line">    username: damon</span><br><span class="line">    passworld: wwwww</span><br><span class="line">    gpu:</span><br><span class="line">    # required if</span><br><span class="line">      type: debug</span><br><span class="line">      count: 2</span><br><span class="line">#  compute:</span><br><span class="line">#  - ip: &lt;compute node ip&gt;</span><br><span class="line">#    hostname: &lt;compute node hostname&gt;</span><br><span class="line">#    gpu:</span><br><span class="line">#    # the type and count must be configured at same time</span><br><span class="line">#     type: &lt;gpu type that is different from default&gt;</span><br><span class="line">#      count: &lt;gpu type that is different from default&gt;</span><br><span class="line"></span><br><span class="line">registry_info:</span><br><span class="line">  # the registry address of docker,format [ip:port] eg. 10.10.8.100:5000</span><br><span class="line">  domain: 10.10.8.100:5000</span><br><span class="line">  # the registry&#39;s username</span><br><span class="line">  username: admin</span><br><span class="line">  # the registry&#39;s password</span><br><span class="line">  password: wdwwdwwdw</span><br><span class="line">  # the namespace of kubeletes</span><br><span class="line">  k8s_namespace: singlebox_google_containers</span><br><span class="line">  # the namespace of services</span><br><span class="line">  leinao_namespace: hub</span><br></pre></td></tr></table></figure><ol start="4"><li>sudo python ../controller.py config generate -i /home/damon/microservice-k8s/deployment/quick-start/quick-start-AIO-example.yaml -o /home/damon/deployment/output_config</li></ol><ul><li>按照config部署k8s(可不操作，默认已经部署k8s)</li></ul><ol><li><p>sudo python ../controller.py cluster k8s-clean -p /home/damon/deployment/output_config</p></li><li><p>sudo python ../controller.py cluster k8s-bootup -p /home/damon/deployment/output_config</p></li></ol><ul><li>把config配置push到远程,k8s重新部署时需要执行:</li></ul><ol><li>sudo python ../controller.py config push -p /home/damon/deployment/output_config<br>one</li></ol><ul><li>编译镜像：</li></ul><ol><li>sudo python pai_build.py build -c /home/damon/deployment/output_config -s cas-server</li><li>sudo python pai_build.py push -c /home/damon/deployment/output_config -i cas-server</li></ol><ul><li>部署服务：one</li></ul><ol><li>sudo python ../controller.py service delete -n cas-server or mysql</li><li>sudo python ../controller.py service start -n cas-server</li></ol><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>部署后，我们可以执行K8s命令查看服务pod：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tom@PK001:~$ kubectl get po -n system-server</span><br><span class="line">NAME                                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">cas-server-deployment-6bdw56dwde-5pdwf   1&#x2F;1     Running   0          3d</span><br><span class="line">gateway-service-deployment-6b7856bc99-5pk56   1&#x2F;1     Running   0          5d3h</span><br><span class="line">order-service-76f57dbd7c-rpfls                  1&#x2F;1   Running   0          10d</span><br><span class="line">pay-service-68bcc4db8-v42gm                  1&#x2F;1     Running   0          10d</span><br></pre></td></tr></table></figure><p>不同 NS 之间服务的互通：</p><p>kube-system —&gt; system-server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tom@PK001:~&#x2F;damon$ kubectl exec -it order-service-76f57dbd7c-rpfls sh -n kube-system</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># curl http:&#x2F;&#x2F;pay-service-svc.system-server.svc.cluster.local:8090&#x2F;api&#x2F;v1&#x2F;healthz</span><br><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: &#123;</span><br><span class="line">    &quot;code&quot;: 0,</span><br><span class="line">    &quot;msg&quot;: &quot;success&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;data&quot;: &quot;success&quot;</span><br><span class="line">&#125;#</span><br><span class="line">#</span><br><span class="line">#</span><br></pre></td></tr></table></figure><p>system-server —&gt; kube-system</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tom@PK001:~&#x2F;damon$ kubectl exec -it pay-service-768bcc4db8-v42gm sh -n system-server</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># curl http:&#x2F;&#x2F;order-service-svc.kube-system.svc.cluster.local:9300&#x2F;api&#x2F;v1&#x2F;orders</span><br><span class="line">&#123;&quot;status&quot;:&#123;&quot;code&quot;:1,&quot;msg&quot;:&quot;no token&quot;&#125;,&quot;data&quot;:null&#125;#</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line">#</span><br></pre></td></tr></table></figure><p>当出现鉴权认证时，需要获取鉴权令牌Token：</p><h6 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h6><ol><li>获取授权码</li></ol><p>页面打开url：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost:2000&#x2F;oauth&#x2F;authorize?response_type&#x3D;code&amp;client_id&#x3D;order-service&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;order-service&#x2F;login&amp;scope&#x3D;all</span><br></pre></td></tr></table></figure><p>此时，页面被拦截到登录页：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/qnzibd6OnPzZnYURl87eVH8l5xUwJmL79XgdR8ChGFibhOuDhalnq0e5Gwj4Nb4V0BvyCWG0WIxy11MudHsAaDxw/640" alt=""></p><p>在点击 Approve、Authorize 后，输入用户名、密码，跳转到上面的重定向地址，并带有 code 属性参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;order-service&#x2F;login?code&#x3D;nbkiUe</span><br></pre></td></tr></table></figure><ol start="2"><li>根据 code 获取 access_token</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST -d &quot;grant_type&#x3D;authorization_code&amp;code&#x3D;nbkiUe&amp;client_id&#x3D;order-service&amp;client_secret&#x3D;order-service-123&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;order-service&#x2F;login&quot; http:&#x2F;&#x2F;localhost:2000&#x2F;oauth&#x2F;token</span><br></pre></td></tr></table></figure><p>返回信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;access_token&quot;:&quot;a2af3f0b-27da-41b8-90c0-3bd2a1ed0421&quot;,&quot;token_type&quot;:&quot;bearer&quot;,&quot;refresh_token&quot;:&quot;91c22287-aa24-4305-95cf-38f7903865f3&quot;,&quot;expires_in&quot;:3283,&quot;scope&quot;:&quot;all&quot;&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>拿到 token 获取用户信息</li></ol><ul><li>头部携带</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -H &quot;Accept: application&#x2F;json&quot; -H &quot;Authorization:bearer a2af3f0b-27da-41b8-90c0-3bd2a1ed0421&quot; -X GET http:&#x2F;&#x2F;localhost:2003&#x2F;api&#x2F;order&#x2F;getCurrentOrderUser</span><br></pre></td></tr></table></figure><ul><li>直接 get 方式传 token</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;localhost:2003&#x2F;api&#x2F;order&#x2F;getCurrentOrderUser?access_token&#x3D;a2af3f0b-27da-41b8-90c0-3bd2a1ed0421</span><br><span class="line"></span><br><span class="line">curl -i -X POST http:&#x2F;&#x2F;localhost:2003&#x2F;api&#x2F;order&#x2F;***?access_token&#x3D;a2af3f0b-27da-41b8-90c0-3bd2a1ed0421</span><br></pre></td></tr></table></figure><ol start="4"><li>刷新token</li></ol><p>通过上面的 “refresh_token” 来刷新获取新 token:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST -d &quot;grant_type&#x3D;refresh_token&amp;refresh_token&#x3D;91c22287-aa24-4305-95cf-38f7903865f3&amp;client_id&#x3D;provider-service&amp;client_secret&#x3D;provider-service-123&quot; http:&#x2F;&#x2F;localhost:2000&#x2F;oauth&#x2F;token</span><br></pre></td></tr></table></figure><ol start="5"><li>退出</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -H &quot;Accept: application&#x2F;json&quot; -H &quot;Authorization:bearer 01f1beaa-ae21-4920-a349-be786ba327e7&quot; -X DELETE http:&#x2F;&#x2F;localhost:2000&#x2F;api&#x2F;logout</span><br></pre></td></tr></table></figure><h6 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h6><p>密码模式由于都是通过直接调用服务来获取token，所以，咱们可以直接在容器内运行，看看效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">curl -i -X POST -d &quot;username&#x3D;admin&amp;password&#x3D;123456&amp;grant_type&#x3D;password&amp;client_id&#x3D;order-service&amp;client_secret&#x3D;order-service-123&amp;scope&#x3D;all&quot; http:&#x2F;&#x2F;cas-server-service.system-server.svc.cluster.local:2000&#x2F;oauth&#x2F;token</span><br><span class="line">Basic模式认证：</span><br><span class="line">curl -i -X POST -H &quot;Authorization:Basic YWRtaW4td2ViOmFkbWluLXdlYi0xMjM&#x3D;&quot; -H &quot;Content-Type:application&#x2F;x-www-form-urlencoded&quot; -d &quot;username&#x3D;admin&amp;password&#x3D;123456&amp;grant_type&#x3D;password&amp;scope&#x3D;all&quot; http:&#x2F;&#x2F;cas-server-service.system-server.svc.cluster.local:2000&#x2F;oauth&#x2F;token</span><br></pre></td></tr></table></figure><p>认证成功后，会返回如下结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;access_token&quot;:&quot;d2066f68-665b-4038-9dbe-5dd1035e75a0&quot;,&quot;token_type&quot;:&quot;bearer&quot;,&quot;refresh_token&quot;:&quot;44009836-731c-4e6a-9cc3-274ce3af8c6b&quot;,&quot;expires_in&quot;:3599,&quot;scope&quot;:&quot;all&quot;&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们通过 token 来访问接口:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -i -H &quot;Accept: application&#x2F;json&quot; -H &quot;Authorization:bearer 9f7a31d6-8d8e-4ff5-a532-a334e630ebcf&quot; -X GET http:&#x2F;&#x2F;order-service-service.system-server.svc.cluster.local:2003&#x2F;api&#x2F;order&#x2F;auth&#x2F;admin</span><br><span class="line">curl -i -H &quot;Accept: application&#x2F;json&quot; -H &quot;Authorization:bearer cb5e8a95-0071-4c1e-b427-5fa58c0c7737&quot; -X GET http:&#x2F;&#x2F;pay-service-svc.system-server.svc.cluster.local:8090&#x2F;api&#x2F;v1&#x2F;pay&#x2F;wwww</span><br><span class="line">curl -i -H &quot;Accept: application&#x2F;json&quot; -H &quot;Authorization:bearer 9f7a31d6-8d8e-4ff5-a532-a334e630ebcf&quot; -X GET http:&#x2F;&#x2F;admin-web-service.system-server.svc.cluster.local:2001&#x2F;api&#x2F;user&#x2F;services</span><br></pre></td></tr></table></figure><p>成功会返回结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Has admin auth!</span><br></pre></td></tr></table></figure><p>token 如果失效，会返回:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;error&quot;:&quot;invalid_token&quot;,&quot;error_description&quot;:&quot;d2066f68-665b-4038-9dbe-5dd1035e75a01&quot;&#125;</span><br></pre></td></tr></table></figure><p>这里主要通过Service来进行服务访问，实现基于K8s的负载均衡：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tom@PK001:~$ kubectl get svc -n system-server</span><br><span class="line">NAME                             TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)     AGE</span><br><span class="line">gateway-service-service       ClusterIP   20.16.1.5     &lt;none&gt;        5556&#x2F;TCP       74d</span><br><span class="line">pay-service-svc               ClusterIP   20.16.63.79   &lt;none&gt;        8090&#x2F;TCP       10d</span><br><span class="line">admin-web-service             ClusterIP   10.16.129.24    &lt;none&gt;        2001&#x2F;TCP     84d</span><br><span class="line">cas-server-service            ClusterIP   10.16.230.167   &lt;none&gt;        2000&#x2F;TCP     67d</span><br><span class="line">cloud-admin-service-service   ClusterIP   10.16.25.178    &lt;none&gt;        1001&#x2F;TCP     190d</span><br></pre></td></tr></table></figure><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><h4 id="云原生技术与微服务架构的天衣无缝"><a href="#云原生技术与微服务架构的天衣无缝" class="headerlink" title="云原生技术与微服务架构的天衣无缝"></a>云原生技术与微服务架构的天衣无缝</h4><p>&emsp;&emsp;云原生的微服务架构是云原生技术和微服务架构的完美结合。微服务作为一种架构风格，所解决的问题是交纵复杂的软件系统的架构与设计；云原生技术乃一种实现方式，所解决的问题是软件系统的运行、维护和治理。微服务架构可以选择不同的实现方式，如 Java 中的 Dubbo、Spring Cloud、Spring Cloud Alibaba，Golang 中的 Beego，Python 中的 Flask 等。但这些不同语言的服务之间的访问与运行可能存在一定得困难性与复杂性。但，云原生和微服务架构的结合，使得它们相得益彰。这其中的原因在于：云原生技术可以有效地弥补微服务架构所带来的实现上的复杂度；微服务架构难以落地的一个重要原因是它过于复杂，对开发团队的组织管理、技术水平和运维能力都提出了极高的要求。因此，一直以来只有少数技术实力雄厚的大企业会采用微服务架构。随着云原生技术的流行，在弥补了微服务架构的这一个短板之后，极大地降低了微服务架构实现的复杂度，使得广大的中小企业有能力在实践中应用微服务架构。云原生技术促进了微服务架构的推广，也是微服务架构落地的最佳搭配。</p><h4 id="云原生时代的微服务的未来"><a href="#云原生时代的微服务的未来" class="headerlink" title="云原生时代的微服务的未来"></a>云原生时代的微服务的未来</h4><p>&emsp;&emsp;云原生的第一个发展趋势：标准化和规范化，该技术的基础是容器化和容器编排技术，最经常会用到的技术是 Kubernetes 和 Docker 等。随着云原生技术的发展，云原生技术的标准化和规范化工作正在不断推进，其目的是促进技术的发展和避免供应商锁定的问题，这对于整个云原生技术的生态系统是至关重要的。</p><p>&emsp;&emsp;云原生的第二个发展趋势：平台化，以服务网格技术为代表，这一趋势的出发点是增强云平台的能力，从而降低运维的复杂度。流量控制、身份认证和访问控制、性能指标数据收集、分布式服务追踪和集中式日志管理等功能，都可以由底层平台来提供，这就极大地降低了中小企业在运行和维护云原生应用时的复杂度，服务网格以 Istio 和 Linkerd 为开源代表。</p><p>&emsp;&emsp;云原生的第三个发展趋势：应用管理技术的进步，如在 Kubernetes 平台上部署和更新应用一直以来都比较复杂，传统的基于资源声明 YAML 文件的做法，已经逐步被 Helm 所替代。操作员模式在 Helm 的基础上更进一步，以更高效、自动化和可扩展的方式对应用部署进行管理。</p><h3 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h3><p>&emsp;&emsp;实践项目开源：<a href="https://gitee.com/damon_one/microservice-k8s" target="_blank" rel="noopener">云原生微服务架构设计实战代码</a>。</p><p><strong>欢迎大家star、fork</strong>，欢迎联系我，一起学习。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码：</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;">https://gitee.com/damon_one/spring-cloud-k8shttps://gitee.com/damon_one/spring-cloud-oauth2</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">程序猿Damon</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://www.damon8.cn" style="text-decoration: none" title="">Damon | Micro-Service | Containerization | DevOps</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：程序猿Damon"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Unit one --><p><ins class="adsbygoogle"     style="display:inline-block;text-align:center;width:880px;height:150px"     data-ad-client="ca-pub-1354758384344627"     data-ad-slot="8964778819"></ins></p><script>    (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Service Mesh 是下一代微服务架构</title>
    <link href="http://www.damon8.cn/2021/03/30/ServiceMesh-01/"/>
    <id>http://www.damon8.cn/2021/03/30/ServiceMesh-01/</id>
    <published>2021-03-30T07:09:35.000Z</published>
    <updated>2021-03-30T08:27:32.830Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Service-Mesh-背后的诉求"><a href="#Service-Mesh-背后的诉求" class="headerlink" title="Service Mesh 背后的诉求"></a>Service Mesh 背后的诉求</h2><p>一种技术的出现必然是有各种推动的因素，Service Mesh 也一样，它的出现就得益于微服务架构的发展。那 Service Mesh 出现时，其背后的诉求是什么呢？</p><h3 id="1-微服务架构的复杂性"><a href="#1-微服务架构的复杂性" class="headerlink" title="1. 微服务架构的复杂性"></a>1. 微服务架构的复杂性</h3><p>在微服务架构中，应用系统往往被拆分成很多个微服务（可以多达成百上千），数量庞大的微服务实例使得服务治理具有一定的挑战，比如说常见的服务注册、服务发现、服务实例的负载均衡，以及为了保护服务器实现熔断、重试等基础功能。除此之外，应用程序中还加上了大量的非功能性代码。</p><p>归根结底，在微服务架构中，微服务组件复杂、上手门槛比较高成了痛点问题。业务开发团队需要一定的学习周期才能上手微服务架构的开发，而人力资源的昂贵以及人员的流动性使得开发成本变高。业务开发团队更加擅长的是某一具体领域的业务，而不是技术的深度。应用系统的核心价值在于实现相应的业务，所以对于业务开发人员来说，微服务仅仅是手段，不是最终的目标。我们需要对业务开发人员“屏蔽”微服务的基础组件，使得微服务之间的通信对于业务开发人员透明。</p><p>为应对这个问题，有一些实践是利用 API 网关接收请求，网关作为代理处理外部服务的请求，并提供服务注册与发现、负载均衡、日志监控、容错等功能。然而，这种方案也存在不足，比如网关的单点故障、系统架构变得异常庞大；从功能来看，API 网关主要是面向用户，也就是说它可以解决从用户到各个后端服务的流量问题，至于其他问题，它可能就无能为力了。而我们需要的是一个完整的贯穿整个请求周期的方案，或者至少是一些能够与 API 网关互补的方案和工具。</p><h3 id="2-微服务本身的挑战"><a href="#2-微服务本身的挑战" class="headerlink" title="2. 微服务本身的挑战"></a>2. 微服务本身的挑战</h3><p>微服务还有其自身引入的复杂度，有比学习微服务框架更艰巨的挑战，如微服务的划分、设计良好的声明式 API、单体旧应用的迁移，还涉及跨多个服务的数据一致性，这都会令大部分团队疲于应付。</p><p>除此之外，版本兼容性也是一个挑战。微服务框架很难一开始就完美无缺，在现实的软件工程中一般不存在这样完美无缺的框架，功能会分为多个里程碑迭代，发布之后就会有补丁修复……没有任何问题，这只是一种理想状态。业务服务中引入微服务的基础组件，这样业务服务的代码和微服务的 SDK 强耦合在一起，导致业务升级和微服务 SDK 的升级强绑定在了一起。如果客户端 SDK 和服务器端版本不一致，那就得谨慎对待客户端与服务端的兼容性问题。版本兼容性的处理非常复杂，特别是在服务端和客户端数量庞大的情况下，每对客户端和服务端的版本都有可能不同，这对于兼容性测试也会造成很大的压力。同时，对于异构的系统，还需要开发多语言的 SDK，维护成本很高。</p><h3 id="3-本质"><a href="#3-本质" class="headerlink" title="3. 本质"></a>3. 本质</h3><p>接下来我们探讨下业务服务最关心的是什么，比如写一个商品服务，对商品做增删改查的操作，你会发现基础设施、跨语言、兼容性和商品服务本身并没关系，而服务间的通讯才是最需要解决的问题。</p><p>比如，为了保证将客户端发出的业务请求发去一个正确的地方，需要用什么样的负载均衡？要不要做灰度？最终这些解决方案，都是让请求去访问正确的后端服务。整个过程当中，这个请求是从来不发生更改的。</p><p>既然在开发微服务的时候不用特别关心服务的通讯层，那是不是可以把微服务的技术栈向下移呢？</p><p>微服务的早期先驱，如 Netflix、Twitter 等大型互联网公司，它们通过建立内部库的方式处理这些问题，然后提供给所有服务使用。但这种方法的问题在于这些库相对来说是比较“脆弱”的，很难保证它们可以适应所有的技术堆栈选择，且很难把库扩展到成百上千个微服务中。</p><p>为了应对上述的问题，Service Mesh 出现了， Service Mesh 通过独立进程的方式隔离微服务基础组件，对这个独立进程升级、运维要比传统的微服务方式简单得多。</p><h2 id="什么是-Service-Mesh"><a href="#什么是-Service-Mesh" class="headerlink" title="什么是 Service Mesh"></a>什么是 Service Mesh</h2><p>Service Mesh（服务网格），最早在 2016 年 9 月，由开发 Linkerd 的 Buoyant 公司提出。2017 年，Linkerd 加入 CNCF，由 CNCF 托管孵化，Linkerd 是第一个加入 CNCF 的 Service Mesh 项目。Service Mesh 开始变得流行起来，特别是在技术社区，有人指出 Service Mesh 会是下一代的微服务架构基础。</p><p>关于 Service Mesh 的定义，目前比较认同的是 Buoyant 的 CEO William Morgan 在博客中给出的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Service Mesh 是用于处理服务到服务通信的专用基础架构层。云原生有着复杂的服务拓扑，它负责可靠的传递请求。实际上，Service Mesh 通常是作为一组轻量级网络代理实现，这些代理与应用程序代码部署在一起，应用程序无感知。</span><br></pre></td></tr></table></figure><p>Service Mesh 模式的核心在于将客户端 SDK 剥离，以 Proxy 独立进程运行，目标是将原来存在于 SDK 中的各种能力下沉，为应用减负，以帮助应用云原生化。</p><p>Service Mesh 的第一代产品，如 Linkerd 1 和 Envoy，天然支持虚拟机。随着云原生的崛起，到了 Istio 和 Linkerd 2 ，不支持虚拟机。相比虚拟机，Kubernetes 提供了太多便利。 绝大部分Service Mesh 的实现都支持 Kubernetes，有些实现甚至只支持 Kubernetes。就这样，Service Mesh 逐步发展为一个独立的基础设施层。</p><p>在云原生架构下，应用系统可能由数百个微服务组成，微服务一般又是多实例部署，并且每一个实例都可能处于不断变化的状态，因为它们是由 Kubernetes 之类的资源调度系统动态调度。 Kubernetes 中的 Service Mesh 实现模式被命名为 Sidecar（边车模式，因为类似连接到摩托车的边车）。</p><p>在模式库中，Sidecar 模式的定义是：将应用程序的组件部署到单独的进程或容器中以提供隔离和封装。这种模式还可以使应用程序由异构组件和技术组成。</p><p>在 Sidecar 模式中，“边车”与父应用程序（即业务服务）是两个独立的进程，二者生命周期相同，同时被创建和退出。“边车”附加到业务服务，并为应用提供支持功能。</p><p>业务所有的流量都转发到 Service Mesh 的代理服务 Sidecar 中，Sidecar 承担了微服务框架基础的功能，包括服务注册与发现、负载均衡、熔断限流、认证鉴权、日志、监控和缓存加速等。不同的是，Service Mesh 强调的是通过独立进程的代理方式。总体来说，Service Mesh 帮助应用程序在复杂的软件架构和网络中建立稳定的通信机制。</p><h2 id="Service-Mesh-的开源组件"><a href="#Service-Mesh-的开源组件" class="headerlink" title="Service Mesh 的开源组件"></a>Service Mesh 的开源组件</h2><p>近几年 Service Mesh 社区比较活跃，其对应的开源组件也很丰富，从最早的 Linkerd 到当前火热的 Istio、Envoy 等组件，下面我们就来重点介绍下这三个开源组件。</p><h3 id="1-Istio"><a href="#1-Istio" class="headerlink" title="1. Istio"></a>1. Istio</h3><p>Istio 由 Google、IBM 和 Lyft 合作开源，所以 Istio 自诞生之日起就备受瞩目。在 Istio 中，直接使用了 Lyft 公司的 Envoy 作为 Sidecar。2017 年 5 月 Istio 发布了 0.1 版本，现在已经发展到 1.9 版本。Istio 是 Service Mesh 的第二代产品，在刚开始发布时还曾计划提供对非 Kubernetes 的支持，发展到现在基本只支持 Kubernetes 上的使用，实质性取消了对虚拟机的支持。</p><p>Istio 功能十分丰富，包括：</p><p>流量管理：Istio 的基本功能，Istio 的流量路由规则使得你可以轻松控制服务之间的流量和 API 调用。</p><p>策略控制：应用策略并确保其得到执行，并且资源在消费者之间公平分配。</p><p>可观测性：通过自动链路追踪、监控和服务的日志，可以全面了解受监视服务如何与其他服务以及 Istio 组件本身进行交互。</p><p>安全认证：通过托管的身份验证，授权和服务之间通信的加密自动保护服务。Istio Security 提供了全面的安全解决方案来解决这些问题。</p><p>Istio 针对现有的服务网络，提供了一种简单的方式将连接、安全、控制和观测的模块，与应用程序或服务隔离开来，从而使开发人员可以将更多的精力放在核心的业务逻辑上。另外，Istio 直接基于成熟的 Envoy 代理进行构建，控制面组件则都是使用 Go 编写，在不侵入应用程序代码的前提下实现可视性与控制能力。总之，Istio 的设计理念是非常新颖前卫的。</p><h3 id="2-Linkerd"><a href="#2-Linkerd" class="headerlink" title="2. Linkerd"></a>2. Linkerd</h3><p>2016 年 1 月，前 Twitter 工程师 William Morgan 和 Oliver Gould 组建了一个名为 Buoyant 的公司，同时在 GitHub 上发布了 Linkerd 0.0.7 版本。Linkerd 由 Buoyant 推出，使用 Scala 语言实现，是业界第一个 Service Mesh。2017 年 1 月，Linkerd 加入 CNCF； 4 月，发布了 1.0 版本。</p><p>Linkerd 的架构由两部分组成：数据平面和控制平面。其中，数据平面由轻量级代理组成，它们作为 Sidecar 容器与服务代码的每个实例一起部署；控制平面是一组在专用 Kubernetes 命名空间中运行的服务（默认情况下）。这些服务承担聚合遥测数据、提供面向用户的 API、向数据平面代理提供控制数据等功能，它们共同驱动着数据平面的行为。</p><p>Linkerd 作为 Service Mesh 的先驱开源组件，在生产环境得到了大规模使用。Linkerd 2 的定位是 Kubernetes 的 Service Mesh，其提供了运行时调试、可观察性、可靠性和安全性，使得运行服务变得更容易、更安全，而无须更改代码。但是随着 Istio 的诞生，前景并不是特别乐观。</p><h3 id="3-Envoy"><a href="#3-Envoy" class="headerlink" title="3. Envoy"></a>3. Envoy</h3><p>2016 年 9 月，Lyft 公司开源 Envoy ，并在 GitHub 上发布了 1.0.0 版本。Envoy 由 C++ 实现，性能和资源消耗上表现优秀。2017 年 9 月，Envoy 加入 CNCF，成为继 Linkerd 之后的第二个 Service Mesh 项目。Envoy 发展平稳，被 Istio 收编之后，Envoy 将自身定义为数据平面，并希望使用者可以通过控制平面来为 Envoy 提供动态配置。Envoy 用于云原生应用，为应用服务提供高性能分布式代理，以及作为大规模微服务架构的 Service Mesh 通信总线和通用数据平面。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码：</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;">https://gitee.com/damon_one/spring-cloud-k8shttps://gitee.com/damon_one/spring-cloud-oauth2</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">程序猿Damon</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://www.damon8.cn" style="text-decoration: none" title="">Damon | Micro-Service | Containerization | DevOps</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：程序猿Damon"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Unit one --><p><ins class="adsbygoogle"     style="display:inline-block;text-align:center;width:880px;height:150px"     data-ad-client="ca-pub-1354758384344627"     data-ad-slot="8964778819"></ins></p><script>    (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>什么是服务网格（Service Mesh）</title>
    <link href="http://www.damon8.cn/2021/03/30/Service-Mesh/"/>
    <id>http://www.damon8.cn/2021/03/30/Service-Mesh/</id>
    <published>2021-03-30T06:41:28.000Z</published>
    <updated>2021-03-30T06:57:19.858Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>服务网格（Service Mesh）是随着 Kubernetes 和微服务架构的流行而出现的新技术，它的目的是解决微服务架构的服务之间相互调用时可能存在的各种问题。微服务架构的服务之间采用进程间的通讯方式进行交互，比如 REST 或 gRPC 等。在第 01 课时介绍微服务架构的时候，我提到过影响微服务架构复杂度的一个重要因素就是微服务之间的相互调用，这使得应用需要对服务调用时产生的错误进行处理。比如，当调用一个服务出现超时错误时，应该进行重试；如果对某个服务的调用在一段时间内频繁出错，说明该服务可能已经崩溃或是负载过大，没有必要再继续进行尝试下去了。</p><p>除了错误处理之外，我们还可能需要对服务之间的调用添加一些策略，比如限制服务被调用的速率，或是添加安全相关的访问控制规则等。这些需求从服务之间的调用而来，并且所有微服务架构的应用都有同样的需求，这些横切的需求，应该由平台或工具来处理，而不需要应用来实现，应用要做的只是提供相关的配置即可。</p><p>在 Kubernetes 出现之前，微服务架构已经在很多企业内部得到了应用。同样的，在服务网格之前也有相似的工具来解决服务调用相关的问题，比如 Netflix OSS 栈中的 Hystrix，但服务网格技术是在已有工具上的升级，它提供了一个更完整的解决方案。</p><p>严格说来，服务网格并不直接依赖 Kubernetes，但绝大部分服务网格实现都支持 Kubernetes，有些实现甚至只支持 Kubernetes。这是因为 Kubernetes 平台提供的功能可以简化服务网格的使用。下面我来为你介绍 Kubernetes 中的边车模式（Sidecar）。</p><h3 id="边车模式"><a href="#边车模式" class="headerlink" title="边车模式"></a>边车模式</h3><p>在 Kubernetes 中，Pod 中的容器通常是紧密耦合的，它们共同完成应用的功能。如果需要实现横切功能，则需要在 Pod 中添加与应用无关的容器，这是因为横切功能的实现离不开对应用使用的存储和网络的访问，而 Pod 中的容器之间共享存储和网络。当我们把横切服务的容器添加到 Pod 中后，Pod中就多了与应用无关的容器，这种部署模式称为边车模式，这些容器被称为边车容器，下图是现实世界中的边车。</p><p>日志收集是边车模式的一个常见应用，它利用了 Pod 中容器共享存储的特性：应用容器往某个持久卷中写入日志，而日志收集工具的边车容器则监控同一个持久卷中的文件来读取日志。</p><p>边车容器在服务网格实现中至关重要。服务网格实现会在每个 Pod 上增加一个新的边车容器来作为其中应用服务的代理，这个容器的代理程序会作为外部调用者和实际服务提供者之间的桥梁。</p><p>如下图所示，Pod 某个端口上的请求，首先会被服务代理处理，然后再转发给实际的应用服务；同样的，应用服务对外的请求，也会先被服务代理处理，然后再转发给实际的接收者。代理边车容器的出现，为解决服务调用相关的问题提供了一种新的方案：服务调用的自动重试和断路器模式的实现，都可以由服务代理来完成，从而简化应用服务的实现。</p><img src="https://static001.geekbang.org/infoq/25/25238dd65ebd30ae0442e82c0f60810c.png" style="display: block; margin: 0 auto; max-width: 100%;"><p>如果仅从最基本的实现方式上来说，服务网格技术并不复杂。打个比方，如果一个 Pod 提供某个应用服务，只需要在该 Pod 中部署一个服务代理的边车容器，由该代理来处理应用容器发送和接收的数据，就实现了服务网格。</p><p>但是，服务网格实际上的解决方案非常复杂，我会在下面进行具体的介绍。</p><p>值得一提的是，边车模式并不是服务代理的唯一部署方式。有些服务网格实现可以在Kubernetes的节点上部署服务代理来处理该节点上的全部请求。</p><h3 id="服务代理"><a href="#服务代理" class="headerlink" title="服务代理"></a>服务代理</h3><p>服务代理是服务网格技术实现的核心，可以说，服务代理决定了服务网格能力的上限。从作用上来说，服务代理与我们所熟悉的 Nginx 和 HAProxy 这类代理并没有太大区别。实际上， Nginx 和 HAProxy 同样可以作为服务代理来使用，但服务网格通常使用专门为服务间调用开发的服务代理实现。在下图所示的 OSI 七层模型中，服务代理一般工作在第 3/4 层和第 7 层。</p><img src="https://static001.geekbang.org/infoq/d7/d78ab20067d165fed51ae7c025c13c29.png" style="display: block; margin: 0 auto; max-width: 100%;"><p>下表列出了常见的服务代理，其中 Envoy、Traefix 和 Linkerd 2 都是新出现的服务代理实现。</p><img src="https://static001.geekbang.org/infoq/a0/a052b50d05a906b856f4953bf6bb422a.png" style="display: block; margin: 0 auto; max-width: 100%;"><p>服务发出和接收的所有调用都需要经过服务代理。服务代理的功能都与服务之间的调用相关，其主要方面如下表所示。 </p><img src="https://static001.geekbang.org/infoq/58/58cb1d35b7a1b2debc92bd557a8edf12.png" style="display: block; margin: 0 auto; max-width: 100%;"><p>代理可以在请求层上工作。当服务 A 调用服务 B 时，服务 A 的代理可以使用负载均衡来动态选择实际调用的服务 B 实例，如果对服务 B 的调用失败，并且该调用是幂等的，则代理可以自动进行重试。服务 A 的代理还可以记录与调用相关的指标数据，服务 B 的代理可以根据访问控制的策略决定是否允许该请求，如果服务 B 当前所接收的请求过多，那么它的代理可以拒绝其中某些请求。</p><p>代理同样可以工作在连接层，服务 A 和服务 B 的代理之间可以建立 TLS 连接，并验证对方的身份。</p><p>由于服务代理需要处理服务所有接收和发送的请求，这对服务代理的性能要求很高，不能增加过长的延迟，这也是 Envoy 等服务代理流行的原因，这些新开发的服务代理对服务之间的调用进行了优化。除了性能之外，服务代理只占用很少的 CPU 和内存资源，这是因为每个服务实例的 Pod 上都可能运行着一个服务代理的容器，当服务数量增加时，服务代理自身的资源开销也会增加。</p><h3 id="服务网格"><a href="#服务网格" class="headerlink" title="服务网格"></a>服务网格</h3><p>服务网格技术起源于 Linkerd 项目，从架构上来说，服务网格的实现很简单，它由服务代理和管理进程组成。服务代理称为服务网格的数据平面（Data Plane），负责拦截服务之间的调用并进行处理；管理进程称为服务网格的控制平面（Control Plane），负责协调代理并提供 API 来管理和监控服务网格。服务网格的能力由这两个平面的能力共同决定。</p><p>下图给出了服务网格的基本架构:</p><img src="https://static001.geekbang.org/infoq/2d/2db5eba7b3d8a3e057accfd1929e24bd.png" style="display: block; margin: 0 auto; max-width: 100%;"><p>服务网格在数据平面的处理能力取决于所使用的服务代理，而服务网格实现通常使用已有的服务代理，因此它们在数据平面方面的能力差别并不大。服务网格实现的价值更多来源于它所提供的控制平面，比如，服务网格实现是否提供了 API 来更新配置，是否提供了图形化界面来查看服务状态，在 Kubernetes 上，是否可以使用自定义资源定义（Custom Resource Definition，CRD）来进行声明式配置。</p><p>服务网格技术的优势有以下几个方面:</p><ul><li><p>它与服务实现使用的技术栈无关。服务代理工作在服务调用这个层次上。不论服务采用什么编程语言或框架来实现，服务代理都可以产生作用。Kubernetes 的流行，使得在微服务架构实现中使用多语言开发变得更简单。一个微服务应用的不同服务可以使用完全不同的技术栈来实现，这些服务之间的调用都可以由服务代理来处理。</p></li><li><p>服务网格技术与应用代码是解耦的，这意味着当我们需要对服务调用相关的策略进行调整时，并不需要修改应用的代码。以服务的访问频率为例，当需要控制对某个服务的调用频率时，可以通过服务网格的控制平面提供的 API 直接进行修改，并不需要对应用做任何改动。这种解耦使得服务网格成为应用运行平台所提供的能力之一，进而促成了新的开源项目和商业产品的出现。</p></li><li><p>对于大型项目，可以由专门的团队来负责管理服务网格的配置，进行更新和日常维护；对于小型项目，可以从开源社区选择合适的产品。</p></li></ul><h3 id="服务网格功能"><a href="#服务网格功能" class="headerlink" title="服务网格功能"></a>服务网格功能</h3><p>服务网格所能提供的功能非常多。每个服务网格实现所提供的功能也各有不同。下面我将对服务网格中的重要功能进行介绍。</p><h3 id="自动代理注入"><a href="#自动代理注入" class="headerlink" title="自动代理注入"></a>自动代理注入</h3><p>为了使用服务网格提供的功能，应用服务的 Pod 需要添加服务代理容器，服务网格提供了自动的代理注入机制。在 Kubernetes 上，如果 Pod 或控制器对象中添加了某个特定的注解，则服务网格可以自动在 Pod 中添加服务代理容器并完成相关的配置。</p><p>流量管理</p><p>流量管理指的是管理服务之间的相互调用，由一系列的子功能组成。</p><ol><li>服务发现</li></ol><p>服务发现指的是发现系统中存在的服务及其对应的访问地址，服务网格会在内部维护一个注册表，包含所有发现的服务及其对应的服务端点。</p><ol start="2"><li>负载均衡</li></ol><p>每个服务通常都有多个运行的实例，在进行调用时，需要根据某些策略选择处理请求的实例。负载均衡的算法可以很简单，比如循环制（round robin）；也可以很复杂，比如根据被调用服务的各个实例的负载情况来动态选择。</p><ol start="3"><li>流量控制</li></ol><p>微服务架构的应用强调持续集成和持续部署，应用的每个服务都可以被单独部署。一个常见的需求是在进行更新时，让小部分用户使用新的版本，而大部分用户仍然使用当前的旧版本，这样的更新方式称为金丝雀部署（Canary Deployment）。为了支持这样的更新方式，我们可以同时部署服务的两个版本，并通过服务网格把调用请求分配到两个版本，比如，20% 的请求分配到新版本，剩下 80% 的请求分配到当前版本，经过一段时间的测试之后，再逐步把更多的请求分配到新版本，直到全部请求分配至新版本。</p><ol start="4"><li>超时处理</li></ol><p>服务网格对服务调用添加了超时处理机制。如果调用在设置的时间之后仍然没有返回，则会直接出错，这样就避免了在被调用的服务出现问题时，进行不必要的等待。不过，超时时间也不能设置得过短，否则会有大量相对耗时的调用产生不必要的错误，针对这一点，服务网格提供了基于配置的方式来调整服务的超时时间。</p><ol start="5"><li>重试</li></ol><p>当服务的调用出现错误时，服务网格可以选择进行重试，服务重试看似简单，但要正确的实现并不容易。简单的重试策略，比如固定时间间隔和最大重试次数的做法，很容易产生重试风暴（Retry Storm）。如果某些请求因为服务负载的原因而失败，简单的重试策略会在固定的时间间隔之后，重试全部失败请求，这些请求在重试时又会因为负载过大的原因而再次失败。所造成的结果就是产生大量失败的重试请求，影响整体的性能，有效的重试机制应该避免出现重试风暴。</p><ol start="6"><li>断路器</li></ol><p>断路器（Circuit Breaker）是微服务架构中的一种常见模式。通过断路器，可以在服务的每个实例上设置限制，比如同时允许的最大连接数量，或是调用失败的次数。当设定的限制达到时，断路器会自动断开，禁止对该实例的连接。</p><p>断路器的存在，使得服务调用可以快速失败，而不用尝试连接一个已经失败或过载的实例，所以它的一个重要作用是避免服务的级联失败。如果一个服务出现错误，可能导致它的调用者因为超时而积压很多未处理的请求，进而导致它的调用者也由于负载过大而崩溃，这样的级联效应，有可能导致整个应用的崩溃。使用断路器之后，出现错误的服务实例被自动隔离，不会影响系统中的其他服务。</p><ol start="7"><li>错误注入</li></ol><p>在使用服务网格配置了服务的错误处理策略之后，一个重要的需求是对这些策略进行测试。错误注入指的是往系统中引入错误来测试应用的故障恢复能力，比如，错误注入可以在服务调用时自动添加延迟，或是直接返回错误给调用者。</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>安全相关的功能解决应用的 3 个 A 需求，分别是认证（Authentication）、授权（Authorization）和审计（Audit）。这3个需求的英文名称都以字母A开头，所以称为3个A需求。</p><p>双向 TLS（mutual TLS，mTLS）指的是在服务调用者和被调用者的服务代理之间建立双向 TLS 连接，这个连接意味着客户端和服务器都需要认证对方的身份。通过 TLS 连接可以对通信进行加密，防止中间人攻击。</p><p>用户认证：服务网格应该可以和不同的用户认证服务进行集成，常用的认证方式包括 JWT 令牌认证，以及与 OpenID Connect 提供者进行集成。</p><h3 id="访问策略"><a href="#访问策略" class="headerlink" title="访问策略"></a>访问策略</h3><p>访问策略用来描述服务调用时的策略。</p><ul><li>访问速率控制：通过访问速率控制，可以限制服务的调用速度，防止服务因请求过多而崩溃。</li></ul><ul><li>服务访问控制：服务访问控制用来限制对服务的访问，限制的方式包括禁止服务、黑名单和白名单等。</li></ul><h3 id="可观察性"><a href="#可观察性" class="headerlink" title="可观察性"></a>可观察性</h3><p>服务网格可以收集与服务之间通信相关的遥测数据，这些数据使得运维人员可以观察服务的行为，发现服务可能存在的问题，并对服务进行优化。</p><p>性能指标：是指服务网格收集与服务调用相关的性能指标数据，包括延迟、访问量、错误和饱和度。除此之外，服务网格还收集与自身的控制平面相关的数据。</p><p>分布式追踪：可以查看单个请求在服务网格中的处理流程，在微服务架构中，应用接收到的请求可能由多个服务协同处理。在请求延迟过高时，需要查看请求在不同服务之间的调用流程，以及每个服务所带来的延迟。分布式追踪是服务网格提供的工具，可以用来收集相关的调用信息。</p><p>访问日志：用来记录每个服务实例所接收到的请求。</p><h3 id="服务网格产品介绍"><a href="#服务网格产品介绍" class="headerlink" title="服务网格产品介绍"></a>服务网格产品介绍</h3><p>Istio 项目由 Google、IBM 和 Lyft 共同发起。由于有大公司的支持，Istio 项目目前所提供的功能是最完备的，这也意味着 Istio 是最复杂的。Istio 所包含的组件非常多，对应的配置也非常复杂，它的学习曲线很陡，上手并不容易。值得一提的是，Lyft 的 Envoy 团队与 Istio 有很好的合作，这就保证了 Istio 有最好的 Envoy 支持。本专栏将使用 Istio 来作为服务网格的实现。</p><p>Linkerd 是最早的服务网格实现，目前作为 CNCF 的项目来开发。相对 Istio 而言，Linkerd 提供的功能较少，但是也更简单易用。对很多应用来说，Linkerd 所提供的功能已经足够好。</p><p>Maesh 是 Containous 提供的服务网格实现。Maesh 使用 Traefik 作为服务代理。相对于 Istio 和 Linkerd，Maesh 还是一个比较新的项目，需要更多的时间来考察。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码：</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;">https://gitee.com/damon_one/spring-cloud-k8shttps://gitee.com/damon_one/spring-cloud-oauth2</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">程序猿Damon</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://www.damon8.cn" style="text-decoration: none" title="">Damon | Micro-Service | Containerization | DevOps</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：程序猿Damon"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Unit one --><p><ins class="adsbygoogle"     style="display:inline-block;text-align:center;width:880px;height:150px"     data-ad-client="ca-pub-1354758384344627"     data-ad-slot="8964778819"></ins></p><script>    (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>云产品年中大优惠</title>
    <link href="http://www.damon8.cn/2021/03/19/popularize-02/"/>
    <id>http://www.damon8.cn/2021/03/19/popularize-02/</id>
    <published>2021-03-19T10:05:26.000Z</published>
    <updated>2021-04-14T03:38:16.827Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">双十一阿里云全网最低：<a class="nav-item-link" target="_blank" href="https://www.aliyun.com/1111/pintuan-share?ptCode=MTc3NDc1NjEyMjkzNTc5N3x8MTE0fDE%3D&userCode=cdnpht6s" style="text-decoration: none" title="InfoQ">立即领取</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">阿里云产品大促：<a class="nav-item-link" target="_blank" href="https://www.aliyun.com/minisite/goods?userCode=cdnpht6s" style="text-decoration: none" title="InfoQ">立即领取</a></p><br><p>专属折扣码：</p><img src="/images/popularize/aliyun.png" style="display: block; margin: 0 auto; max-width: 100%;"><br data-tool="mdnice编辑器"><p>=============================================================================================================================</p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">【腾讯云】11.11 云上盛惠，云产品限时抢购，1核2G云服务器首年88元！<a class="nav-item-link" target="_blank" href="https://curl.qcloud.com/E29fNTk3" style="text-decoration: none" title="InfoQ">立即秒杀</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">【腾讯云】境外1核2G服务器低至2折，半价续费券限量免费领取！<a class="nav-item-link" target="_blank" href="https://curl.qcloud.com/yGyHMrOc" style="text-decoration: none" title="InfoQ">立即秒杀</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">【腾讯云】新客户无门槛领取总价值高达2860元代金券，每种代金券限量500张，先到先得！<a class="nav-item-link" target="_blank" href="https://curl.qcloud.com/ewl6G2Di" style="text-decoration: none" title="InfoQ">立即秒杀</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">【腾讯云】热卖云产品3折起，云服务器、云数据库特惠，服务更稳，速度更快，价格更低！<a class="nav-item-link" target="_blank" href="https://curl.qcloud.com/VuHGCdHM" style="text-decoration: none" title="InfoQ">立即秒杀</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">【腾讯云】腾讯云数据库性能卓越稳定可靠，为您解决数据库运维难题<a class="nav-item-link" target="_blank" href="https://curl.qcloud.com/yZ7iRLoW" style="text-decoration: none" title="InfoQ">立即秒杀</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">【腾讯云】云数据库MySQL基础版1元体验<a class="nav-item-link" target="_blank" href="https://curl.qcloud.com/QYRX2K0A" style="text-decoration: none" title="InfoQ">立即秒杀</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">腾讯云新客专属福利：<a class="nav-item-link" target="_blank" href="https://url.cn/7JAnmBmX" style="text-decoration: none" title="InfoQ">立即秒杀</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">腾讯云十周年大促：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/act/cps/redirect?redirect=33567&cps_key=c140c92d2bde7476bad935dc8ea0ef41&from=activity" style="text-decoration: none" title="InfoQ">立即秒杀</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">腾讯云服务器全球购：<a class="nav-item-link" target="_blank" href="https://url.cn/huMTG8Sc" style="text-decoration: none" title="InfoQ">立即抢购</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">腾讯企业上云特惠活动：<a class="nav-item-link" target="_blank" href="https://url.cn/Vx78pocV" style="text-decoration: none" title="InfoQ">立即抢购</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">腾讯云产品三折：<a class="nav-item-link" target="_blank" href="https://url.cn/vzVRpgHO" style="text-decoration: none" title="InfoQ">立即抢购</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">腾讯服务器X实时音视频 联合大促：<a class="nav-item-link" target="_blank" href="https://url.cn/TpMozc1X" style="text-decoration: none" title="InfoQ">立即抢购</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">腾讯云服务器购买页：<a class="nav-item-link" target="_blank" href="https://url.cn/FH9kStEc" style="text-decoration: none" title="InfoQ">立即抢购</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">腾讯云数据库购买页：<a class="nav-item-link" target="_blank" href="https://url.cn/LyWcueXJ" style="text-decoration: none" title="InfoQ">立即抢购</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">腾讯云新客专属福利：<a class="nav-item-link" target="_blank" href="https://url.cn/RMo8TtHA" style="text-decoration: none" title="InfoQ">立即抢购</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">腾讯云限时秒杀活动：<a class="nav-item-link" target="_blank" href="https://url.cn/Npc7v6ae" style="text-decoration: none" title="InfoQ">立即抢购</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">腾讯云数据库Redis：<a class="nav-item-link" target="_blank" href="https://url.cn/mRkH6Kem" style="text-decoration: none" title="InfoQ">立即抢购</a></p><br><p>=============================================================================================================================</p><br><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">华为云新客专属福利：<a class="nav-item-link" target="_blank" href="https://account.huaweicloud.com/obmgr/invitation/invitation.html?bpName=000000010000000263EE620C0306EC55CA228C7F03DCE166723D7253C2DEA099D34C69DD0FECCE13692F65A613D7DEAFF4BEDA506668EFE88D57BC5DEDD5EA7D1DCC557E55B653A1&inviteCode=00000001000000020DDF706C9C17CC9385769E6F76491B4B2663ACCDCE6E162A8B68F6FBD5ECB0B9&bindType=1&isDefault=1" style="text-decoration: none" title="InfoQ">立即注册</a></p><br><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码：</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;">https://gitee.com/damon_one/spring-cloud-k8shttps://gitee.com/damon_one/spring-cloud-oauth2</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">程序猿Damon</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://www.damon8.cn" style="text-decoration: none" title="">Damon | Micro-Service | Containerization | DevOps</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：程序猿Damon"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Unit one --><p><ins class="adsbygoogle"     style="display:inline-block;text-align:center;width:880px;height:150px"     data-ad-client="ca-pub-1354758384344627"     data-ad-slot="8964778819"></ins></p><script>    (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>备份Kubernetes的5个最佳实践</title>
    <link href="http://www.damon8.cn/2021/02/22/k8s-backup/"/>
    <id>http://www.damon8.cn/2021/02/22/k8s-backup/</id>
    <published>2021-02-22T09:14:29.000Z</published>
    <updated>2021-02-24T04:26:36.492Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>备份应用程序和数据是组织经常需要处理的事情。尽管Kubernetes可以确保应用程序服务的高可用性和可伸缩性，但这些好处并不能有效地保护数据。因此，必须对Kubernetes应用程序进行数据管理和备份，并应将其纳入标准操作流程中。</p><p>但是，备份Kubernetes应用程序需要一种独特的方法，该方法与传统的备份解决方案大不相同。使用Kubernetes，经常会将应用程序部署在集群中跨节点的多个容器中，要备份应用程序以及数据和存储量，你需要考虑所有各种Kubernetes对象和配置数据，还必须适应应用程序快速的开发和部署周期，DevOps的“左移(shift-left)”理念，数据保护，安全要求等。</p><p>鉴于这些独特的要求，备份Kubernetes似乎是一项艰巨的任务，但是你可以采取一些步骤来简化该过程。以下是五个最佳做法：</p><p><strong>1.考虑Kubernetes架构</strong></p><p>一个典型的Kubernetes应用程序由数百个组件组成-Pod，服务(service)，证书，密钥(secret)等等。任何Kubernetes备份解决方案不仅要能够备份和还原数据，而且还要能够备份和还原所有这些组件。至关重要的是，备份解决方案要通过API自动与Kubernetes控制平面进行交互，以便不仅能够发现集群上运行的Kubernetes应用，而且还可以与基础计算，网络和存储基础架构集成。</p><p>存储也是一个重要的考虑因素，必须包含在备份计划中。与应用程序配置数据一样，Kubernetes存储（用于应用程序容器的持久卷）包含需要保护的重要业务数据。</p><p>最后，确定要备份存储的位置。你将其保留在本地s存储还是在云中？灵活性和易用性将成为任何数据备份存储的重要特征。</p><p><strong>2.制定恢复计划</strong></p><p>由于Kubernetes应用程序的分布式架构，还原数据需要很多步骤。例如，你需要验证集群依赖关系，创建新的Kubernetes视图的替代数据，并确定在何处启动恢复。然后，你需要标识备份数据源并准备目标存储。一旦计划了这些，就必须更新所有组件以创建新的存储资源。提前创建详细计划可以帮助你引导这个复杂的过程，幸运的是，有些Kubernetes备份解决方案可以自动为你执行此操作，你应该寻找一种支持此功能的解决方案。</p><p>但是可靠的执行计划仅仅是开始。你还应该确保你的备份平台可以将各个步骤转换为相关的Kubernetes API调用。这样可确保恢复功能所需的资源可用，并确保正确部署和配置了云原生应用程序的所有组件。</p><p><strong>3.简化操作</strong></p><p>如果备份需要编码，打包或部署，则开发人员可能会避免使用它们。他们的目标是快速开发和部署应用程序，而复杂的备份过程可能会阻碍其进展。</p><p>因此，备份应由API驱动，并且是无缝衔接的。确保你的解决方案具有针对应用程序而不是其单个组件的自动备份策略，并具有在部署新应用程序时检测和备份新应用程序的能力。最后，确保你的备份解决方案提供了简单的工作流程，并使你的运维团队能够顺畅地遵守任何法规和监控要求。</p><p><strong>4.确保安全</strong></p><p>与任何数据管理功能一样，安全性至关重要。执行Kubernetes备份时，要实施身份和访问管理以及基于角色的访问管理（RBAC）的控件，以确保只有授权的用户和组才能访问备份平台。这使你可以控制谁可以执行任务，例如监视和验证备份，执行还原等，并使你可以向开发人员授予从快照还原应用程序的权限。</p><p>你的解决方案应集成到云提供商的身份验证解决方案中，而无需任何其他工具或API。最后，请确保你的数据已加密-无论是在传输中还是在静止状态。</p><p><strong>5.利用Kubernetes的可移植性</strong></p><p>要利用Kubernetes的可移植性功能，你的备份解决方案应该能够兼容几种发行版和基础架构配置执行还原，并自动转换应用程序的备份版本以在新环境中运行。</p><p>备份解决方案要能够转换所有应用程序依赖项以与新环境兼容，这一点很重要。</p><p><strong>Kubernetes原生备份是你的最佳选择</strong></p><p>无论你的目标是保护Kubernetes应用程序免受数据丢失和损坏，为测试和开发目的备份数据，将应用程序迁移到新环境中，还是支持组织的灾难恢复计划，备份对于高效运维都是必不可少的。</p><p>使用传统解决方案而不是专门为Kubernetes环境设计的解决方案会增加意外数据丢失和配置错误的风险，并且无法提供保护应用程序数据所需的细粒度，可感知的应用程序备份和恢复功能。为了遵守Kubernetes环境中的备份和恢复最佳实践，Kubernetes原生备份解决方案是最佳方法。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码：</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;">https://gitee.com/damon_one/spring-cloud-k8shttps://gitee.com/damon_one/spring-cloud-oauth2</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：程序猿Damon"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br><br><code style="font-size: 20px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: red">特别声明 <br>原文作者：王延飞 <br>本文原链：http://mtw.so/5GiprA <br>本文转载如有侵权，请联系站长删除，谢谢 <br></code><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Unit one --><p><ins class="adsbygoogle"     style="display:inline-block;text-align:center;width:880px;height:150px"     data-ad-client="ca-pub-1354758384344627"     data-ad-slot="8964778819"></ins></p><script>    (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Spring Cloud 与 K8s 在微服务层面的不同</title>
    <link href="http://www.damon8.cn/2021/02/04/spring-cloud-k8s/"/>
    <id>http://www.damon8.cn/2021/02/04/spring-cloud-k8s/</id>
    <published>2021-02-04T02:18:16.000Z</published>
    <updated>2021-02-22T02:58:55.237Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Spring-Boot-1-x-与-2-x-的区别"><a href="#Spring-Boot-1-x-与-2-x-的区别" class="headerlink" title="Spring Boot 1.x 与 2.x 的区别"></a>Spring Boot 1.x 与 2.x 的区别</h3><p>在《<a href="https://www.damon8.cn/2020/07/23/micro-service03/">微服务 Spring Cloud 架构设计</a>》一文中，笔者讲过 Spring Cloud 的架构设计。其实 Spring Boot 在一开始时，运用到的基本就是 Eureka、Config、Zuul、Ribbon、Feign、Hystrix 等。到了 Spring Boot 2.x 的时候，大量的组件开始风云崛起。下面简单列下这两个版本之间的区别如下。</p><p>Spring Boot 1.x 中，session 的超时时间是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.session.timeout&#x3D;3600</span><br></pre></td></tr></table></figure><p>而在 2.x 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.servlet.session.timeout&#x3D;PT120M</span><br></pre></td></tr></table></figure><p>截然不同的写法，cookie 也是一样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  servlet:</span><br><span class="line">    session:</span><br><span class="line">      timeout: PT120M</span><br><span class="line">      cookie:</span><br><span class="line">        name: ORDER-SERVICE-SESSIONID</span><br></pre></td></tr></table></figure><ul><li>应用的 ContextPath 配置属性改动，跟上面的 session 一样，加上了一个 servlet。</li><li>Spring Boot 2.x 基于 Spring 5，而 Spring Boot 1.x 基于 Spring 4 或较低。</li><li>统一错误处理的基类 AbstarctErrorController 的改动。</li><li>配置文件的中文可以直接读取，不需要转码。</li><li>Acutator 变化很大，默认情况不再启用所有监控，需要定制化编写监控信息，完全需要重写，HealthIndicator,EndPoint 同理。</li><li>从 Spring Boot 2.x 开始，可以与 K8s 结合来实现服务的配置管理、负载均衡等，这是与 1.x 所不同的。</li></ul><h3 id="K8s-的一些资源的介绍"><a href="#K8s-的一些资源的介绍" class="headerlink" title="K8s 的一些资源的介绍"></a>K8s 的一些资源的介绍</h3><p>上面说到 Spring Boot 2.x 可以结合 K8s 来作为微服务的架构设计，那么就先来说下 K8s 的一些组件吧。</p><p>ConfigMap，看到这个名字可以理解：它是用于保存配置信息的键值对，可以用来保存单个属性，也可以保存配置文件。对于一些非敏感的信息，比如应用的配置信息，则可以使用 ConfigMap。</p><p>创建一个 ConfigMap 有多种方式如下。</p><p><strong>1. key-value 字符串创建</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap test-config --from-literal&#x3D;baseDir&#x3D;&#x2F;usr</span><br></pre></td></tr></table></figure><p>上面的命令创建了一个名为 test-config，拥有一条 key 为 baseDir，value 为 “/usr” 的键值对数据。</p><p><strong>2. 根据 yml 描述文件创建</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: test-config</span><br><span class="line">data:</span><br><span class="line">  baseDir: &#x2F;usr</span><br></pre></td></tr></table></figure><p>也可以这样，创建一个 yml 文件，选择不同的环境配置不同的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">kind: ConfigMap</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: cas-server</span><br><span class="line">data:</span><br><span class="line">  application.yaml: |-</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the World</span><br><span class="line">    ---</span><br><span class="line">    spring:</span><br><span class="line">      profiles: dev</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Dev</span><br><span class="line">    spring:</span><br><span class="line">      profiles: test</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Test</span><br><span class="line">    spring:</span><br><span class="line">      profiles: prod</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Prod</span><br></pre></td></tr></table></figure><p>注意点：</p><ol><li>ConfigMap 必须在 Pod 使用其之前创建。</li><li>Pod 只能使用同一个命名空间的 ConfigMap。</li></ol><p>当然，还有其他更多用途，具体可以参考官网。</p><p>Service，顾名思义是一个服务，什么样的服务呢？它是定义了一个服务的多种 pod 的逻辑合集以及一种访问 pod 的策略。</p><p>service 的类型有四种：</p><ul><li>ExternalName：创建一个 DNS 别名指向 service name，这样可以防止 service name 发生变化，但需要配合 DNS 插件使用。</li><li>ClusterIP：默认的类型，用于为集群内 Pod 访问时，提供的固定访问地址,默认是自动分配地址,可使用 ClusterIP 关键字指定固定 IP。</li><li>NodePort：基于 ClusterIp，用于为集群外部访问 Service 后面 Pod 提供访问接入端口。</li><li>LoadBalancer：它是基于 NodePort。</li></ul><h3 id="如何使用-K8s-来实现服务注册与发现"><a href="#如何使用-K8s-来实现服务注册与发现" class="headerlink" title="如何使用 K8s 来实现服务注册与发现"></a>如何使用 K8s 来实现服务注册与发现</h3><p>从上面讲的 Service，我们可以看到一种场景：所有的微服务在一个局域网内，或者说在一个 K8s 集群下，那么可以通过 Service 用于集群内 Pod 的访问，这就是 Service 默认的一种类型 ClusterIP，ClusterIP 这种的默认会自动分配地址。</p><p>那么问题来了，既然可以通过上面的 ClusterIp 来实现集群内部的服务访问，那么如何注册服务呢？其实 K8s 并没有引入任何的注册中心，使用的就是 K8s 的 kube-dns 组件。然后 K8s 将 Service 的名称当做域名注册到 kube-dns 中，通过 Service 的名称就可以访问其提供的服务。那么问题又来了，如果一个服务的 pod 对应有多个，那么如何实现 LB？其实，最终通过 kube-proxy，实现负载均衡。</p><p>说到这，我们来看下 Service 的服务发现与负载均衡的策略，Service 负载分发策略有两种：</p><ul><li>RoundRobin：轮询模式，即轮询将请求转发到后端的各个 pod 上，其为默认模式。</li><li>SessionAffinity：基于客户端 IP 地址进行会话保持的模式，类似 IP Hash 的方式，来实现服务的负载均衡。</li></ul><p>其实，K8s 利用其 Service 实现服务的发现，其实说白了，就是通过域名进行层层解析，最后解析到容器内部的 ip 和 port 来找到对应的服务，以完成请求。</p><p>下面写一个很简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: cas-server-service</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: cas-server01</span><br><span class="line">    port: 2000</span><br><span class="line">    targetPort: cas-server01</span><br><span class="line">  selector:</span><br><span class="line">    app: cas-server</span><br></pre></td></tr></table></figure><p>可以看到执行 <code>kubectl apply -f service.yaml</code> 后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ kubectl get svc</span><br><span class="line">NAME                          TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)              AGE</span><br><span class="line">admin-web-service             ClusterIP   10.16.129.24    &lt;none&gt;        2001&#x2F;TCP              84d</span><br><span class="line">cas-server-service            ClusterIP   10.16.230.167   &lt;none&gt;        2000&#x2F;TCP               67d</span><br><span class="line">cloud-admin-service-service   ClusterIP   10.16.25.178    &lt;none&gt;        1001&#x2F;TCP         190d</span><br></pre></td></tr></table></figure><p>这样，我们可以看到默认的类型是 ClusterIP，用于为集群内 Pod 访问时，可以先通过域名来解析到多个服务地址信息，然后再通过 LB 策略来选择其中一个作为请求的对象。</p><h3 id="K8s-如何来处理微服务中常用的配置"><a href="#K8s-如何来处理微服务中常用的配置" class="headerlink" title="K8s 如何来处理微服务中常用的配置"></a>K8s 如何来处理微服务中常用的配置</h3><p>在上面，我们讲过了几种创建 ConfigMap 的方式，其中有一种在 Java 中常常用到：通过创建 yml 文件来实现配置管理。</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">kind: ConfigMap</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: cas-server</span><br><span class="line">data:</span><br><span class="line">  application.yaml: |-</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the World</span><br><span class="line">    ---</span><br><span class="line">    spring:</span><br><span class="line">      profiles: dev</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Dev</span><br><span class="line">    spring:</span><br><span class="line">      profiles: test</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Test</span><br><span class="line">    spring:</span><br><span class="line">      profiles: prod</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Prod</span><br></pre></td></tr></table></figure><p>上面创建了一个 yml 文件，同时，通过 spring.profiles 指定了开发、测试、生产等每种环境的配置。</p><p>具体代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps&#x2F;v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: cas-server-deployment</span><br><span class="line">  labels:</span><br><span class="line">    app: cas-server</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: cas-server</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: cas-server</span><br><span class="line">    spec:</span><br><span class="line">      nodeSelector:</span><br><span class="line">        cas-server: &quot;true&quot;</span><br><span class="line">      containers:</span><br><span class="line">      - name: cas-server</span><br><span class="line">        image: &#123;&#123; cluster_cfg[&#39;cluster&#39;][&#39;docker-registry&#39;][&#39;prefix&#39;] &#125;&#125;cas-server</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        ports:</span><br><span class="line">          - name: cas-server01</span><br><span class="line">            containerPort: 2000</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: &#x2F;home&#x2F;cas-server</span><br><span class="line">          name: cas-server-path</span><br><span class="line">        args: [&quot;sh&quot;, &quot;-c&quot;, &quot;nohup java $JAVA_OPTS -jar -XX:MetaspaceSize&#x3D;128m -XX:MaxMetaspaceSize&#x3D;128m -Xms1024m -Xmx1024m -Xmn256m -Xss256k -XX:SurvivorRatio&#x3D;8 -XX:+UseConcMarkSweepGC cas-server.jar --spring.profiles.active&#x3D;dev&quot;, &quot;&amp;&quot;]</span><br><span class="line">      hostAliases:</span><br><span class="line">      - ip: &quot;127.0.0.1&quot;</span><br><span class="line">        hostnames:</span><br><span class="line">        - &quot;gemantic.localhost&quot;</span><br><span class="line">      - ip: &quot;0.0.0.0&quot;</span><br><span class="line">        hostnames:</span><br><span class="line">        - &quot;gemantic.all&quot;</span><br><span class="line">      volumes:</span><br><span class="line">      - name: cas-server-path</span><br><span class="line">        hostPath:</span><br><span class="line">          path: &#x2F;var&#x2F;pai&#x2F;cas-server</span><br></pre></td></tr></table></figure><p>这样，当我们启动容器时，通过 <code>--spring.profiles.active=dev</code> 来指定当前容器的活跃环境，即可获取 ConfigMap 中对应的配置。是不是感觉跟 Java 中的 Config 配置多个环境的配置有点类似呢？但是，我们不用那么复杂，这些统统可以交给 K8s 来处理。只需要你启动这一命令即可，是不是很简单？</p><h3 id="Spring-Boot-2-x-的新特性"><a href="#Spring-Boot-2-x-的新特性" class="headerlink" title="Spring Boot 2.x 的新特性"></a>Spring Boot 2.x 的新特性</h3><p>在第一节中，我们就讲到 1.x 与 2.x 的区别，其中最为凸显的是，Spring Boot 2.x 结合了 K8s 来实现微服务的架构设计。其实，在 K8s 中，更新 ConfigMap 后，pod 是不会自动刷新 configMap 中的变更，如果想要获取 ConfigMap 中最新的信息，需要重启 pod。</p><p>但 2.x 提供了自动刷新的功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cas-server</span><br><span class="line">  cloud:</span><br><span class="line">    kubernetes:</span><br><span class="line">      config:</span><br><span class="line">        sources:</span><br><span class="line">         - name: $&#123;spring.application.name&#125;</span><br><span class="line">           namespace: default</span><br><span class="line">      discovery:</span><br><span class="line">        all-namespaces: true</span><br><span class="line">      reload:</span><br><span class="line">        enabled: true</span><br><span class="line">        mode: polling</span><br><span class="line">        period: 500</span><br></pre></td></tr></table></figure><p>如上，我们打开了自动更新配置的开关，并且设置了自动更新的方式为主动拉取，时间间隔为 500ms，同时，还提供了另外一种方式——event 事件通知模式。这样，在 ConfigMap 发生改变时，无需重启 pod 即可获取最新的数据信息。</p><p>同时，Spring Boot 2.x 结合了 K8s 来实现微服务的服务注册与发现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-cloud-kubernetes-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-cloud-kubernetes-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>开启服务发现功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    kubernetes:</span><br><span class="line">      discovery:</span><br><span class="line">        all-namespaces: true</span><br></pre></td></tr></table></figure><p>开启后，我们在《<a href="https://www.damon8.cn/2020/07/23/micro-service03/">微服务 Spring Cloud 架构设计</a>》一文中讲过，其实最终是向 K8s 的 API Server 发起 http 请求，获取 Service 资源的数据列表。然后根据底层的负载均衡策略来实现服务的发现，最终解析到某个 pod 上。那么为了同一服务的多个 pod 存在，我们需要执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale --replicas&#x3D;2 deployment admin-web-deployment</span><br></pre></td></tr></table></figure><p>同时，我们如果通过 HTTP 的 RestTemplate Client 来作服务请求时，可以配置一些请求的策略，RestTemplate 一般与 Ribbon 结合使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">client:</span><br><span class="line">  http:</span><br><span class="line">    request:</span><br><span class="line">      connectTimeout: 8000</span><br><span class="line">      readTimeout: 3000</span><br><span class="line"></span><br><span class="line">backend:</span><br><span class="line">  ribbon:</span><br><span class="line">    eureka:</span><br><span class="line">      enabled: false</span><br><span class="line">    client:</span><br><span class="line">      enabled: true</span><br><span class="line">    ServerListRefreshInterval: 5000</span><br><span class="line"></span><br><span class="line">ribbon:</span><br><span class="line">  ConnectTimeout: 8000</span><br><span class="line">  ReadTimeout: 3000</span><br><span class="line">  eager-load:</span><br><span class="line">    enabled: true</span><br><span class="line">    clients: cas-server-service,admin-web-service</span><br><span class="line">  MaxAutoRetries: 1 #对第一次请求的服务的重试次数</span><br><span class="line">  MaxAutoRetriesNextServer: 1 #要重试的下一个服务的最大数量（不包括第一个服务）</span><br><span class="line">  #ServerListRefreshInterval: 2000</span><br><span class="line">  OkToRetryOnAllOperations: true</span><br><span class="line">  NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule #com.damon.config.RibbonConfiguration #分布式负载均衡策略</span><br></pre></td></tr></table></figure><p>可以配置一些服务列表，自定义一些负载均衡的策略。</p><p>如果你是使用 Feign 来作为 LB，其实与 Ribbon 只有一点点不一样，因为 Feign 本身是基于 Ribbon 来实现的，除了加上注解 @EnableFeignClients 后，还要配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">  client:</span><br><span class="line">    config:</span><br><span class="line">      default: #provider-service</span><br><span class="line">        connectTimeout: 8000 #客户端连接超时时间</span><br><span class="line">        readTimeout: 3000 #客户端读超时设置</span><br><span class="line">        loggerLevel: full</span><br></pre></td></tr></table></figure><p>其他的可以自定义负载均衡策略，这一点是基于 Ribbon 的，所以是一样的。</p><h3 id="实战-Spring-Boot-2-x-结合-K8s-来实现微服务架构设计"><a href="#实战-Spring-Boot-2-x-结合-K8s-来实现微服务架构设计" class="headerlink" title="实战 Spring Boot 2.x 结合 K8s 来实现微服务架构设计"></a>实战 Spring Boot 2.x 结合 K8s 来实现微服务架构设计</h3><p>微服务架构中，主要的就是服务消费者、服务的生产者可以互通，可以发生调用，在这基础上，还可以实现负载均衡，即一个服务调用另一个服务时，在该服务存在多个节点的情况下，可以通过一些策略来找到该服务的一个合适的节点访问。下面主要介绍服务的生产者与消费者。</p><p>先看生产者，引入常用的依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.13.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;relativePath&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">&lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">&lt;swagger.version&gt;2.6.1&lt;&#x2F;swagger.version&gt;</span><br><span class="line">&lt;xstream.version&gt;1.4.7&lt;&#x2F;xstream.version&gt;</span><br><span class="line">&lt;pageHelper.version&gt;4.1.6&lt;&#x2F;pageHelper.version&gt;</span><br><span class="line">&lt;fastjson.version&gt;1.2.51&lt;&#x2F;fastjson.version&gt;</span><br><span class="line">&lt;springcloud.version&gt;Greenwich.SR3&lt;&#x2F;springcloud.version&gt;</span><br><span class="line">&lt;springcloud.kubernetes.version&gt;1.1.1.RELEASE&lt;&#x2F;springcloud.kubernetes.version&gt;</span><br><span class="line">&lt;mysql.version&gt;5.1.46&lt;&#x2F;mysql.version&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;springcloud.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;exclusions&gt;</span><br><span class="line">&lt;exclusion&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;exclusion&gt;</span><br><span class="line">&lt;&#x2F;exclusions&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-undertow&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置加载依赖 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-actuator-autoconfigure&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-kubernetes-config&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.jsonwebtoken&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jjwt&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.9.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.hutool&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hutool-all&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.6.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.google.guava&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;guava&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;19.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-lang3&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-collections&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;swagger.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;swagger.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 数据库分页依赖 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.github.pagehelper&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;pagehelper&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;pageHelper.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.1&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;mysql.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 数据库驱动 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;fastjson.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.jsoup&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jsoup&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.11.3&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p>上面我们使用了比较新的版本：Spring Boot 2.1.13，Cloud 版本是 Greenwich.SR3，其次，我们配置了 K8s 的 ConfigMap 所用的依赖，加上了数据库的一些配置，具体其他的，实现过程中，大家可以自行添加。</p><p>接下来，我们看启动时加载的配置文件，这里加了关于 K8s ConfigMap 所管理的配置所在的信息，以及保证服务被发现，开启了所有的 namespace，同时还启动了配置自动刷新的功能，注意的是，该配置需要在 bootstrap 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cas-server</span><br><span class="line">  cloud:</span><br><span class="line">    kubernetes:</span><br><span class="line">      config:</span><br><span class="line">        sources:</span><br><span class="line">         - name: $&#123;spring.application.name&#125;</span><br><span class="line">           namespace: default</span><br><span class="line">      discovery:</span><br><span class="line">        all-namespaces: true #发现所有的命令空间的服务</span><br><span class="line">      reload:</span><br><span class="line">        enabled: true</span><br><span class="line">        mode: polling #自动刷新模式为拉取模式，也可以是事件模式 event</span><br><span class="line">        period: 500 #拉取模式下的频率</span><br><span class="line"></span><br><span class="line">logging: #日志路径设置</span><br><span class="line">  path: &#x2F;data&#x2F;$&#123;spring.application.name&#125;&#x2F;logs</span><br></pre></td></tr></table></figure><p>剩下的一些配置可以在 application 文件中配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 2000</span><br><span class="line">  undertow:</span><br><span class="line">    accesslog:</span><br><span class="line">      enabled: false</span><br><span class="line">      pattern: combined</span><br><span class="line">  servlet:</span><br><span class="line">    session:</span><br><span class="line">      timeout: PT120M #session 超时时间</span><br><span class="line"></span><br><span class="line">client:</span><br><span class="line">  http:</span><br><span class="line">    request:</span><br><span class="line">      connectTimeout: 8000</span><br><span class="line">      readTimeout: 30000</span><br><span class="line"></span><br><span class="line">mybatis: #持久层配置</span><br><span class="line">  mapperLocations: classpath:mapper&#x2F;*.xml</span><br><span class="line">  typeAliasesPackage: com.damon.*.model</span><br></pre></td></tr></table></figure><p>接下来看下启动类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *</span><br><span class="line"> * @author Damon</span><br><span class="line"> * @date 2020 年 1 月 13 日 下午 8:29:42</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(basePackages &#x3D; &#123;&quot;com.damon&quot;&#125;)</span><br><span class="line">&#x2F;&#x2F;@SpringBootApplication(scanBasePackages &#x3D; &#123; &quot;com.damon&quot; &#125;)</span><br><span class="line">@EnableConfigurationProperties(EnvConfig.class)</span><br><span class="line">public class CasApp &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(CasApp.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们没有直接用注解 @SpringBootApplication，因为主要用到的就是几个配置，没必要全部加载。</p><p>我们看到启动类中有一个引入的 EnvConfig.class：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author Damon</span><br><span class="line"> * @date 2019 年 10 月 25 日 下午 8:54:01</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ConfigurationProperties(prefix &#x3D; &quot;greeting&quot;)</span><br><span class="line">public class EnvConfig &#123;</span><br><span class="line"></span><br><span class="line">    private String message &#x3D; &quot;This is a dummy message&quot;;</span><br><span class="line"></span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return this.message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMessage(String message) &#123;</span><br><span class="line">        this.message &#x3D; message;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这就是配置 ConfigMap 中的属性的类。剩下的可以自己定义一个接口类，来实现服务生产者。</p><p>最后，我们需要在 K8s 下部署的话，需要准备几个脚本。</p><p><strong>1. 创建 ConfigMap</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">kind: ConfigMap</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: cas-server</span><br><span class="line">data:</span><br><span class="line">  application.yaml: |-</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the World</span><br><span class="line">    ---</span><br><span class="line">    spring:</span><br><span class="line">      profiles: dev</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Dev</span><br><span class="line">    spring:</span><br><span class="line">      profiles: test</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Test</span><br><span class="line">    spring:</span><br><span class="line">      profiles: prod</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Prod</span><br></pre></td></tr></table></figure><p>设置了不同环境的配置，注意，这里的 namespace 需要与服务部署的 namespace 一致，这里默认的是 default，而且在创建服务之前，先得创建这个。</p><p><strong>2. 创建服务部署脚本</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps&#x2F;v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: cas-server-deployment</span><br><span class="line">  labels:</span><br><span class="line">    app: cas-server</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: cas-server</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: cas-server</span><br><span class="line">    spec:</span><br><span class="line">      nodeSelector:</span><br><span class="line">        cas-server: &quot;true&quot;</span><br><span class="line">      containers:</span><br><span class="line">      - name: cas-server</span><br><span class="line">        image: cas-server</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        ports:</span><br><span class="line">          - name: cas-server01</span><br><span class="line">            containerPort: 2000</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: &#x2F;home&#x2F;cas-server</span><br><span class="line">          name: cas-server-path</span><br><span class="line">        - mountPath: &#x2F;data&#x2F;cas-server</span><br><span class="line">          name: cas-server-log-path</span><br><span class="line">        - mountPath: &#x2F;etc&#x2F;kubernetes</span><br><span class="line">          name: kube-config-path</span><br><span class="line">        args: [&quot;sh&quot;, &quot;-c&quot;, &quot;nohup java $JAVA_OPTS -jar -XX:MetaspaceSize&#x3D;128m -XX:MaxMetaspaceSize&#x3D;128m -Xms1024m -Xmx1024m -Xmn256m -Xss256k -XX:SurvivorRatio&#x3D;8 -XX:+UseConcMarkSweepGC cas-server.jar --spring.profiles.active&#x3D;dev&quot;, &quot;&amp;&quot;]</span><br><span class="line">      volumes:</span><br><span class="line">      - name: cas-server-path</span><br><span class="line">        hostPath:</span><br><span class="line">          path: &#x2F;var&#x2F;pai&#x2F;cas-server</span><br><span class="line">      - name: cas-server-log-path</span><br><span class="line">        hostPath:</span><br><span class="line">          path: &#x2F;data&#x2F;cas-server</span><br><span class="line">      - name: kube-config-path</span><br><span class="line">        hostPath:</span><br><span class="line">          path: &#x2F;etc&#x2F;kubernetes</span><br></pre></td></tr></table></figure><p>注意：这里有个属性 replicas，其作用是当前 pod 所启动的副本数，即我们常说的启动的节点个数，当然，你也可以通过前面讲的脚本来执行生成多个 pod 副本。如果这里没有设置多个的话，也可以通过命令来执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale --replicas&#x3D;3 deployment cas-server-deployment</span><br></pre></td></tr></table></figure><p>这里，我建议使用 Deployment 类型的来创建 pod，因为 Deployment 类型更好的支持弹性伸缩与滚动更新。</p><p>同时，我们通过 <code>--spring.profiles.active=dev</code> 来指定当前 pod 的运行环境。</p><p><strong>3. 创建一个 Service</strong></p><p>最后，如果服务想被发现，需要创建一个 Service：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: cas-server-service</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: cas-server01</span><br><span class="line">    port: 2000</span><br><span class="line">    targetPort: cas-server01</span><br><span class="line">  selector:</span><br><span class="line">    app: cas-server</span><br></pre></td></tr></table></figure><p>注意，这里的 namespace 需要与服务部署的 namespace 一致，这里默认的是 default。</p><p>看看服务的消费者，同样，先看引入常用的依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.13.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;relativePath&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">&lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">&lt;swagger.version&gt;2.6.1&lt;&#x2F;swagger.version&gt;</span><br><span class="line">&lt;xstream.version&gt;1.4.7&lt;&#x2F;xstream.version&gt;</span><br><span class="line">&lt;pageHelper.version&gt;4.1.6&lt;&#x2F;pageHelper.version&gt;</span><br><span class="line">&lt;fastjson.version&gt;1.2.51&lt;&#x2F;fastjson.version&gt;</span><br><span class="line">&lt;springcloud.version&gt;Greenwich.SR3&lt;&#x2F;springcloud.version&gt;</span><br><span class="line">&lt;!-- &lt;springcloud.version&gt;2.1.8.RELEASE&lt;&#x2F;springcloud.version&gt; --&gt;</span><br><span class="line">&lt;springcloud.kubernetes.version&gt;1.1.1.RELEASE&lt;&#x2F;springcloud.kubernetes.version&gt;</span><br><span class="line">&lt;mysql.version&gt;5.1.46&lt;&#x2F;mysql.version&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;springcloud.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;exclusions&gt;</span><br><span class="line">&lt;exclusion&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;exclusion&gt;</span><br><span class="line">&lt;&#x2F;exclusions&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-undertow&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 配置加载依赖 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-actuator-autoconfigure&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-kubernetes-config&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-commons&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 结合 k8s 实现服务发现 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-kubernetes-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-kubernetes-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 负载均衡策略 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-kubernetes-ribbon&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 熔断机制 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.hutool&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hutool-all&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.6.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;fastjson.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.jsoup&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jsoup&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.11.3&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;swagger.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;swagger.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-lang3&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-collections&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 数据库分页 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.github.pagehelper&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;pagehelper&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;pageHelper.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.1&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;mysql.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 数据库驱动 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p>这里大部分的依赖跟生产者一样，但，需要加入服务发现的依赖，以及所用的负载均衡的策略依赖、服务的熔断机制。</p><p>接下来 bootstrap 文件中的配置跟生产者一样，这里不在说了，唯一不同的是 application 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">backend:</span><br><span class="line">  ribbon:</span><br><span class="line">    eureka:</span><br><span class="line">      enabled: false</span><br><span class="line">    client:</span><br><span class="line">      enabled: true</span><br><span class="line">    ServerListRefreshInterval: 5000</span><br><span class="line"></span><br><span class="line">ribbon:</span><br><span class="line">  ConnectTimeout: 3000</span><br><span class="line">  ReadTimeout: 1000</span><br><span class="line">  eager-load:</span><br><span class="line">    enabled: true</span><br><span class="line">    clients: cas-server-service,edge-cas-service,admin-web-service #负载均衡发现的服务列表</span><br><span class="line">  MaxAutoRetries: 1 #对第一次请求的服务的重试次数</span><br><span class="line">  MaxAutoRetriesNextServer: 1 #要重试的下一个服务的最大数量（不包括第一个服务）</span><br><span class="line">  OkToRetryOnAllOperations: true</span><br><span class="line">  NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule #负载均衡策略</span><br><span class="line"></span><br><span class="line">hystrix:</span><br><span class="line">  command:</span><br><span class="line">    BackendCall:</span><br><span class="line">      execution:</span><br><span class="line">        isolation:</span><br><span class="line">          thread:</span><br><span class="line">            timeoutInMilliseconds: 5000 #熔断机制设置的超时时间</span><br><span class="line">  threadpool:</span><br><span class="line">    BackendCallThread:</span><br><span class="line">      coreSize: 5</span><br></pre></td></tr></table></figure><p>引入了负载均衡的机制以及策略（可以自定义策略）。</p><p>接下来看启动类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author Damon</span><br><span class="line"> * @date 2020 年 1 月 13 日 下午 9:23:06</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(basePackages &#x3D; &#123;&quot;com.damon&quot;&#125;)</span><br><span class="line">@EnableConfigurationProperties(EnvConfig.class)</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class AdminApp &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(AdminApp.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的 EnvConfig 类，这里不再展示了。其他的比如：注解 @EnableDiscoveryClient 是为了服务发现。</p><p>同样，我们新建接口，假如我们生产者有一个接口是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;cas-server-service&#x2F;api&#x2F;getUser</span><br></pre></td></tr></table></figure><p>则，我们在调用它时，可以通过 RestTemplate Client 来直接调用，通过 Ribbon 来实现负载均衡：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@LoadBalanced</span><br><span class="line">@Bean</span><br><span class="line">public RestTemplate restTemplate() &#123;</span><br><span class="line">SimpleClientHttpRequestFactory requestFactory &#x3D; new SimpleClientHttpRequestFactory();</span><br><span class="line">requestFactory.setReadTimeout(env.getProperty(&quot;client.http.request.readTimeout&quot;, Integer.class, 15000));</span><br><span class="line">requestFactory.setConnectTimeout(env.getProperty(&quot;client.http.request.connectTimeout&quot;, Integer.class, 3000));</span><br><span class="line">RestTemplate rt &#x3D; new RestTemplate(requestFactory);</span><br><span class="line">return rt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这种方式的分布式负载均衡实现起来很简单，直接注入一个初始化 Bean，加上一个注解 @LoadBalanced 即可。</p><p>在实现类中，我们只要直接调用服务生产者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;String&gt; forEntity &#x3D; restTemplate.getForEntity(&quot;http:&#x2F;&#x2F;cas-server&#x2F;api&#x2F;getUser&quot;, String.class);</span><br></pre></td></tr></table></figure><p>其中，URL 中 必须要加上 <code>&quot;http://&quot;</code>，这样即可实现服务的发现以及负载均衡，其中，LB 的策略，可以采用 Ribbon 的几种方式，也可以自定义一种。</p><p>最后，可以在实现类上加一个熔断机制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@HystrixCommand(fallbackMethod &#x3D; &quot;admin_service_fallBack&quot;)</span><br><span class="line">public Response&lt;Object&gt; getUserInfo(HttpServletRequest req, HttpServletResponse res) &#123;</span><br><span class="line"></span><br><span class="line">ResponseEntity&lt;String&gt; forEntity &#x3D; restTemplate.getForEntity(envConfig.getCas_server_url() + &quot;&#x2F;api&#x2F;getUser&quot;, String.class);</span><br><span class="line">        logger.info(&quot;test restTemplate.getForEntity(): &#123;&#125;&quot;, forEntity);</span><br><span class="line">        if (forEntity.getStatusCodeValue() &#x3D;&#x3D; 200) &#123;</span><br><span class="line">                logger.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;test restTemplate.getForEntity(): &#123;&#125;&quot;, JSON.toJSON(forEntity.getBody()));</span><br><span class="line">                logger.info(JSON.toJSONString(forEntity.getBody()));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中发生熔断时，回调方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private Response&lt;Object&gt; admin_service_fallBack(HttpServletRequest req, HttpServletResponse res) &#123;</span><br><span class="line">String token &#x3D; StrUtil.subAfter(req.getHeader(&quot;Authorization&quot;), &quot;bearer &quot;, false);</span><br><span class="line">logger.info(&quot;admin_service_fallBack token: &#123;&#125;&quot;, token);</span><br><span class="line">return Response.ok(200, -5, &quot;服务挂啦!&quot;, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其返回的对象必须与原函数一致，否则可能会报错。具体的可以参考《<a href="https://mp.weixin.qq.com/s/TcwAONaCexKIeT-63ClGsg" target="_blank" rel="noopener">Spring cloud 之熔断机制</a>》。</p><p>最后与生产者一样，需要创建 ConfigMap、Service、服务部署脚本，下面会开源这些代码，这里也就不一一展示了。最后，我们会发现：当请求 认证中心时，认证中心存在的多个 pod，可以被轮训的请求到。这就是基于 Ribbon 的轮训策略来实现分布式的负载均衡，并且基于 Redis 来实现信息共享。</p><h3 id="结束福利"><a href="#结束福利" class="headerlink" title="结束福利"></a>结束福利</h3><p>开源几个微服务的架构设计项目：</p><ul><li><a href="https://github.com/damon008/spring-cloud-oauth2" target="_blank" rel="noopener">https://github.com/damon008/spring-cloud-oauth2</a></li><li><a href="https://github.com/damon008/spring-cloud-k8s" target="_blank" rel="noopener">https://github.com/damon008/spring-cloud-k8s</a></li><li><a href="https://gitee.com/damon_one/spring-cloud-k8s" target="_blank" rel="noopener">https://gitee.com/damon_one/spring-cloud-k8s</a></li><li><a href="https://gitee.com/damon_one/spring-cloud-oauth2" target="_blank" rel="noopener">https://gitee.com/damon_one/spring-cloud-oauth2</a></li></ul><p>欢迎大家 star，多多指教。</p><h3 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h3><p>笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号<strong>程序猿 Damon</strong> 发起人。个人微信 <strong>MrNull008</strong>，欢迎來撩。</p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：程序猿Damon"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Unit one --><p><ins class="adsbygoogle"     style="display:inline-block;text-align:center;width:880px;height:150px"     data-ad-client="ca-pub-1354758384344627"     data-ad-slot="8964778819"></ins></p><script>    (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Volcano 作业资源预留设计原理解读</title>
    <link href="http://www.damon8.cn/2020/12/28/volcano-reserve/"/>
    <id>http://www.damon8.cn/2020/12/28/volcano-reserve/</id>
    <published>2020-12-28T06:37:04.000Z</published>
    <updated>2021-02-22T03:10:43.290Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Volcano 是一个基于 Kubernetes 的云原生批量计算平台，也是 CNCF 的首个批量计算项目。Volcano 主要用于 AI、大数据、基因、渲染等诸多高性能计算场景，对主流通用计算框架均有很好的支持。它提供高性能计算任务调度，异构设备管理，任务运行时管理等能力。本篇文章将深度剖析 Volcano 重要特性之——资源预留。</p><h3 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h3><p>在实际应用中，常见以下两种场景：</p><ul><li><p>在集群资源不足的情况下，假设处于待调度状态的作业 A 和 B，A 资源申请量小于 B 或 A 优先级高于 B。基于默认调度策略，A 将优先于 B 进行调度。在最坏的情况下，若后续持续有高优先级或申请资源量较少的作业加入待调度队列，B 将长时间处于饥饿状态并永远等待下去。</p></li><li><p>在集群资源不足的情况下，假设存在待调度作业 A 和 B。A 优先级低于 B 但资源申请量小于 B。在基于集群吞吐量和资源利用率为核心的调度策略下，A 将优先被调度。在最坏的情况下，B 将持续饥饿下去。</p></li></ul><p>以上两种场景出现的根因是缺少一种公平调度机制：<strong>保证长期处于饥饿状态的作业在达到某个临界条件后被优先调度</strong>。造成作业持久饥饿的原因很多，包括资源申请量长时间无法满足、优先级持续过低、抢占发生频率过高、亲和性无法满足（v1.1.0 暂不支持此场景）等，以资源申请量无法满足最为常见。</p><h3 id="特性设计"><a href="#特性设计" class="headerlink" title="特性设计"></a>特性设计</h3><p>为了保证长期处于阻塞状态的作业能够拥有公平的调度机会，需要解决两个主要问题：</p><ul><li><p>如何识别目标作业？</p></li><li><p>如何为目标作业预留资源？</p></li></ul><h3 id="目标作业识别"><a href="#目标作业识别" class="headerlink" title="目标作业识别"></a>目标作业识别</h3><h4 id="作业条件"><a href="#作业条件" class="headerlink" title="作业条件"></a>作业条件</h4><p>作业条件的选定可以基于等待时间、资源申请量等单个维度或多个维度的组合。综合考虑，v1.1.0 实现版本选择优先级最高且等待时间最长的作业作为目标作业。这样不仅可以保证紧急任务优先被调度，等待时间长度的考虑默认筛选出了资源需求较多的作业。</p><h4 id="作业数量"><a href="#作业数量" class="headerlink" title="作业数量"></a>作业数量</h4><p>客观来说，满足条件的作业通常不止一个，可以为目标作业组或单个目标作业预留资源。考虑到资源预留必然引起调度器性能在吞吐量和延时等方面的影响，v1.1.0 采用了单个目标作业的方式。</p><h4 id="识别方式"><a href="#识别方式" class="headerlink" title="识别方式"></a>识别方式</h4><p>识别方式有两种：自定义配置和自动识别。v1.1.0 暂时仅支持自动识别方式，即调度器在每个调度周期自动识别符合条件和数量的目标作业，并为其预留资源。后续版本将考虑在全局和 Queue 粒度支持自定义配置。</p><h3 id="资源预留算法"><a href="#资源预留算法" class="headerlink" title="资源预留算法"></a>资源预留算法</h3><p>资源预留算法是整个特性的核心。v1.1.0 采用节点组锁定的方式为目标作业预留资源，即选定一组符合某些约束条件的节点纳入节点组，节点组内的节点从纳入时刻起不再接受新作业投递，节点规格总和满足目标作业要求。需要强调的是，<strong>目标作业将可以在整个集群中进行调度，非目标作业仅可使用节点组外的节点进行调度</strong>。</p><h4 id="节点选取"><a href="#节点选取" class="headerlink" title="节点选取"></a>节点选取</h4><p>在特性设计阶段，社区考虑过以下节点选取算法：规格优先、空闲优先。</p><p><strong>规格优先</strong>是指集群中所有节点按照主要规格（目标作业申请资源规格）进行降序排序，选取前 N 个节点纳入节点组，这 N 个节点的资源总量满足申请量。这种方式的优点是实现简单、锁定节点数量最小化、对目标作业的调度友好（这种方式锁定的资源总量往往比申请总量大一些，且作业中各 Pod 容易聚集调度在锁定节点，有利于 Pod 间通信等）；缺点是锁定资源总量大概率不是最优解、综合调度性能损失（吞吐量、调度时长）、易产生大资源碎片。v1.1.0 的实现采用的是该算法。</p><p><strong>空闲优先</strong>是指集群中所有节点按照主要资源类型（目标作业申请资源类型）的空闲资源量进行降序排序，选取前 N 个节点纳入节点组，这 N 个节点的资源总量满足申请量。这种方式的优点是较大概率最快腾出满足要求的资源总量；缺点是集群空闲资源分布的强动态性导致节点组不是最优解，所求解稳定性差。</p><h4 id="节点数量"><a href="#节点数量" class="headerlink" title="节点数量"></a>节点数量</h4><p>为了尽可能减少锁定操作对调度器综合性能的影响，在满足预留资源申请量的前提下，无论采用哪种节点选取算法，都应保证所选节点数最少。</p><h4 id="锁定方式"><a href="#锁定方式" class="headerlink" title="锁定方式"></a>锁定方式</h4><p>锁定方式包括两个核心考量点：并行锁定数量、锁定节点已有负载处理手段。</p><p>并行锁定数量有三个选择：单节点锁定、多节点锁定、集群锁定。单节点锁定是指每个调度周期内基于当前集群资源分布选定一个符合要求的节点纳入节点组。这种方式可以尽量减少资源分布波动对所求解的稳定性的影响，缺点是要经过较多的调度周期才能完成锁定过程。v1.1.0 的实现选择的是这种方式。</p><p>以此类推，<strong>多节点锁定</strong>是指每个调度周期内选定 X（X&gt;1）个满足条件的节点进行锁定。这种方式能一定程度上弥补单节点锁定引入的锁定时长过长问题，缺点是 X 不易找到最优值，实现复杂度高。</p><p><strong>集群锁定</strong>是指一次性锁定集群所有节点，直至目标作业完成调度。这种粗暴的方式实现最为简单，目标作业等待时间最短，非常适合超大目标作业的资源预留。</p><p>锁定节点已有负载的处理手段有两种：抢占式预留、非抢占式预留。顾名思义，<strong>抢占式预留</strong>将会强制驱逐锁定节点上的已有负载。这种方式可以保证最快腾出所需的资源申请量，但会对已有业务造成重大影响，因此仅适用于紧急任务的资源预留。<strong>非抢占式预留</strong>则在节点锁定后不做任何处理，等待运行在其上的负载自行结束。v1.1.0 采用的是非抢占式预留。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>基于 v1.1.0 的实现，社区当前仅支持目标作业的自动化识别与资源预留。为此，新引入了 2 个 action 和 1 个 plugin。elect action 用于选取目标作业；reserve action 用于执行资源预留动作；reservation plugin 中实现了具体的目标选取和资源预留逻辑。</p><p>若要开启资源预留特性，将以上 action 和 plugin 配置到 volcano 的配置文件中即可。</p><p>下面是推荐配置样例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">actions:</span> <span class="string">"enqueue, elect, allocate, backfill, reserve"</span></span><br><span class="line"><span class="attr">tiers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">plugins:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">priority</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">gang</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">conformance</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">reservation</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">plugins:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">drf</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">predicates</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">proportion</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nodeorder</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">binpack</span></span><br></pre></td></tr></table></figure><p>自行配置时，请注意以下事项：</p><ul><li><p>elect action 必须配置在 enqueue action 和 allocate action 之间</p></li><li><p>reserve action 必须配置在 allocate action 之后</p></li></ul><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码：</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;">https://gitee.com/damon_one/spring-cloud-k8shttps://gitee.com/damon_one/spring-cloud-oauth2</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">程序猿Damon</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://www.damon8.cn" style="text-decoration: none" title="">Damon | Micro-Service | Containerization | DevOps</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：程序猿Damon"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Unit one --><p><ins class="adsbygoogle"     style="display:inline-block;text-align:center;width:880px;height:150px"     data-ad-client="ca-pub-1354758384344627"     data-ad-slot="8964778819"></ins></p><script>    (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Go 并发基础</title>
    <link href="http://www.damon8.cn/2020/12/23/study-go/"/>
    <id>http://www.damon8.cn/2020/12/23/study-go/</id>
    <published>2020-12-23T07:17:50.000Z</published>
    <updated>2021-02-22T03:10:43.559Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="协程（Goroutine）"><a href="#协程（Goroutine）" class="headerlink" title="协程（Goroutine）"></a>协程（Goroutine）</h4><p>我们知道 Go 中，存在一个 defer 关键字用于修饰一个函数或者方法，使得该函数或者方法在返回前才会执行，也就说被延迟执行，但又一定会执行。但其实 Go 中也存在类似的异步，或者说多线程的概念，但在 Go 中不叫作线程，而是叫协程。</p><p>协程相对于线程来说，是一个非常轻量级的东西，它在一个程序中，可以启动很多个。协程也称为 goroutine。goroutine 被 Go runtime 所调度，这一点和线程不一样。也就是说，Go 语言的并发是由 Go 自己所调度的，自己决定同时执行多少个 goroutine，什么时候执行哪几个。这些对于我们开发者来说很透明，只需要在编码的时候告诉 Go 语言要启动几个 goroutine，至于如何调度执行，我们不用关心。</p><p>启动一个 goroutine 简单，Go 语言为我们提供了 go 关键字，相比其他编程语言简化了很多，如代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">   go fmt.Println(&quot;码疯窝在香嗝喱辣&quot;)</span><br><span class="line"></span><br><span class="line">   fmt.Println(&quot;I am main goroutine&quot;)</span><br><span class="line"></span><br><span class="line">   time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就启动了一个 goroutine，用来调用 fmt.Println 函数，打印”码疯窝在香嗝喱辣”，所以这段代码里，其实有两个 goroutine，一个是 main 函数启动的 main goroutine，一个是通过 go 关键字启动的 goroutine。</p><p>也就是说，启动一个协程的关键字 go 即可，语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go function()</span><br><span class="line"></span><br><span class="line">go 函数执行体</span><br></pre></td></tr></table></figure><p>go 关键字后跟一个方法或者函数的调用，就可以启动一个 goroutine，让方法在这个新启动的 goroutine 中运行。运行以上示例，可以看到如下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I am main goroutine</span><br><span class="line"></span><br><span class="line">#待一秒的同时输出下面</span><br><span class="line"></span><br><span class="line">码疯窝在香嗝喱辣</span><br></pre></td></tr></table></figure><p>从输出结果也可以看出，程序是并发的，go 关键字启动的 goroutine 并不阻塞 main goroutine 的执行，所以我们看到如上打印。</p><p>在 Go 中，既然有了协程，那么这些协程之间如何通信呢？Go 提供了一个 <strong>channel（通道）</strong> 来解决。</p><h4 id="声明一个-channel"><a href="#声明一个-channel" class="headerlink" title="声明一个 channel"></a>声明一个 channel</h4><p>在 Go 语言中，声明一个 channel 非常简单，使用内置的 make 函数即可，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch:&#x3D;make(chan string)</span><br></pre></td></tr></table></figure><p>其中 chan 是一个关键字，表示是 channel 类型。后面的 string 表示 channel 里的数据是 string 类型。通过 channel 的声明也可以看到，chan 是一个集合类型。</p><p>定义好 chan 后就可以使用了，一个 chan 的操作只有两种：发送和接收:</p><ul><li><p>发送：向 chan 发送值，把值放在 chan 中，操作符为 chan &lt;-</p></li><li><p>接收：获取 chan 中的值，操作符为 &lt;- chan</p></li></ul><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">ch :&#x3D; make(chan string)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;码疯窝在香嗝喱辣&quot;)</span><br><span class="line"></span><br><span class="line">ch &lt;- &quot;发送数据者：码疯窝在香嗝喱辣&quot;</span><br><span class="line"></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;I am main goroutine&quot;)</span><br><span class="line"></span><br><span class="line">v :&#x3D; &lt;- ch</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;接收到的chan中的值为：&quot;,v)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>我们先来执行看看打印结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I am main goroutine</span><br><span class="line"></span><br><span class="line">码疯窝在香嗝喱辣</span><br><span class="line"></span><br><span class="line">接收到的chan中的值为：送数据者：码疯窝在香嗝喱辣</span><br></pre></td></tr></table></figure><p>从运行结果可以看出：达到了使用 time.Sleep 函数的效果。</p><p>相信应该明白为什么程序不会在新的 goroutine 完成之前退出了，因为通过 make 创建的 chan 中没有值，而 main goroutine 又想从 chan 中获取值，获取不到就一直等待，等到另一个 goroutine 向 chan 发送值为止。</p><h4 id="无缓冲-channel"><a href="#无缓冲-channel" class="headerlink" title="无缓冲 channel"></a>无缓冲 channel</h4><p>上面的示例中，使用 make 创建的 chan 就是一个无缓冲 channel，它的容量是 0，不能存储任何数据。所以无缓冲 channel 只起到传输数据的作用，数据并不会在 channel 中做任何停留。这也意味着，无缓冲 channel 的发送和接收操作是同时进行的，它也被称为同步 channel。</p><h4 id="有缓冲-channel"><a href="#有缓冲-channel" class="headerlink" title="有缓冲 channel"></a>有缓冲 channel</h4><p>有缓冲 channel 类似一个<strong>可阻塞的队列</strong>，内部的元素先进先出。通过 make 函数的第二个参数可以指定 channel 容量的大小，进而创建一个有缓冲 channel，如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cacheCh :&#x3D; make(chan int,5)</span><br></pre></td></tr></table></figure><p>定义了一个容量为 5 的元素为 int 类型的 chan。</p><p>一个有缓冲 channel 具备以下特点：</p><ul><li><p>有缓冲 channel 的内部有一个缓冲队列</p></li><li><p>发送操作是向队列的尾部插入元素，如果队列已满，则阻塞等待，直到另一个 goroutine 执行，接收操作释放队列的空间</p></li><li><p>接收操作是从队列的头部获取元素并把它从队列中删除，如果队列为空，则阻塞等待，直到另一个 goroutine 执行，发送操作插入新的元素</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cache :&#x3D; make(chan int,5)</span><br><span class="line"></span><br><span class="line">cache &lt;- 2</span><br><span class="line"></span><br><span class="line">cache &lt;- 3</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;容量:&quot;,cap(cache),&quot;,元素个数：&quot;,len(cache))</span><br></pre></td></tr></table></figure><p><strong>无缓冲 channel 其实就是一个容量大小为 0 的 channel。比如 make(chan int,0)</strong></p><br><h4 id="关闭-channel"><a href="#关闭-channel" class="headerlink" title="关闭 channel"></a>关闭 channel</h4><p>通过内置函数 close 即可关闭 channel。如果一个 channel 被关闭了，就不能向里面发送数据了，如果发送的话，会引起 painc 异常。但是还可以接收 channel 里的数据，如果 channel 里没有数据的话，接收的数据是元素类型的零值。</p><h4 id="单向-channel"><a href="#单向-channel" class="headerlink" title="单向 channel"></a>单向 channel</h4><p>所谓单向，即可要不发送，要么只能接收。所以单向 channel 的声明也很简单，只需要在声明的时候带上 &lt;- 操作符即可，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">send :&#x3D; make(chan &lt;- int)</span><br><span class="line">receive :&#x3D; make(&lt;- chan int)</span><br></pre></td></tr></table></figure><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码：</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;">https://gitee.com/damon_one/spring-cloud-k8shttps://gitee.com/damon_one/spring-cloud-oauth2</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">程序猿Damon</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://www.damon8.cn" style="text-decoration: none" title="">Damon | Micro-Service | Containerization | DevOps</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：程序猿Damon"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Unit one --><p><ins class="adsbygoogle"     style="display:inline-block;text-align:center;width:880px;height:150px"     data-ad-client="ca-pub-1354758384344627"     data-ad-slot="8964778819"></ins></p><script>    (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>云原生时代跨语言间微服务的打法</title>
    <link href="http://www.damon8.cn/2020/12/22/microservice-k8s/"/>
    <id>http://www.damon8.cn/2020/12/22/microservice-k8s/</id>
    <published>2020-12-22T10:28:34.000Z</published>
    <updated>2021-02-22T03:10:43.223Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-K8s-组件"><a href="#1-K8s-组件" class="headerlink" title="1. K8s 组件"></a>1. K8s 组件</h2><ul><li>configMap</li><li>kube-apiserver</li><li>scheduler</li><li>etcd</li><li>controller</li><li>kube-proxy</li></ul><p><img src="https://static001.geekbang.org/infoq/8d/8dc543a02801265b6ef2121b467f3bbf.jpeg" alt=""></p><br><p>K8s 中主要通过 kube-proxy 负责为 Service 提供 cluster 内部的服务发现和负载均衡，它是 K8s 集群内部的负载均衡器，也是一个分布式代理服务器，在 K8s 的每个节点上都有一个，这一设计体现了它的伸缩性优势，需要访问服务的节点越多，提供负载均衡能力的 kube-proxy 就越多，高可用节点也随之增多。通过 K8s service 的 “ClusterIP” 来实现集群内服务的 LB，当然，如果集群外需要访问 Service 对应的所有具有相同功能的 pod 应用程序，则可以通过 K8s service 的另外一种方式来实现：”NodePort”。</p><h2 id="2-基于-Service-实现微服务负载均衡"><a href="#2-基于-Service-实现微服务负载均衡" class="headerlink" title="2. 基于 Service 实现微服务负载均衡"></a>2. 基于 Service 实现微服务负载均衡</h2><p>在 Java 语言，或其它语言中，通常需要做很多繁重的组件来实现服务的 LB。例如：Dubbo、SpringCloud、甚至 SpringCloudAlibaba 等。当然，对于 Python、Go 等语言，也有其 Restful API，所以也会集成标准的代理插件来进行做传统的 LB。但对于云原生时代的到来，服务容器化让微服务的访问更好了。K8s Service 提供的 LB，即为无语言边际的负载均衡，不用考虑任何语言的阻碍，只要是通用的 Restful API，即可借助 service 来进行处理集群内部微服务之间的 LB。</p><p>在 K8s 集群中，如果内部访问，可以简单的通过 servicename 来进行访问。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: web-server-service</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - name: web-server</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: web-server-port</span><br><span class="line">  selector:</span><br><span class="line">    app: web-server</span><br></pre></td></tr></table></figure><p>通过 <strong>selector</strong> 将 service 与服务 pod 对应起来，创建一个微服务的 service，默认其形式是：ClusterIP，则可以通过如下来访问该 service 对应的后端 pod:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;$service_name.$namespace.svc.cluster.local:$service_port&#x2F;api&#x2F;v1&#x2F;***</span><br></pre></td></tr></table></figure><br><p>这里，K8s 通过虚拟出一个集群 IP，利用 kube-proxy 为 service 提供 cluster 内的服务发现和负载均衡，上面说了 kube-proxy 的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Name:              web-server-service</span><br><span class="line">Namespace:         default</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP:                20.16.249.134</span><br><span class="line">Port:              &lt;unset&gt;  80&#x2F;TCP</span><br><span class="line">TargetPort:        80&#x2F;TCP</span><br><span class="line">Endpoints:         20.162.35.223:80</span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br></pre></td></tr></table></figure><h2 id="3-高可用案例"><a href="#3-高可用案例" class="headerlink" title="3. 高可用案例"></a>3. 高可用案例</h2><h3 id="3-1-传统微服务请求案例"><a href="#3-1-传统微服务请求案例" class="headerlink" title="3.1 传统微服务请求案例"></a>3.1 传统微服务请求案例</h3><p>传统的微服务中，不同语言构建的微服务架构很多，一般直接通过 http 协议进行访问，在同一种语言中，又会出现一种集成框架模式来实现微服务架构。如：Java 中 Dubbo、Springcloud 等，但其繁琐的框架结构导致了服务的繁重。</p><h3 id="3-2-跨语言间微服务的互通"><a href="#3-2-跨语言间微服务的互通" class="headerlink" title="3.2 跨语言间微服务的互通"></a>3.2 跨语言间微服务的互通</h3><p>在 k8s 集群内，通过 kube-proxy 结合 service 等一些功能组件来实现微服务之间的调用，不管是同语言也好，跨语言也罢。都会很好的进行处理，包括实现高可用以及负载均衡、服务治理等。</p><br><p>任何一个 k8s 集群中的 pod 都可以通过 http 协议来访问其它 pod 的服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@rest-server-ver2-ds-vcfc7:&#x2F;usr&#x2F;src&#x2F;app# curl http:&#x2F;&#x2F;web-server-service.kube-system.svc.cluster.local:80&#x2F;api&#x2F;v1&#x2F;healthz</span><br><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: &#123;</span><br><span class="line">    &quot;code&quot;: 0,</span><br><span class="line">    &quot;msg&quot;: &quot;success&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;data&quot;: &quot;success&quot;</span><br><span class="line">&#125;root@rest-server-ver2-ds-vcfc7:&#x2F;usr&#x2F;src&#x2F;app#</span><br></pre></td></tr></table></figure><p>其中的权限有的可以通过 namespace 来控制，有的可以通过服务本身的访问权限来控制，但一切都可以进行访问，不存在语言的差别对待。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码：</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;">https://gitee.com/damon_one/spring-cloud-k8shttps://gitee.com/damon_one/spring-cloud-oauth2</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">程序猿Damon</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://www.damon8.cn" style="text-decoration: none" title="">Damon | Micro-Service | Containerization | DevOps</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：程序猿Damon"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Unit one --><p><ins class="adsbygoogle"     style="display:inline-block;text-align:center;width:880px;height:150px"     data-ad-client="ca-pub-1354758384344627"     data-ad-slot="8964778819"></ins></p><script>    (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
