[{"title":"ArrayList、LinkedList 你真的了解吗？","date":"2020-07-21T00:17:35.442Z","path":"2020/07/21/hello-world/","text":"1、 前言 经常在面试时，被问到集合的概念，集合 List、Map、Set 等底层设计以及其使用场景与注意细节。但大部分人的回答都是千篇一律，跟网上的答案一模一样，这是致命滴。其实，大家都错了，尤其是网上，更是误导大家，详细原因，且听我来分析。 2、集合 List 2.1 大家心中的 List在广大的网友心中，List 是一个缓存数据的容器，是 JDK 为开发者提供的一种集合类型。面试时，被问到最常见的就是 ArrayList 和 LinkedList 的区别。 相信大部分网友都能回答上：ArrayList 是基于数组实现，LinkedList 是基于链表实现。而在使用场景时，我发现大部分网友的答案都是：在新增、删除操作时，LinkedList 的效率要高于 ArrayList，而在查询、遍历操作的时候，ArrayList 的效率要高于 LinkedList。这个答案是否准确呢？今天就带大家验证一哈。 2.2 性能比较首先，大家都知道 ArrayList、LinkedList 都继承了 AbstractList 抽象类，而 AbstractList 实现了 List 接口。ArrayList 使用数组实现，而 LinkedList 使用了双向链表实现。接下来，我们就详细地分析下 ArrayList 和 LinkedList 的性能。 123public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 在源码中，我们知道 ArrayList 除了实现克隆和序列化，还实现了 RandomAccess 接口。大家可能会对这个接口比较陌生，通过代码我们可以发现，这个接口其实是一个空接口，没有实现逻辑，那么 ArrayList 为什么要实现它呢？原来 RandomAccess 接口是一个标志接口，它标志着只要实现该接口，就能实现快速随机访问。 至于 ArrayList、LinkedList 的各种操作方法这里不再说了，大家可以看 这一篇。 接下来，我们看看一些测试数据，以测试 50000 次为例： ArrayList、LinkedList 新增测试 123头部：ArrayList.Time 大于 LinkedList.Time中间：ArrayList.Time 小于 LinkedList.Time末尾：ArrayList.Time 小于 LinkedList.Time 通过这测试，我们可以看到 LinkedList 新增元素的未必要快于 ArrayList。 由于 ArrayList 是数组实现的，而数组是一块连续的内存空间，在新增元素到数组头部的时候，需要对头部以后的数据进行重排，所以效率很低。而 LinkedList 是基于链表实现，在新增元素的时候，首先会通过循环查找到新增元素的位置，如果要新增的位置处于前半段，就从前往后找；若其位置处于后半段，就从后往前找。故 LinkedList 新增元素到头部是非常高效的。 在中间位置插入时，ArrayList 同样有部分数据需要重排，效率也不是很高，而 LinkedList 将元素新增到中间，耗时最久的，因为靠近中间位置，在新增元素之前的循环查找是遍历元素最多的操作。 而在尾部操作时，发现在没有扩容的前提下，ArrayList 的效率要高于 LinkedList。这是因为 ArrayList 在新增元素到尾部的时候，不需要复制、重排，效率非常高。而 LinkedList 虽然也不用循环查找元素，但 LinkedList 中多了 new 对象以及变换指针指向对象的逻辑，所以要耗时多于 ArrayList 的操作。 12345678910111213141516 public boolean add(E e) &#123; linkLast(e); return true;&#125;void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; ArrayList、LinkedList 删除测试 123头部：ArrayList.Time 大于 LinkedList.Time中间：ArrayList.Time 小于 LinkedList.Time末尾：ArrayList.Time 小于 LinkedList.Time 大家会发现 ArrayList 和 LinkedList 删除操作的测试结果和新增的结果很接近，这是一样的道理，我就不赘述了。 ArrayList、LinkedList 遍历测试 12for循环：ArrayList.Time 小于 LinkedList.Time迭代器：ArrayList.Time 几乎等于 LinkedList.Time 我们可以看到，LinkedList 的 for 循环遍历比不上 ArrayList 的 for 循环。这是因为 LinkedList 基于链表实现的，在使用 for 循环的时候，每一次 for 循环都会去遍历大半个 List，所以严重影响了遍历的效率。而 ArrayList 是基于数组实现的，并且实现了 RandomAccess 接口标志，意味着 ArrayList 可以实现快速随机访问，所以 for 循环非常快。LinkedList 的迭代遍历和 ArrayList 的迭代性能差不多，也不会太差，所以在遍历 LinkedList 时，我们要使用迭代循环遍历。 3、常错点 思考在一次 ArrayList 删除操作的过程中，有下面两种写法： 12345678public static void removeA(ArrayList&lt;String&gt; l) &#123; for (String s : l)&#123; if (s.equals(&quot;aaa&quot;)) &#123; l.remove(s); &#125; &#125;&#125; 1234567891011public static void removeB(ArrayList&lt;String&gt; l) &#123; Iterator&lt;String&gt; it &#x3D; l.iterator(); while (it.hasNext()) &#123; String str &#x3D; it.next(); if (str.equals(&quot;aaa&quot;)) &#123; it.remove(); &#125; &#125;&#125; 第一种写法错误，第二种是正确的，原因是上面的两种写法都有用到 list 内部迭代器Iterator，即遍历时，ArrayList 内部创建了一个内部迭代器 iterator，在使用 next 方法来取下一个元素时，会使用 ArrayList 里保存的一个用来记录 list 修改次数的变量 modCount，与 iterator 保存了一个叫 expectedModCount 的表示期望的修改次数进行比较，如果不相等则会抛出一个叫 ConcurrentModificationException 的异常。且在 for 循环中调用 list 中的 remove 方法，会走到一个 fastRemove 方法，该方法不是 iterator 中的方法，而是 ArrayList 中的方法，在该方法只做了 modCount++，而没有同步到 expectedModCount。所以不一致就抛出了 ConcurrentModificationException 异常了。 下面是 ArrayList 自己的remove 方法： 12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125; 12345678private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 如果有看过阿里 Java 编程规范就知道，在集合中进行 remove 操作时，不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。 结束福利 开源实战利用 k8s 作微服务的架构设计代码: https://gitee.com/damon_one/spring-cloud-k8s 欢迎大家 star，多多指教。 关于作者 笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 docker、k8s 做微服务容器化，自动化部署等一站式项目部署、落地。Go 语言学习，k8s 研究，边缘计算框架 KubeEdge 等。公众号 程序猿Damon 发起人。个人微信 MrNull008，欢迎來撩。 欢迎关注：InfoQ 欢迎关注：腾讯自媒体专栏 欢迎关注","tags":[]},{"title":"首发基于OpenPAI细化部署 Hadoop 集群","date":"2020-07-18T06:34:34.000Z","path":"2020/07/18/hadoop-deploy/","text":"前提 https://github.com/microsoft/pai/tree/v0.14.0 Hadoop 2.9.0 k8s 1.9.4 (高版本未测) 本次讲解的主要是基于 Microsoft 开源的 OpenPAI，向大家通俗易懂的讲解 OpenPAI 是如何快速部署 Hadoop 集群的。便于大家快速部署Hadoop集群。 环境：1234ubuntu 16.04docker 18.06k8s 1.9.4Hadoop 2.9.0 1. 准备分析以上系统环境准备好，首先克隆 Microsoft 开源的 OpenPAI 的代码: https://github.com/microsoft/pai，切换到分支 v0.14.0。 由于我的目录在 /home/damon 下，所以直接: 12cd &#x2F;home&#x2F;damon&#x2F;paill 可以看到有如下目录: 其中，src 目录下都是一些代码目录以及脚本： 看着很多，其实我们只要看 quick-start 下的几个文件: 1234sudo vi deployment&#x2F;quick-start&#x2F;quick-start-example.yaml #配置master节点信息sudo vi deployment&#x2F;quick-start&#x2F;kubernetes-configuration.yaml.template #不作大改sudo vi deployment&#x2F;quick-start&#x2F;layout.yaml.template #增加机器相关信息sudo vi deployment&#x2F;quick-start&#x2F;services-configuration.yaml.template #配置docker相关信息 第一个配置文件主要是关于 master 节点。第二个配置主要是配置 k8s 的基本信息，因为 OpenPAI 不仅可以部署 Hadoop，还可以基于 Docker、python 来部署 k8s。第三个配置主要是增加机器的信息，我们需要修改的是配置 master 节点的信息，至于 node 节点，我们可以通过打标签的方式来。第四个配置主要是配置 docker 信息，存储 image 的各种 tag 形式。 根据配置模板生成配置文件1sudo python paictl.py config generate -i deployment&#x2F;quick-start&#x2F;quick-start-example.yaml -o ~&#x2F;damon&#x2F;pai-config -f 把生成的本地配置文件推送到远程 k8s 集群1sudo python paictl.py config push -p ~&#x2F;damon&#x2F;pai-config&#x2F; 执行上面的命令时，会出现输入命令，意思是让你输入一个 cluster-id，这是 OpenPAI 为集群设置的一个 id。输入后回车即可把配置推送到远程了。 获取 cluster-id如果生成过，执行 12damon@master:~&#x2F;damon&#x2F;pai$ sudo python paictl.py config get-id2020-07-16 19:56:48,066 [INFO] - deployment.confStorage.get_cluster_id : Cluster-id is: ustc 即可获取。 重点以上配置都结束后，上面说过了，配置中只有 master 节点信息，需要手动给 node 节点打标签: 1kubectl label node nodeName hdfsrole&#x3D;master 同样的标签还有类似: 123master labels:hdfsrole&#x3D;master,jobhistory&#x3D;true,launcher&#x3D;true,node-exporter&#x3D;true,pai-master&#x3D;true,yarnrole&#x3D;master,zookeeper&#x3D;true 12node labels:gpu-check&#x3D;true,hdfsrole&#x3D;worker,node-exporter&#x3D;true,pai-worker&#x3D;true,yarnrole&#x3D;worker 打完标签后，即可开始部署 Hadoop 集群了。 部署 Hadoop部署 Hadoop 的命令: 1sudo python paictl.py service start [-c &#x2F;path&#x2F;to&#x2F;kubeconfig] [ -n service-name ] 解释：-c 参数中带的是 k8s 授权的 kube-config 路径，-n 参数是服务名，如果没带 -n，则会默认启动 src 下的所有的服务。 Hadoop 中主要有这些服务: 1234567zookeeperhadoop-name-nodehadoop-data-nodehadoop-resource-managerhadoop-node-managerhadoop-batch-jobhadoop-jobhistory 那就手动一个个执行吧。执行一个后看看 pod 有没有启动，相关的 configmap 有没有创建，默认都是官方的。 注意项如果发现 namenode 启用了安全模式，而不想启用的话，执行: 12kubectl exec -it hadoop-name-node-e3bw9 bashhadoop dfsadmin -safemode leave 即：进入 name-node 容器中执行关闭。 模块功能说明 resource-manager 是调度中心，负责资源管理。 node-manager 是容器启动的的执行者。通常异常情况需要重启 node-manager。 zookeeper 为数据的存储中心。 namenode 和 datanode 为 hadoop 服务（HDFS）的基础层。 模块运维方法说明 resource-manager 重启：大量任务 waiting 和 stopping 和数据不一致等情况。 node-manager 重启：更新节点的资源信息或者节点故障等。 结束福利 开源实战利用 k8s 作微服务的架构设计代码： https://gitee.com/damon_one/spring-cloud-k8s https://gitee.com/damon_one/spring-cloud-oauth2 欢迎大家 star，多多指教。 关于作者 笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 docker、k8s 做微服务容器化，自动化部署等一站式项目部署、落地。Go 语言学习，k8s 研究，边缘计算框架 KubeEdge 等。公众号 程序猿Damon 发起人。个人微信 MrNull008，欢迎來撩。 欢迎关注：InfoQ 欢迎关注：腾讯自媒体专栏","tags":[]},{"title":"微服务自动化部署CI/CD","date":"2020-07-14T12:03:14.000Z","path":"2020/07/14/ci-cd/","text":"一直有人说想了解微服务的自动化部署，今天它来了。 在微服务化的时代，自动化部署越来越成为企业的重中之重了，因为这样减少了人员的成本，开发人员将代码提交后，触发相关事件即可部署测试环境，甚至得到许可后部署到线上。这样，原先开发人员、运维人员等要做的事，通通不必再重复劳作了。这对于一个企业来说，leader比较在乎的一件事。今天讲解通过jenkins、gitlab、harbor、k8s来作简单的CI/CD平台，暂时未涉及到代码检测等。 环境：123ubuntu16.04docker18.04k8s1.13.x + 1. 准备以上系统环境准备好，本文讲述的是用 k8s 来进行部署 jenkins 2. 部署 jenkins新建部署脚本 jenkins.yaml: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263apiVersion: v1kind: Servicemetadata: name: jenkins-service namespace: default labels: app: jenkinsspec: type: NodePort ports: - port: 8080 targetPort: 8080 protocol: TCP nodePort: 30600 name: jenkins - port: 30000 targetPort: 30000 nodePort: 30000 protocol: TCP name: agent selector: app: jenkins tier: jenkins---apiVersion: apps&#x2F;v1kind: Deploymentmetadata: name: jenkins-deployment labels: app: jenkinsspec: replicas: 1 strategy: type: Recreate template: metadata: labels: app: jenkins tier: jenkins spec: containers: - name: jenkins image: jenkinsci&#x2F;blueocean:latest imagePullPolicy: Always ports: - containerPort: 8080 name: jenkins - containerPort: 30000 name: agent volumeMounts: - mountPath: &#x2F;var&#x2F;jenkins_home name: jenkins-data - mountPath: &#x2F;data&#x2F;jenkins name: jenkins-log-path volumes: - name: jenkins-data hostPath: path: &#x2F;home&#x2F;demo&#x2F;jenkins - name: jenkins-log-path hostPath: path: &#x2F;data&#x2F;jenkins 执行脚本： 1kubectl apply -f jenkins.yaml 查看部署成功的 pod 1kubectl get pod 同时会看到一个 service 生成，映射端口到外部。 接下来通过页面访问该服务，首次打开后，会让输入一个 admin 的密钥，这一串字符可以在日志中找到，执行 kubectl logs -f test-jenkins-c6bd58bf9-tgmsa 即可，输入一串字符后，进入下一步，需要安装一些插件，在安装插件的时候，需要注意的是，选择 jenkins 的 image 不同，其所需安装的插件也是不一样的，有的可能 image 已经存在了。具体请看：https://jenkins.io/zh/doc/book/installing/ 安装完插件后，进入下一步，创建第一个账户，管理员账户，一般建议创建，方便后面使用，注：邮箱也需要填写。 完成以上后，我们进入正式界面： 第一步：点击系统管理—&gt;插件管理，添加一些插件，这里有用到kubernetes的插件，故安装了kubernetes plugins，其他的可根据自行项目确定下载、安装。 第二步：点击系统管理—&gt;系统设置 添加jenkins的地址以及邮件地址 第三步：拉动滚动框到最下面，新增一个云 这里我加了kubernetes的配置，为什么后面会讲。 第四步：新建任务 在触发器中新增规则，最下面要生成token。 第五步： 接下来就是选择与gitlab互动，gitlab的地址以及凭据，凭据可通过首页加上可访问gitlab的用户信息，脚本路径需要根据自身的Jenkinsfile路径情况填写。 第六步： 如果启用全局安全，这个端口本身是50000，但由于k8s的默认nodePort范围是30000-32767，故可以修改在这区间内，比如：30000，这也是为什么上面创建时service的nodePort是30000了。 至此，jenkins环境配置完成 第七步：配置gitlab 这里的url就是在新建任务时生成的Gitlab webhook，token就是上面截图生成的token，最后add webhook。 第八步： 关于Harbor，自己可以简单搭建一个harbor服务，找度娘问一下很多，此处略。 第九步： 新建Jenkinsfile文件，如果刚才的路径是在项目根目录，则直接在项目根目录下创建Jenkinsfile文件: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960def label &#x3D; &quot;mypod-$&#123;UUID.randomUUID().toString()&#125;&quot;def k8sPodYaml &#x3D; &quot;&quot;&quot; apiVersion: &quot;v1&quot; kind: &quot;Pod&quot; metadata: labels: jenkins: &quot;slave&quot; name: &quot;$&#123;label&#125;&quot; spec: containers: - env: - name: &quot;CI_ENV&quot; value: &quot;YES&quot; - name: &quot;JENKINS_AGENT_WORKDIR&quot; value: &quot;&#x2F;home&#x2F;jenkins&#x2F;agent&quot; image: &quot;jenkins&#x2F;jnlp-slave&quot; imagePullPolicy: &quot;Always&quot; name: &quot;jnlp&quot; resources: limits: &#123;&#125; requests: &#123;&#125; securityContext: privileged: false tty: false volumeMounts: - mountPath: &quot;&#x2F;home&#x2F;jenkins&#x2F;.kube&quot; name: &quot;volume-2&quot; readOnly: false - mountPath: &quot;&#x2F;var&#x2F;run&#x2F;docker.sock&quot; name: &quot;volume-0&quot; readOnly: false - mountPath: &quot;&#x2F;var&#x2F;inference&#x2F;config&quot; name: &quot;volume-1&quot; readOnly: false - mountPath: &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;kubectl&quot; name: &quot;volume-3&quot; readOnly: false - mountPath: &quot;&#x2F;home&#x2F;jenkins&#x2F;agent&quot; name: &quot;workspace-volume&quot; readOnly: false workingDir: &quot;&#x2F;home&#x2F;jenkins&#x2F;agent&quot; nodeSelector: &#123;&#125; restartPolicy: &quot;Never&quot; volumes: - hostPath: path: &quot;&#x2F;var&#x2F;run&#x2F;docker.sock&quot; name: &quot;volume-0&quot; - hostPath: path: &quot;&#x2F;home&#x2F;leinao&#x2F;.kube&quot; name: &quot;volume-2&quot; - hostPath: path: &quot;&#x2F;home&#x2F;leinao&#x2F;inference-deploy&#x2F;output_config&quot; name: &quot;volume-1&quot; - emptyDir: &#123;&#125; name: &quot;workspace-volume&quot; - hostPath: path: &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;kubectl&quot; name: &quot;volume-3&quot; 下面是自己的任务构建项目时的逻辑，由于我们这块用了自己的框架写的编译逻辑，故比较简单的，这里不合适公开，但是逻辑都差不多，大家可自行编写。 这块解释上面的k8s的yaml，这个就是为了在k8s中启动一个pod，通过该pod来执行构建逻辑的过程。 到此，关于Jenkins结合harbor、gitlab、k8s来实现CI/CD结束了，有几点注意的地方： 1. 如果jenkins是在容器中启动的一定要记得将这个端口(30000)暴露到外部，不然jenkins-master会不知道slave是否已经启动，会反复去创建pod只到超过重试次数。 2. 如果提示Jenkins doesn’t have label jenkins-jnlp-slave，可能原因： 1). 因为slave节点无法链接到jenkins节点开放端口50000导致 2). 因为slave镜像中slave启动失败导致的 3). 因为jenkins和k8s通信有延时导致超时jenkins会反复创建pod 4). 因为slave pod启动失败 5). 因为pipeline中指定的label与配置中的不一致导致 3. 也可以通过Ingress暴露的方式来进行暴露。 结束福利 开源实战利用 k8s 作微服务的架构设计代码： https://gitee.com/damon_one/spring-cloud-k8s https://gitee.com/damon_one/spring-cloud-oauth2 欢迎大家 star，多多指教。 关于作者 笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 docker、k8s 做微服务容器化，自动化部署等一站式项目部署、落地。Go 语言学习，k8s 研究，边缘计算框架 KubeEdge 等。公众号 程序猿Damon 发起人。个人微信 MrNull008，欢迎來撩。 欢迎关注：InfoQ 欢迎关注：腾讯自媒体专栏","tags":[]},{"title":"Nginx 日常操作","date":"2020-07-14T07:05:15.000Z","path":"2020/07/14/nginx/","text":"Ubuntu 下 Nginx 安装 先下载相关文件: cd /usr/local/src sudo 模式下 wget http://nginx.org/download/nginx-1.10.2.tar.gz wget http://www.openssl.org/source/openssl-fips-2.0.10.tar.gz wget http://zlib.net/zlib-1.2.11.tar.gz wget https://netix.dl.sourceforge.net/project/pcre/pcre/8.40/pcre-8.40.tar.gz 安装nginx相关组件: 安装openssl sudo tar zxvf openssl-fips-2.0.10.tar.gz cd openssl-fips-2.0.10 sudo ./config && make && make install 安装pcre: sudo tar zxvf pcre-8.40.tar.gz cd pcre-8.40 sudo ./configure && make && make install 安装zlib: sudo tar zxvf zlib-1.2.11.tar.gz cd zlib-1.2.11 sudo ./configure && make && make install 安装nginx: sudo tar zxvf nginx-1.10.2.tar.gz cd nginx-1.10.2 sudo ./configure && make && make install 启动nginx: /usr/local/nginx/sbin/nginx 查看nginx是否启动成功: netstat -lnp 查看 nginx 的测试，以及相关配置: nginx -t nginx 默认的日志位置: tail -f /var/log/nginx/access.log 加配置: sudo /usr/local/nginx/sbin/nginx sudo /usr/local/nginx/sbin/nginx -s stop(quit、reload) sudo /usr/local/nginx/sbin/nginx -h sudo vi /usr/local/nginx/conf/nginx.conf Ubuntu 下 Nginx 完全卸载 先暂停 nginx 服务 1sudo service nginx stop 删除 nginx，–purge 包括配置文件: 1sudo apt-get --purge remove nginx 移除全部不使用的软件包: 1sudo apt-get autoremove 列出与 nginx 相关的软件 并删除显示的软件: 12345dpkg --get-selections|grep nginxsudo apt-get --purge remove nginxsudo apt-get --purge remove nginx-commonsudo apt-get --purge remove nginx-core 结束福利 开源实战利用 k8s 作微服务的架构设计代码： https://gitee.com/damon_one/spring-cloud-k8s https://gitee.com/damon_one/spring-cloud-oauth2 欢迎大家 star，多多指教。 关于作者 笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 docker、k8s 做微服务容器化，自动化部署等一站式项目部署、落地。Go 语言学习，k8s 研究，边缘计算框架 KubeEdge 等。公众号 程序猿Damon 发起人。个人微信 MrNull008，欢迎來撩。 欢迎关注：InfoQ 欢迎关注：腾讯自媒体专栏","tags":[]},{"title":"Spring cloud 之熔断机制（实战）","date":"2020-07-10T06:16:14.000Z","path":"2020/07/10/springcloud-04/","text":"前面讲过 Spring cloud 之多种方式限流（实战）来处理请求频繁的压力。大家都知道，多个微服务之间调用的时候，假设微服务 A 调用微服务 B 和微服务 C，微服务 B 和微服务 C 有调用其他的微服务，这就是所谓的 扇出，若扇出的链路上某个微服务的请求时间过长或者不可用，对微服务 A 的调用就会占用越来越多的时间以及更多资源，进而引起系统雪崩，即”雪崩效应”。 这个时候，需要一个机制来保证当某个微服务出现异常时（请求反应慢或宕机），其整个流程还是阔以友好滴进行下去。即向调用方返回一个符合预期的、可处理的备选响应(FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常，这样就可以保证调用方的线程不会被长时间、无厘头滴占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。我们把这个机制，或者这种处理方式叫作“熔断器”。 熔断机制是应对雪崩效应的一种微服务链路保护机制，当整个链路的某个微服务异常时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回“合理”的响应信息。当检测到该节点微服务正常后恢复调用链路，在Spring cloud 框架机制通过 Hystrix 实现，Hystrix 会监控微服务见调用的状况，当失败的调用到一个阈值，默认是5秒内20次调用失败就会启动熔断机制，熔断机制的注解是 @HystrixCommand。 最近研究了一下 Spring cloud 的熔断机制，特分享一些代码，以及实战中的坑。 在Spring cloud 中，假设有几个微服务：用户管理服务、订单服务、鉴权中心、物流服务等。这时，订单服务中，某个接口请求用户管理服务，这个时候如果需要熔断机制，该怎么处理呢？ 首先，订单服务引入依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; 这个时候，订单服务启动类中需要引用熔断注解 @EnableCircuitBreaker，使其生效： 12345678910111213141516171819&#x2F;** * @author Damon * @date 2020年1月13日 下午3:23:06 * *&#x2F;@EnableOAuth2Sso@Configuration@EnableAutoConfiguration@ComponentScan(basePackages &#x3D; &#123;&quot;com.damon&quot;&#125;)@EnableDiscoveryClient@EnableCircuitBreakerpublic class OrderApp &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderApp.class, args); &#125;&#125; 这里，不要忘记注解 @EnableDiscoveryClient 来相互暴露服务。 最后需要在调用用户管理服务的函数中，加入注解 @HystrixCommand： 123456789101112131415161718192021222324252627282930313233343536373839@HystrixCommand(fallbackMethod &#x3D; &quot;admin_service_fallBack&quot;, commandProperties &#x3D; &#123; @HystrixProperty(name &#x3D; &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value &#x3D; &quot;5000&quot;) &#125;)&#x2F;&#x2F;隔离策略:execution.isolation.strategy &#x3D;SEMAPHORE or THREAD(不配置默认) @Override public Response&lt;Object&gt; getUserInfo(HttpServletRequest req, HttpServletResponse res) &#123; ResponseEntity&lt;String&gt; forEntity &#x3D; restTemplate.getForEntity(envConfig.getAdmin_web_url() + &quot;&#x2F;api&#x2F;user&#x2F;getUserInfo&quot;, String.class); HttpHeaders headers &#x3D; new HttpHeaders(); MediaType type &#x3D; MediaType.parseMediaType(&quot;application&#x2F;json; charset&#x3D;UTF-8&quot;); headers.setContentType(type); headers.add(&quot;Accept&quot;, MediaType.APPLICATION_JSON.toString()); headers.add(&quot;Authorization&quot;, &quot;bearer &quot; + StrUtil.subAfter(req.getHeader(&quot;Authorization&quot;), &quot;bearer &quot;, false)); HttpEntity&lt;String&gt; formEntity &#x3D; new HttpEntity&lt;String&gt;(null, headers); String body &#x3D; &quot;&quot;; try &#123; ResponseEntity&lt;String&gt; responseEntity &#x3D; restTemplate.exchange(&quot;http:&#x2F;&#x2F;admin-web-service&#x2F;api&#x2F;user&#x2F;getUserInfo&quot;, HttpMethod.GET, formEntity, String.class); if (responseEntity.getStatusCodeValue() &#x3D;&#x3D; 200) &#123; logger.debug(String.format(&quot;request getUserInfo return: &#123;&#125;&quot;, JSON.toJSON(responseEntity.getBody()))); return Response.ok(responseEntity.getStatusCodeValue(), 0, &quot;success&quot;, JSON.toJSON(responseEntity.getBody())); &#125; &#125; catch (Exception e) &#123; logger.error(&quot;loadJobDetail error&quot;); logger.error(e.getMessage(), e); &#125; return null; &#125; &#x2F;** * 熔断时调用的方法 * * 参数要与被请求的方法的参数一致 * * @return *&#x2F; private Response&lt;Object&gt; admin_service_fallBack(HttpServletRequest req, HttpServletResponse res) &#123; String token &#x3D; StrUtil.subAfter(req.getHeader(&quot;Authorization&quot;), &quot;bearer &quot;, false); logger.info(&quot;admin_service_fallBack token: &#123;&#125;&quot;, token); return Response.ok(200, -2, &quot;用戶服務掛啦!&quot;, null); &#125; 其中上面代码需要注意的是：注解中 fallbackMethod 的值指定了熔断后的处理函数，这个函数的参数与当前的调用方法的参数需要保持一致，否则报错： 1com.netflix.hystrix.contrib.javanica.exception.FallbackDefinitionException:fallback method wasn&#39;t found. 最后，配置 Hystrix 相关的参数配置yaml： 12hystrix.command.BackendCall.execution.isolation.thread.timeoutInMilliseconds: 5000hystrix.threadpool.BackendCallThread.coreSize: 5 其中第一个配置在调用函数中其实也可以配置： 12@HystrixCommand(fallbackMethod &#x3D; &quot;admin_service_fallBack&quot;, commandProperties &#x3D; &#123; @HystrixProperty(name &#x3D; &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value &#x3D; &quot;3000&quot;) &#125;) 这里配置的3000毫秒生效后，如果配置文件中也配置了，则会被覆盖。 如果不加@HystrixCommand中的commandProperties=@HystrixProperty注解配置，下面的FallBack函数admin_service_fallBack()是一个线程；@HystrixCommand()是一个隔离线程。若加上commandProperties=@HystrixProperty注解配置后，将2个线程合并到一个线程里。 这样到此为止，调用方就结束配置了，至于被调用方，相关配置与源码在Spring Cloud Kubernetes之实战二服务注册与发现&nbsp;一文中，讲过被调用服务的相关，这里的http://admin-web-service 为被调用服务，则在其服务启动类中需要注解 @EnableDiscoveryClient： 12345678910111213141516171819202122232425262728293031package com.damon;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.boot.autoconfigure.security.oauth2.client.EnableOAuth2Sso;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import com.damon.config.EnvConfig;&#x2F;** * @author Damon * @date 2020年1月13日 下午3:23:06 * *&#x2F;@EnableOAuth2Sso@Configuration@EnableAutoConfiguration@ComponentScan(basePackages &#x3D; &#123;&quot;com.damon&quot;&#125;)@EnableConfigurationProperties(EnvConfig.class)@EnableDiscoveryClientpublic class AdminApp &#123; public static void main(String[] args) &#123; SpringApplication.run(AdminApp.class, args); &#125;&#125; 另外，配置 RestTemplate 的 Bean 中加上注解 @LoadBalanced 需要作 LB，这样利用服务名来根据 LB 规则找到对应的其中一个服务，这样比较明显看出 LB 的效果： 12345678910111213141516171819202122232425262728293031package com.damon.config;import javax.annotation.Resource;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.env.Environment;import org.springframework.http.client.SimpleClientHttpRequestFactory;import org.springframework.web.client.RestTemplate;&#x2F;** * @author Damon * @date 2018年2月2日 下午7:15:53 *&#x2F;@Configurationpublic class BeansConfig &#123; @Resource private Environment env; @LoadBalanced&#x2F;&#x2F;就不能用ip等形式来请求其他服务 @Bean public RestTemplate restTemplate() &#123; SimpleClientHttpRequestFactory requestFactory &#x3D; new SimpleClientHttpRequestFactory(); requestFactory.setReadTimeout(env.getProperty(&quot;client.http.request.readTimeout&quot;, Integer.class, 15000)); requestFactory.setConnectTimeout(env.getProperty(&quot;client.http.request.connectTimeout&quot;, Integer.class, 3000)); RestTemplate rt &#x3D; new RestTemplate(requestFactory); return rt; &#125;&#125; 最后如果没问题了，可以先暂停用户管理服务，然后运行订单服务时，返回熔断结果： 1&#123;&quot;message&quot;:&#123;&quot;code&quot;:-2,&quot;message&quot;:&quot;用戶服務掛啦!&quot;,&quot;status&quot;:200&#125;&#125; OK，Spring cloud 熔断实战就结束了！ 结束福利 开源实战利用 k8s 作微服务的架构设计代码： https://gitee.com/damon_one/spring-cloud-k8s https://gitee.com/damon_one/spring-cloud-oauth2 欢迎大家 star，多多指教。 关于作者 笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 docker、k8s 做微服务容器化，自动化部署等一站式项目部署、落地。Go 语言学习，k8s 研究，边缘计算框架 KubeEdge 等。公众号 程序猿Damon 发起人。个人微信 MrNull008，欢迎來撩。 欢迎关注：InfoQ 欢迎关注：腾讯自媒体专栏","tags":[]},{"title":"Spring cloud 之多种方式限流（实战）","date":"2020-07-10T06:15:01.000Z","path":"2020/07/10/springcloud-03/","text":"在频繁的网络请求时，服务有时候也会受到很大的压力，尤其是那种网络攻击，非法的。这样的情形有时候需要作一些限制。例如：限制对方的请求，这种限制可以有几个依据：请求IP、用户唯一标识、请求的接口地址等等。 当前限流的方式也很多：Spring cloud 中在网关本身自带限流的一些功能，基于 redis 来做的。同时，阿里也开源了一款：限流神器 Sentinel。今天我们主要围绕这两块来实战微服务的限流机制。 首先讲 Spring cloud 原生的限流功能，因为限流可以是对每个服务进行限流，也可以对于网关统一作限流处理。 一、实战基于 Spring cloud Gateway 的限流 pom.xml引入依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; 其基础是基于redis，所以： 1234567891011121314spring: application: name: gateway-service redis: #redis相关配置 database: 8 host: 10.12.15.5 port: 6379 password: 123456 #有密码时设置 jedis: pool: max-active: 8 max-idle: 8 min-idle: 0 timeout: 10000ms 接下来需要注入限流策略的 bean： 1234567891011121314151617181920212223242526272829303132@Primary @Bean(value &#x3D; &quot;ipKeyResolver&quot;) KeyResolver ipKeyResolver() &#123; return exchange -&gt; Mono.just(exchange.getRequest().getRemoteAddress().getHostName()); &#x2F;&#x2F;return exchange -&gt; Mono.just(exchange.getRequest().getRemoteAddress().getAddress().getHostAddress()); &#x2F;&#x2F;return exchange -&gt; Mono.just(exchange.getRequest().getRemoteAddress().getAddress().getHostAddress()); &#125; &#x2F;** * API限流 * @return * @author Damon * @date 2020年3月18日 * *&#x2F; @Bean(value &#x3D; &quot;apiKeyResolver&quot;) KeyResolver apiKeyResolver() &#123; return exchange -&gt; Mono.just(exchange.getRequest().getPath().value()); &#125; &#x2F;** * 请求路径中必须携带userId参数 * 用户限流 * @return * @author Damon * @date 2020年3月18日 * *&#x2F; @Bean(value &#x3D; &quot;userKeyResolver&quot;) KeyResolver userKeyResolver() &#123; return exchange -&gt; Mono.just(exchange.getRequest().getQueryParams().getFirst(&quot;userId&quot;)); &#125; 这里引入ipKeyResolver、apiKeyResolver、userKeyResolver三种策略，可以利用注解 @Primary 来决定其中一个被使用。 注入bean后，需要在配置中备用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576spring: application: name: gateway-service redis: #redis相关配置 database: 8 host: 10.12.15.5 port: 6379 password: 123456 #有密码时设置 jedis: pool: max-active: 8 max-idle: 8 min-idle: 0 timeout: 10000ms cloud: kubernetes: discovery: all-namespaces: true gateway: discovery: locator: enabled: true lowerCaseServiceId: true routes: #路由配置:参数为一个List - id: cas-server #唯一标识 uri: lb:&#x2F;&#x2F;cas-server-service #转发的地址,写服务名称 order: -1 predicates: - Path&#x3D;&#x2F;cas-server&#x2F;** #判断匹配条件,即地址带有&#x2F;ribbon&#x2F;**的请求,会转发至lb:cas-server-service filters: - StripPrefix&#x3D;1 #去掉Path前缀,参数为1代表去掉&#x2F;ribbon - name: RequestRateLimiter #基于redis的Gateway的自身限流 args: redis-rate-limiter.replenishRate: 1 # 允许用户每秒处理多少个请求 redis-rate-limiter.burstCapacity: 3 # 令牌桶的容量，允许在一秒钟内完成的最大请求数 key-resolver: &quot;#&#123;@ipKeyResolver&#125;&quot; #SPEL表达式取的对应的bean - id: admin-web uri: lb:&#x2F;&#x2F;admin-web-service order: -1 predicates: - Path&#x3D;&#x2F;admin-web&#x2F;** filters: - StripPrefix&#x3D;1 - name: RequestRateLimiter args: redis-rate-limiter.replenishRate: 1 # 允许用户每秒处理多少个请求 redis-rate-limiter.burstCapacity: 3 # 令牌桶的容量，允许在一秒钟内完成的最大请求数 key-resolver: &quot;#&#123;@ipKeyResolver&#125;&quot; #SPEL表达式取的对应的bean - id: order-service uri: lb:&#x2F;&#x2F;order-service-service order: -1 predicates: - Path&#x3D;&#x2F;order-service&#x2F;** filters: - StripPrefix&#x3D;1 - name: RequestRateLimiter args: redis-rate-limiter.replenishRate: 1 # 允许用户每秒处理多少个请求 redis-rate-limiter.burstCapacity: 3 # 令牌桶的容量，允许在一秒钟内完成的最大请求数 key-resolver: &quot;#&#123;@ipKeyResolver&#125;&quot; #SPEL表达式取的对应的bean http: encoding: charset: UTF-8 enabled: true force: true mvc: throw-exception-if-no-handler-found: true main: allow-bean-definition-overriding: true # 当遇到同样名称时，是否允许覆盖注册 这里是在原有的路由基础上加入 RequestRateLimiter限流过滤器，包括三个参数： 12345- name: RequestRateLimiter #基于redis的Gateway的自身限流 args: redis-rate-limiter.replenishRate: 3 #允许用户每秒处理多少个请求 redis-rate-limiter.burstCapacity: 5 #令牌桶的容量，允许在一秒钟内完成的最大请求数 key-resolver: &quot;#&#123;@ipKeyResolver&#125;&quot; #SPEL表达式取的对应的bean 其中 replenishRate，其含义表示允许每秒处理请求数； burstCapacity 表示允许在一秒内处理的最大请求数； key-resolver 这里采用请求 IP 限流，利用SPEL 表达式取对应的 bean 写一个小脚本来压测一下： 123for i in $(seq 1 30000); do echo $(expr $i \\\\* 3 + 1);curl -i -H &quot;Accept: application&#x2F;json&quot; -H &quot;Authorization:bearer b064d95b-af3f-4053-a980-377c63ab3413&quot; -X GET http:&#x2F;&#x2F;10.10.15.5:5556&#x2F;order-service&#x2F;api&#x2F;order&#x2F;getUserInfo;donefor i in $(seq 1 30000); do echo $(expr $i \\\\* 3 + 1);curl -i -H &quot;Accept: application&#x2F;json&quot; -H &quot;Authorization:bearer b064d95b-af3f-4053-a980-377c63ab3413&quot; -X GET http:&#x2F;&#x2F;10.10.15.5:5556&#x2F;admin-web&#x2F;api&#x2F;user&#x2F;getCurrentUser;done 上面两个脚本分别对2个服务进行压测，打印结果： 12345678910111213141516171819202122232425262728293031323334HTTP&#x2F;1.1 200 OKtransfer-encoding: chunkedX-RateLimit-Remaining: 2X-RateLimit-Burst-Capacity: 3X-RateLimit-Replenish-Rate: 1Expires: 0Cache-Control: no-cache, no-store, max-age&#x3D;0, must-revalidateSet-Cookie: ORDER-SERVICE-SESSIONID&#x3D;R99Ljit9XvfCapyUJDWL8I0rZqxReoY6HwcQV2n2; path&#x3D;&#x2F;X-XSS-Protection: 1; mode&#x3D;blockPragma: no-cacheX-Frame-Options: DENYDate: Thu, 19 Mar 2020 06:32:27 GMTX-Content-Type-Options: nosniffContent-Type: application&#x2F;json;charset&#x3D;UTF-8&#123;&quot;message&quot;:&#123;&quot;status&quot;:200,&quot;code&quot;:0,&quot;message&quot;:&quot;success&quot;&#125;,&quot;data&quot;:&quot;&#123;\\&quot;message\\&quot;:&#123;\\&quot;status\\&quot;:200,\\&quot;code\\&quot;:0,\\&quot;message\\&quot;:\\&quot;get user success\\&quot;&#125;,\\&quot;data\\&quot;:&#123;\\&quot;id\\&quot;:23,\\&quot;isAdmin\\&quot;:1,\\&quot;userId\\&quot;:\\&quot;fbb18810-e980-428c-932f-848f3b9e7c84\\&quot;,\\&quot;userType\\&quot;:\\&quot;super_admin\\&quot;,\\&quot;username\\&quot;:\\&quot;admin\\&quot;,\\&quot;realName\\&quot;:\\&quot;super_admin\\&quot;,\\&quot;password\\&quot;:\\&quot;$2a$10$89AqlYKlnsTpNmWcCMvgluRFQ&#x2F;6MLK1k&#x2F;nkBpz.Lw6Exh.WMQFH6W\\&quot;,\\&quot;phone\\&quot;:null,\\&quot;email\\&quot;:null,\\&quot;createBy\\&quot;:\\&quot;admin\\&quot;,\\&quot;createTime\\&quot;:1573119753172,\\&quot;updateBy\\&quot;:\\&quot;admin\\&quot;,\\&quot;updateTime\\&quot;:1573119753172,\\&quot;loginTime\\&quot;:null,\\&quot;expireTime\\&quot;:null,\\&quot;remarks\\&quot;:\\&quot;super_admin\\&quot;,\\&quot;delFlag\\&quot;:0,\\&quot;loginType\\&quot;:null&#125;&#125;&quot;&#125;ex同一秒内多次后：HTTP&#x2F;1.1 429 Too Many RequestsX-RateLimit-Remaining: 0X-RateLimit-Burst-Capacity: 3X-RateLimit-Replenish-Rate: 1content-length: 0expr: syntax errorHTTP&#x2F;1.1 429 Too Many RequestsX-RateLimit-Remaining: 0X-RateLimit-Burst-Capacity: 3X-RateLimit-Replenish-Rate: 1content-length: 0expr: syntax error 从上面可以看到，执行后，会出现调用失败的情况，状态变为429 (Too Many Requests) 。 二、基于阿里开源限流神器：Sentinel 首先引入依赖： 12345&lt;!--基于 阿里的sentinel作限流 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; 在配置文件 application.yaml 文件中配置，需要新增2个配置： 123456789101112131415161718spring: application: name: admin-web cloud: kubernetes: discovery: all-namespaces: true sentinel: eager: true #取消Sentinel控制台的懒加载 transport: dashboard: 10.12.15.2:8080 #sentinel的Dashboard地址 port: 8719 #是sentinel应用端和控制台通信端口 heartbeat-interval-ms: 500 #心跳时间 scg: fallback: #scg.fallback为sentinel限流后的响应配置 mode: response response-status: 455 response-body: 已被限流 其中，这里面配置了一个服务：spring.cloud.sentinel.transport.dashboard，配置的是 sentinel 的 Dashboard 地址。同时 spring.cloud.sentinel.transport.port 这个端口配置会在应用对应的机器上启动一个Http Server，该 Server 会与 Sentinel 控制台做交互。 Sentinel 默认为所有的 HTTP 服务提供限流埋点，上面配置完成后自动完成所有埋点，只需要控制配置限流规则即可。 这里我们讲下通过注解来给指定接口函数加上限流埋点，写一个RestController，在接口函数上加上注解 @SentinelResource： 123456789@GetMapping(value &#x3D; &quot;&#x2F;getToken&quot;)@SentinelResource(&quot;getToken&quot;)public Response&lt;Object&gt; getToken(Authentication authentication)&#123; &#x2F;&#x2F;Authentication authentication &#x3D; SecurityContextHolder.getContext().getAuthentication(); authentication.getCredentials(); OAuth2AuthenticationDetails details &#x3D; (OAuth2AuthenticationDetails)authentication.getDetails(); String token &#x3D; details.getTokenValue(); return Response.ok(200, 0, &quot;get token success&quot;, token);&#125; 以上代码部分完成了，接下来先安装SentinelDashBoard，Sentinel DashBoard下载地址：https://github.com/alibaba/Sentinel/releases 。 下载完成后，命令启动： 1java -jar sentinel-dashboard-1.6.2.jar 默认启动端口为8080，访问 IP:8080，就可以显示 Sentinel 的登录界面，用户名与密码均为sentinel。登录 Dashboard 成功后，多次访问接口”/getToken”，可以在 Dashboard 看到相应数据，这里不展示了。接下来可以设置接口的限流功能，在 “+流控” 按钮点击打开设置界面，设置阈值类型为 qps，单机阈值为5。 浏览器重复请求 http://10.10.15.5:5556/admin-web/api/user/getToken 如果超过阀值就会出现如下界面信息： 1Blocked by Sentinel (flow limiting) 此时，就看到Sentinel 限流起作用了，可以加上 spring.cloud.sentinel.scg.fallback 为sentinel 限流后的响应配置，亦可自定义限流异常信息： 1234567891011121314151617@GetMapping(value &#x3D; &quot;&#x2F;getToken&quot;)@SentinelResource(value &#x3D; &quot;getToken&quot;, blockHandler &#x3D; &quot;handleSentinelException&quot;, blockHandlerClass &#x3D; &#123;MySentinelException.class&#125;))public Response&lt;Object&gt; getToken(Authentication authentication)&#123; &#x2F;&#x2F;Authentication authentication &#x3D; SecurityContextHolder.getContext().getAuthentication(); authentication.getCredentials(); OAuth2AuthenticationDetails details &#x3D; (OAuth2AuthenticationDetails)authentication.getDetails(); String token &#x3D; details.getTokenValue(); return Response.ok(200, 0, &quot;get token success&quot;, token);&#125;public class MySentinelException &#123; public static Response&lt;Object&gt; handleSentinelException(BlockException e) &#123; Map&lt;String,Object&gt; map&#x3D;new HashMap&lt;&gt;(); logger.info(&quot;Oops: &quot; + ex.getClass().getCanonicalName()); return Response.ok(200, -8, &quot;通过注解 @SentinelResource 配置限流埋点并自定义限流后的处理逻辑&quot;, null); &#125;&#125; 这里讲下注解 @SentinelResource 包含以下属性： value：资源名称，必需项； entryType：入口类型，可选项（默认为 EntryType.OUT）； blockHandler：blockHandlerClass中对应的异常处理方法名，参数类型和返回值必须和原方法一致； blockHandlerClass：自定义限流逻辑处理类 Sentinel 限流逻辑处理完毕了，但每次服务重启后，之前配置的限流规则就会被清空。因为是内存形式的规则对象。所以下面就讲下用 Sentinel 的一个特性 ReadableDataSource 获取文件、数据库或者配置中心设置限流规则，目前支持 Apollo、Nacos、ZK 配置来管理。 首先回忆一下，一条限流规则主要由下面几个因素组成： resource：资源名，即限流规则的作用对象，即为注解 @SentinelResource 的value； count：限流阈值；grade：限流阈值类型（QPS 或并发线程数）； limitApp：流控针对的调用来源，若为 default 则不区分调用来源； strategy：基于调用关系的限流策略； controlBehavior：流量控制效果（直接拒绝、排队等待、匀速器模式） 理解了意思，接下来通过文件来配置： 1234#通过文件读取限流规则spring.cloud.sentinel.datasource.ds1.file.file&#x3D;classpath:flowrule.jsonspring.cloud.sentinel.datasource.ds1.file.data-type&#x3D;jsonspring.cloud.sentinel.datasource.ds1.file.rule-type&#x3D;flow 在resources新建一个文件，比如 flowrule.json 添加限流规则： 123456789101112131415161718[ &#123; &quot;resource&quot;: &quot;getToken&quot;, &quot;count&quot;: 1, &quot;controlBehavior&quot;: 0, &quot;grade&quot;: 1, &quot;limitApp&quot;: &quot;default&quot;, &quot;strategy&quot;: 0 &#125;, &#123; &quot;resource&quot;: &quot;resource&quot;, &quot;count&quot;: 1, &quot;controlBehavior&quot;: 0, &quot;grade&quot;: 1, &quot;limitApp&quot;: &quot;default&quot;, &quot;strategy&quot;: 0 &#125;] 重新启动项目，出现如下日志说明成功： 12DataSource ds1-sentinel-file-datasource start to loadConfigDataSource ds1-sentinel-file-datasource load 2 FlowRule 如果采用 Nacos 作为配置获取限流规则，可在文件中加如下配置： 1234567891011121314151617181920spring: application: name: order-service cloud: nacos: config: server-addr: 10.10.15.5:8848 discovery: server-addr: 10.10.15.5:8848 sentinel: eager: true transport: dashboard: 10.10.15.5:8080 datasource: ds1: nacos: server-addr: 10.10.15.5:8848 dataId: $&#123;spring.application.name&#125;-flow-rules data-type: json rule-type: flow 以上即为限流的两种方式。 结束福利 开源实战利用 k8s 作微服务的架构设计代码： https://gitee.com/damon_one/spring-cloud-k8s https://gitee.com/damon_one/spring-cloud-oauth2 欢迎大家 star，多多指教。 关于作者 笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 docker、k8s 做微服务容器化，自动化部署等一站式项目部署、落地。Go 语言学习，k8s 研究，边缘计算框架 KubeEdge 等。公众号 程序猿Damon 发起人。个人微信 MrNull008，欢迎來撩。 欢迎关注：InfoQ 欢迎关注：腾讯自媒体专栏","tags":[]},{"title":"面试被问finally 和 return，到底谁先执行？","date":"2020-07-10T06:13:40.000Z","path":"2020/07/10/core-java01/","text":"经常有人面试被问到，finally 和 return，到底谁先执行呢？ 为了解决这个问题，其实我们可以先想想 finally 是被用来干嘛的呢？它是被用来结束一些正常的收尾动作或结束标识。也就是说无论怎么样，finally 都会被最后执行。例如：一般在操作数据库时，用Jdbc连接池连接数据库后释放资源，需要 finally 来处理。再如 redis 连接，在获取连接池处理完数据的增删改查后，需要释放其连接池。 但是，如果 return 是在 finally 前面呢？或者在 finally 后面呢？我们先来看看 return 在 finally 前面时，如： 1234567891011121314151617181920212223242526272829303132333435363738package com.test;&#x2F;** * * * @author Damon * @date 2020年3月18日 上午11:02:08 * *&#x2F;public class App &#123; public static void main(String[] args) &#123; System.out.println(&quot;return result: &quot; + test()); &#125; public static int test() &#123; try &#123; Thread.sleep(1); System.out.println(&quot;執行 return 1&quot;); return 1;&#x2F;&#x2F; return 在try里，則先執行，再執行finally后才有可能执行该return &#125; catch (InterruptedException e) &#123; e.printStackTrace(); return -1; &#125; finally &#123; System.out.println(&quot;执行 finally&quot;); &#x2F;&#x2F;return 3; &#125; &#x2F;&#x2F;System.out.println(&quot;執行 return 2&quot;); &#x2F;&#x2F;return 1; &#125;&#125;结果：執行 return 1执行 finallyreturn result: 1 也就是说，在执行 return 之前，先执行了 finally。 我们在看，如果 finally 前面有 return，在其内部也有 return： 1234567891011121314151617181920212223242526272829303132333435363738package com.test;&#x2F;** * * * @author Damon * @date 2020年3月18日 上午11:02:08 * *&#x2F;public class App &#123; public static void main(String[] args) &#123; System.out.println(&quot;return result: &quot; + test()); &#125; public static int test() &#123; try &#123; Thread.sleep(1); System.out.println(&quot;執行 return 1&quot;); return 1;&#x2F;&#x2F; return 在try里，則先執行，再執行finally后才有可能执行该return &#125; catch (InterruptedException e) &#123; e.printStackTrace(); return -1; &#125; finally &#123; System.out.println(&quot;执行 finally&quot;); return 3; &#125; &#x2F;&#x2F;System.out.println(&quot;執行 return 2&quot;); &#x2F;&#x2F;return 1; &#125;&#125;结果：執行 return 1执行 finallyreturn result: 3 其内部被 return 后，就不再执行前面那个 return 了。 我们再来看 return 在 finally 之后，如： 1234567891011121314151617181920212223242526272829303132333435363738package com.test;&#x2F;** * * * @author Damon * @date 2020年3月18日 上午11:02:08 * *&#x2F;public class App &#123; public static void main(String[] args) &#123; System.out.println(&quot;return result: &quot; + test()); &#125; public static int test() &#123; try &#123; Thread.sleep(1); &#x2F;&#x2F;System.out.println(&quot;執行 return 1&quot;); &#x2F;&#x2F;return 1;&#x2F;&#x2F; return 在try里，則先執行，再執行finally后才有可能执行该return &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#x2F;&#x2F;return -1; &#125; finally &#123; System.out.println(&quot;执行 finally&quot;); &#x2F;&#x2F;return 3; &#125; System.out.println(&quot;執行 return 2&quot;); return 1; &#125;&#125;结果：执行 finally執行 return 2return result: 1 总结：finally 在 return 之后时，先执行 finally 后，再执行该 return；finally 内含有 return 时，直接执行其 return 后结束；finally 在 return 前，执行完 finally 后再执行 return。 接下来还有常被问到的是：Java 中 final、finally、finalize 的区别与用法： final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。即如果一个类被声明为 final，意味着它不能作为父类被继承，因此一个类不能同时被声明为 abstract 的，又被声明为 final 的。变量或方法被声明为 final，可以保证它们在使用中不被修改。被声明为 final 的变量必须在声明时给赋予初值，而在以后的引用中只能读取，不可修改。被声明为 final 的方法也同样只能使用，不能重载。 finally 是异常处理语句结构的一部分，总是执行，常见的场景：释放一些资源，例如前面所说的 redis、db 等。在异常处理时提供 finally 块来执行任何清除操作，即在执行 catch 后会执行 finally 代码块。 finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。 结束福利 开源实战利用 k8s 作微服务的架构设计代码： https://gitee.com/damon_one/spring-cloud-k8s https://gitee.com/damon_one/spring-cloud-oauth2 欢迎大家 star，多多指教。 关于作者 笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 docker、k8s 做微服务容器化，自动化部署等一站式项目部署、落地。Go 语言学习，k8s 研究，边缘计算框架 KubeEdge 等。公众号 程序猿Damon 发起人。个人微信 MrNull008，欢迎來撩。 欢迎关注：InfoQ 欢迎关注：腾讯自媒体专栏","tags":[]},{"title":"Spring Cloud Kubernetes之实战一配置管理","date":"2020-07-10T06:10:45.000Z","path":"2020/07/10/springcloud-02/","text":"一直以来，玩springcloud的，基本都是在玩Springboot1.x，Springcloud(Dalston版)的众多相关组件来做配置中心、服务注册与发现，网关用的是Netflix公司对springboot做的LB，等等，但是这些东西太过沉重，复杂了。在一个以k8s为基础的iaas服务系统，如果不用k8s的特性来做这些事，那是说不过去的。理由这就不重复述说了。一句话：减少系统服务的复杂性。 本文主要介绍springcloud结合k8s，做配置管理，避免更多服务组件的冗余，完美填坑版！ 环境： ubuntu16.04 docker18.04 k8s1.13.x + maven3.5.3 java1.8 + springboot 2.1.1 spring-cloud-kubernetes：1.0.1.RELEAS 前提 Ubuntu下安装docker18.04 or 其它较高版本，k8s1.13.x及以上，jvm环境等。 创建项目基础依赖： 12345678910111213141516171819202122232425262728293031323334&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;&#x2F;version&gt; &lt;relativePath&#x2F;&gt; &lt;&#x2F;parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt; &lt;swagger.version&gt;2.6.1&lt;&#x2F;swagger.version&gt; &lt;xstream.version&gt;1.4.7&lt;&#x2F;xstream.version&gt; &lt;pageHelper.version&gt;4.1.6&lt;&#x2F;pageHelper.version&gt; &lt;fastjson.version&gt;1.2.51&lt;&#x2F;fastjson.version&gt; &lt;shiro.version&gt;1.3.0&lt;&#x2F;shiro.version&gt; &lt;!-- &lt;kubernetes-client-version&gt;6.0.1&lt;&#x2F;kubernetes-client-version&gt; --&gt; &lt;kubernetes-client-version&gt;5.0.0&lt;&#x2F;kubernetes-client-version&gt; &lt;fabric8-kubernetes-client.version&gt;4.6.1&lt;&#x2F;fabric8-kubernetes-client.version&gt;&lt;!-- 对应k8s v1.15.3 --&gt; &lt;springcloud.version&gt;Greenwich.SR4&lt;&#x2F;springcloud.version&gt; &lt;springcloud.kubernetes.version&gt;1.1.1.RELEASE&lt;&#x2F;springcloud.kubernetes.version&gt; &lt;mysql.version&gt;5.1.46&lt;&#x2F;mysql.version&gt; &lt;&#x2F;properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;springcloud.version&#125;&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; &lt;&#x2F;dependencyManagement&gt; 核心依赖： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt; &lt;&#x2F;exclusion&gt; &lt;&#x2F;exclusions&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-actuator&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-actuator-autoconfigure&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-kubernetes-config&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt;&lt;!-- springcloud-k8s-discovery --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-commons&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-kubernetes-core&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-kubernetes-discovery&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-kubernetes-ribbon&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; **本次依赖引入配置管理、服务的发现(即消费者)。**如果有操作redis和db的话，引入相应的依赖： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;1.1.1&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!--分页插件--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;&#x2F;groupId&gt; &lt;artifactId&gt;pagehelper&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;pageHelper.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- datasource pool--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt; &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt; &lt;version&gt;1.1.3&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt; &lt;artifactId&gt;commons-lang3&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;&#x2F;groupId&gt; &lt;artifactId&gt;commons-collections&lt;&#x2F;artifactId&gt; &lt;version&gt;3.2.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- 对redis支持,引入的话项目缓存就支持redis了,所以必须加上redis的相关配置,否则操作相关缓存会报异常 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-redis&lt;&#x2F;artifactId&gt; &lt;version&gt;1.4.7.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;&#x2F;groupId&gt; &lt;artifactId&gt;guava&lt;&#x2F;artifactId&gt; &lt;version&gt;19.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; 剩下的就是构建镜像时的插件： 1234567891011121314151617181920212223242526&lt;build&gt; &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;&#x2F;finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt; &lt;configuration&gt; &lt;jvmArguments&gt;-Dfile.encoding&#x3D;UTF-8&lt;&#x2F;jvmArguments&gt; &lt;fork&gt;true&lt;&#x2F;fork&gt; &lt;&#x2F;configuration&gt; &lt;&#x2F;plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.jacoco&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jacoco-maven-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;0.7.8&lt;&#x2F;version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;prepare-agent&lt;&#x2F;goal&gt; &lt;goal&gt;report&lt;&#x2F;goal&gt; &lt;&#x2F;goals&gt; &lt;&#x2F;execution&gt; &lt;&#x2F;executions&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt; &lt;&#x2F;build&gt; 接下来，我们创建主类： 12345678910@SpringBootApplication(scanBasePackages &#x3D; &#123; &quot;com.leinao&quot; &#125;)@EnableConfigurationProperties(EnvConfig.class)@EnableDiscoveryClient@EnableHystrix@EnableSchedulingpublic class AdminApp &#123; public static void main(String[] args) &#123; SpringApplication.run(AdminApp.class, args); &#125;&#125; 注意这里创建启动类时，对springboot的项目进行了优化，避免启动时加载很多，启动繁重，具体深度优化，可参考：https://mp.weixin.qq.com/s?__biz=MzU2NjIzNDk5NQ==&amp;mid=2247487954&amp;idx=1&amp;sn=2426451f3bd83161cfe1237f82d6b448&amp;key=f8fb043b3d2681a794e51a46e142af77355722dff712776af12b1f3c831218df6dfc329df63c8e5e550b3d88d58f0f178c4c3c16b141733e0e3344fa595e2bc25241d864d45132753fd99279b832de85&amp;ascene=1&amp;uin=MzQzMzI2NjAxMQ%3D%3D&amp;devicetype=Windows+10&amp;version=62070158&amp;lang=zh_CN&amp;pass_ticket=pnSSI9jAq0M11V5hYMmkoVm5qO%2FWk9l3UUUJMglbdtdDOzLHa7iHsDmwSzs486sD。 然后我们在进行配置，注意：据官方说，项目的src\\main\\resources路径下不要创建application.yml文件，只创建名为bootstrap.yml的文件： 123456789101112131415161718192021222324252627282930313233343536management: endpoint: restart: enabled: true health: enabled: true info: enabled: truespring: application: name: edge-admin cloud: kubernetes: config: sources: - name: $&#123;spring.application.name&#125; namespace: default discovery: all-namespaces: true reload: #自动更新配置的开关设置为打开 enabled: true #更新配置信息的模式：polling是主动拉取，event是事件通知 mode: polling #主动拉取的间隔时间是500毫秒 period: 500 http: encoding: charset: UTF-8 enabled: true force: true mvc: throw-exception-if-no-handler-found: true main: allow-bean-definition-overriding: true # 当遇到同样名称时，是否允许覆盖注册 这里，我创建了bootstrap文件，同时也加了application文件，启动时会先加载bootstrap，验证有效。 在application.yaml中，我们加入如下内容： 12345678910111213141516171819202122232425262728293031323334353637383940server: port: 9999 undertow: accesslog: enabled: false pattern: combined servlet: session: timeout: PT120Mlogging: path: &#x2F;data&#x2F;$&#123;spring.application.name&#125;&#x2F;logsmanagement: endpoint: restart: enabled: true health: enabled: true info: enabled: trueclient: http: request: connectTimeout: 8000 readTimeout: 30000mybatis: mapperLocations: classpath:mapper&#x2F;*.xml typeAliasesPackage: com.demo.*.modelbackend: ribbon: eureka: enabled: false client: enabled: true ServerListRefreshInterval: 5000hystrix.command.BackendCall.execution.isolation.thread.timeoutInMilliseconds: 5000hystrix.threadpool.BackendCallThread.coreSize: 5 注意：这里的server设置session的超时时间，对于springboot2.0与1.0版本完全不一样了，具体看内容。 其他的application-test.yaml等配置文件，配置的是日志的级别： 1234567logging: level: com: leinao: INFO org: springframework: web: INFO 接下来配置环境配置： EnvConfig.java类作为环境变量配置，注解ConfigurationProperties的prefix=”spring_cloud”， 表示该类用到的配置项都是名为”spring_cloud”的配置项的子内容 ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363package com.demo.config;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Configuration;&#x2F;** * 配置信息 * @author Damon * @date 2019年10月25日 下午1:54:01 * *&#x2F;@Configuration@ConfigurationProperties(prefix &#x3D; &quot;greeting&quot;)public class EnvConfig &#123; private String message &#x3D; &quot;This is a dummy message&quot;; private String container_command; private String model_dir_path; private String so_path; private String config_path; private String task_role_name; private String container_name; private String container_workdir; private String init_containers_image; private String service_account_name; private String spring_mq_host; private String spring_mq_port; private String spring_mq_user; private String spring_mq_pwd; private String jdbc_driverClassName; private String jdbc_url; private String jdbc_username; private String jdbc_password; private String spring_redis_host; private String spring_redis_port; private String spring_redis_pwd; private String kube_apiserver_address; private String image_path; private String volume_image_path; private String inference_job_namespace; private String api_version; private String remote_deployment_url; private String remote_pods_url; private String remote_deployment_pod_log_url; private String base_path; private String chunk_size; private String cas_url; private String create_job_url; private String abnormal_data_dir; private Long expire_time&#x3D; 600000L; public String getMessage() &#123; return this.message; &#125; public void setMessage(String message) &#123; this.message &#x3D; message; &#125; public String getContainer_command() &#123; return container_command; &#125; public void setContainer_command(String container_command) &#123; this.container_command &#x3D; container_command; &#125; public String getModel_dir_path() &#123; return model_dir_path; &#125; public void setModel_dir_path(String model_dir_path) &#123; this.model_dir_path &#x3D; model_dir_path; &#125; public String getSo_path() &#123; return so_path; &#125; public void setSo_path(String so_path) &#123; this.so_path &#x3D; so_path; &#125; public String getConfig_path() &#123; return config_path; &#125; public void setConfig_path(String config_path) &#123; this.config_path &#x3D; config_path; &#125; public String getTask_role_name() &#123; return task_role_name; &#125; public void setTask_role_name(String task_role_name) &#123; this.task_role_name &#x3D; task_role_name; &#125; public String getContainer_name() &#123; return container_name; &#125; public void setContainer_name(String container_name) &#123; this.container_name &#x3D; container_name; &#125; public String getContainer_workdir() &#123; return container_workdir; &#125; public void setContainer_workdir(String container_workdir) &#123; this.container_workdir &#x3D; container_workdir; &#125; public String getInit_containers_image() &#123; return init_containers_image; &#125; public void setInit_containers_image(String init_containers_image) &#123; this.init_containers_image &#x3D; init_containers_image; &#125; public String getService_account_name() &#123; return service_account_name; &#125; public void setService_account_name(String service_account_name) &#123; this.service_account_name &#x3D; service_account_name; &#125; public String getSpring_mq_host() &#123; return spring_mq_host; &#125; public void setSpring_mq_host(String spring_mq_host) &#123; this.spring_mq_host &#x3D; spring_mq_host; &#125; public String getSpring_mq_port() &#123; return spring_mq_port; &#125; public void setSpring_mq_port(String spring_mq_port) &#123; this.spring_mq_port &#x3D; spring_mq_port; &#125; public String getSpring_mq_user() &#123; return spring_mq_user; &#125; public void setSpring_mq_user(String spring_mq_user) &#123; this.spring_mq_user &#x3D; spring_mq_user; &#125; public String getSpring_mq_pwd() &#123; return spring_mq_pwd; &#125; public void setSpring_mq_pwd(String spring_mq_pwd) &#123; this.spring_mq_pwd &#x3D; spring_mq_pwd; &#125; public String getJdbc_driverClassName() &#123; return jdbc_driverClassName; &#125; public void setJdbc_driverClassName(String jdbc_driverClassName) &#123; this.jdbc_driverClassName &#x3D; jdbc_driverClassName; &#125; public String getJdbc_url() &#123; return jdbc_url; &#125; public void setJdbc_url(String jdbc_url) &#123; this.jdbc_url &#x3D; jdbc_url; &#125; public String getJdbc_username() &#123; return jdbc_username; &#125; public void setJdbc_username(String jdbc_username) &#123; this.jdbc_username &#x3D; jdbc_username; &#125; public String getJdbc_password() &#123; return jdbc_password; &#125; public void setJdbc_password(String jdbc_password) &#123; this.jdbc_password &#x3D; jdbc_password; &#125; public String getSpring_redis_host() &#123; return spring_redis_host; &#125; public void setSpring_redis_host(String spring_redis_host) &#123; this.spring_redis_host &#x3D; spring_redis_host; &#125; public String getSpring_redis_port() &#123; return spring_redis_port; &#125; public void setSpring_redis_port(String spring_redis_port) &#123; this.spring_redis_port &#x3D; spring_redis_port; &#125; public String getSpring_redis_pwd() &#123; return spring_redis_pwd; &#125; public void setSpring_redis_pwd(String spring_redis_pwd) &#123; this.spring_redis_pwd &#x3D; spring_redis_pwd; &#125; public String getKube_apiserver_address() &#123; return kube_apiserver_address; &#125; public void setKube_apiserver_address(String kube_apiserver_address) &#123; this.kube_apiserver_address &#x3D; kube_apiserver_address; &#125; public String getImage_path() &#123; return image_path; &#125; public void setImage_path(String image_path) &#123; this.image_path &#x3D; image_path; &#125; public String getVolume_image_path() &#123; return volume_image_path; &#125; public void setVolume_image_path(String volume_image_path) &#123; this.volume_image_path &#x3D; volume_image_path; &#125; public String getInference_job_namespace() &#123; return inference_job_namespace; &#125; public void setInference_job_namespace(String inference_job_namespace) &#123; this.inference_job_namespace &#x3D; inference_job_namespace; &#125; public String getApi_version() &#123; return api_version; &#125; public void setApi_version(String api_version) &#123; this.api_version &#x3D; api_version; &#125; public String getRemote_deployment_url() &#123; return remote_deployment_url; &#125; public void setRemote_deployment_url(String remote_deployment_url) &#123; this.remote_deployment_url &#x3D; remote_deployment_url; &#125; public String getRemote_pods_url() &#123; return remote_pods_url; &#125; public void setRemote_pods_url(String remote_pods_url) &#123; this.remote_pods_url &#x3D; remote_pods_url; &#125; public String getRemote_deployment_pod_log_url() &#123; return remote_deployment_pod_log_url; &#125; public void setRemote_deployment_pod_log_url(String remote_deployment_pod_log_url) &#123; this.remote_deployment_pod_log_url &#x3D; remote_deployment_pod_log_url; &#125; public String getBase_path() &#123; return base_path; &#125; public void setBase_path(String base_path) &#123; this.base_path &#x3D; base_path; &#125; public String getChunk_size() &#123; return chunk_size; &#125; public void setChunk_size(String chunk_size) &#123; this.chunk_size &#x3D; chunk_size; &#125; public Long getExpire_time() &#123; return expire_time; &#125; public void setExpire_time(Long expire_time) &#123; this.expire_time &#x3D; expire_time; &#125; public String getCas_url() &#123; return cas_url; &#125; public void setCas_url(String cas_url) &#123; this.cas_url &#x3D; cas_url; &#125; public String getCreate_job_url() &#123; return create_job_url; &#125; public void setCreate_job_url(String create_job_url) &#123; this.create_job_url &#x3D; create_job_url; &#125; public String getAbnormal_data_dir() &#123; return abnormal_data_dir; &#125; public void setAbnormal_data_dir(String abnormal_data_dir) &#123; this.abnormal_data_dir &#x3D; abnormal_data_dir; &#125;&#125;测试demo类：&#x2F;** * @author Damon * @date 2019年12月27日 上午9:16:41 * *&#x2F;@RestControllerpublic class DemoController &#123; @Autowired private EnvConfig envConfig; &#x2F;** * * @author Damon * @date 2019年12月26日 * *&#x2F; @GetMapping(value &#x3D; &quot;&#x2F;getTest&quot;) public String getTest() &#123; return envConfig.getBase_path(); &#125;&#125; 重点：默认的svc是没有权限访问k8s的API Server的资源的，执行如下脚本，可以提升权限，允许其访问configmap的可读权限： 123456789101112131415#使用这个代表集群最高权限，deployment中无需引入serviceAccount: config-readerapiVersion: rbac.authorization.k8s.io&#x2F;v1kind: ClusterRoleBindingmetadata: name: fabric8-rbacsubjects: - kind: ServiceAccount # Reference to upper&#39;s &#96;metadata.name&#96; name: default # Reference to upper&#39;s &#96;metadata.namespace&#96; namespace: defaultroleRef: kind: ClusterRole name: cluster-admin apiGroup: rbac.authorization.k8s.io 配置configmap： 1234567891011121314151617181920212223kind: ConfigMapapiVersion: v1metadata: name: edge-admindata: application.yaml: |- greeting: message: Say Hello to the World --- spring: profiles: dev greeting: message: Say Hello to the Developers --- spring: profiles: test greeting: message: Say Hello to the Test --- spring: profiles: prod greeting: message: Say Hello to the Prod 接下来就是执行deployment启动项目了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162apiVersion: apps&#x2F;v1kind: Deploymentmetadata: name: edge-admin-deployment labels: app: edge-adminspec: replicas: 1 selector: matchLabels: app: edge-admin template: metadata: labels: app: edge-admin spec: nodeSelector: edge-admin: &quot;true&quot; containers: - name: edge-admin image: 10.11.2.20:8000&#x2F;harbor&#x2F;edge-admin imagePullPolicy: IfNotPresent ports: - name: admin01 containerPort: 1002 volumeMounts: - mountPath: &#x2F;home&#x2F;edge-admin name: edge-admin-path - mountPath: &#x2F;data&#x2F;edge-admin name: edge-admin-log-path - mountPath: &#x2F;etc&#x2F;kubernetes name: kube-config-path - mountPath: &#x2F;abnormal_data_dir name: abnormal-data-dir args: [&quot;sh&quot;, &quot;-c&quot;, &quot;nohup java $JAVA_OPTS -jar -XX:MetaspaceSize&#x3D;128m -XX:MaxMetaspaceSize&#x3D;128m -Xms1024m -Xmx1024m -Xmn256m -Xss256k -XX:SurvivorRatio&#x3D;8 -XX:+UseConcMarkSweepGC edge-admin.jar --spring.profiles.active&#x3D;dev&quot;, &quot;&amp;&quot;] hostAliases: - ip: &quot;10.10.1.5&quot; hostnames: - &quot;k8s.api.server&quot; - &quot;foo.remote&quot; - ip: &quot;127.0.0.1&quot; hostnames: - &quot;foo.localhost&quot; - ip: &quot;0.0.0.0&quot; hostnames: - &quot;foo.all&quot; #利用admin-rbac.yaml来获取权限 #serviceAccount: config-reader #serviceAccountName: config-reader volumes: - name: edge-admin-path hostPath: path: &#x2F;var&#x2F;pai&#x2F;edge-admin - name: edge-admin-log-path hostPath: path: &#x2F;data&#x2F;edge-admin - name: kube-config-path hostPath: path: &#x2F;etc&#x2F;kubernetes - name: abnormal-data-dir hostPath: path: &#x2F;data&#x2F;images&#x2F;detect_result&#x2F;defect 其中，前面说的，项目启动参数对其性能优化，是对jvm的参数设置。分别执行kubectl apply -f deployment.yaml和configmap.yaml，创建demo时所用的configmap的资源以及利用k8s部署启动项目。 最后打开浏览器：执行ip:port/hello，即可看到configmap中对应的属性值，这里就不展示了，有兴趣的可以试试。 以上即是对springcloud和k8s首次结合后利用其configmap特性，来做配置管理，摒弃springcloud-config、spring-boot-starter-actuator的组件，减少系统的复杂性，毕竟k8s是肯定会被用到的，所以可以直接用其特性来做系统服务的环境配置管理。 结束福利 开源实战利用 k8s 作微服务的架构设计代码： https://gitee.com/damon_one/spring-cloud-k8s https://gitee.com/damon_one/spring-cloud-oauth2 欢迎大家 star，多多指教。 关于作者 笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 docker、k8s 做微服务容器化，自动化部署等一站式项目部署、落地。Go 语言学习，k8s 研究，边缘计算框架 KubeEdge 等。公众号 程序猿Damon 发起人。个人微信 MrNull008，欢迎來撩。 欢迎关注：InfoQ 欢迎关注：腾讯自媒体专栏","tags":[]},{"title":"浅谈微服务安全架构设计","date":"2020-07-10T05:57:33.000Z","path":"2020/07/10/micro-service01/","text":"1、 回顾微服务设计理念 在前面的一篇文章 https://gitbook.cn/gitchat/activity/5e8ada3452383e517ff2b5f8 中，我们了解到什么是微服务，微服务的划分依据，其实，说到底，微服务的设计，有其独到的好处：使得各个模块之间解耦合，让每一个模块有自己独立的灵魂，其他服务即使出现任何问题，自己不会受到任何的影响。这是微服务的核心宗旨。那么今天要讲的微服务安全性问题，其实也是反映微服务的一个核心：高内聚。所谓高内聚，简单的理解就是，对外暴露的最小限度，降低其依赖关系，大部分都作为一个黑盒子封装起来，不直接对外，这样，即使内部发生变更、翻云覆雨，对外的接口没发生改变，这才是好的微服务设计理念，做到完美的对外兼容，一个好的架构设计，首先，这一点可能需要 get 到位，不知道大家咋认为呢？所以今天说的微服务安全性，就跟这个高内聚有一点点相关了。或者说，体现了微服务设计的核心理念。 2、微服务下的各种安全性保证 2.1 常见的几种安全性措施在微服务中，我们常见的，有如下几种安全性设计的举措：网关设计、服务端口的对外暴露的限度、token 鉴权、OAuth2 的统一认证、微信中的 openId 设计等。这些都是在为服务的安全性作考虑的一些举措。 2.2 OAuth2 的概念何为 OAuth2 呢？我们先了解 OAuth，Oauth 是一个开放标准，假设有这样一种场景：一个 QQ 应用，希望让一个第三方的（慕课网）应用，能够得到关于自身的一些信息（唯一用户标识，比如说 QQ 号，用户个人信息、一些基础资料，昵称和头像等）。但是在获得这些资料的同时，却又不能提供用户名和密码之类的信息。如下图： 而 OAuth 就是实现上述目标的一种规范。OAuth2 是 OAuth 协议的延续版本，但不兼容 OAuth1.0，即完全废弃了 OAuth1.0。 OAuth2.0 有这么几个术语：客户凭证、令牌、作用域。 客户凭证：客户的 clientId 和密码用于认证客户。 令牌：授权服务器在接收到客户请求后颁发的令牌。 作用域：客户请求访问令牌时,由资源拥有者额外指定的细分权限。 2.3 OAuth2 的原理在 OAuth2 的授权机制中有 4 个核心对象： Resource Owner：资源拥有者，即用户。 Client：第三方接入平台、应用，请求者。 Resource Server：资源服务器，存储用户信息、用户的资源信息等资源。 Authorization Server：授权认证服务器。 实现机制： 用户在第三方应用上点击登录，应用向认证服务器发送请求，说有用户希望进行授权操作，同时说明自己是谁、用户授权完成后的回调 url，例如：上面的截图，通过慕课网访问 QQ 获取授权。 认证服务器展示给用户自己的授权界面。 用户进行授权操作，认证服务器验证成功后，生成一个授权编码 code，并跳转到第三方的回调 url。 第三方应用拿到 code 后，连同自己在平台上的身份信息（ID 密码）发送给认证服务器，再一次进行验证请求，说明自己的身份正确，并且用户也已经授权我了，来换取访问用户资源的权限。 认证服务器对请求信息进行验证，如果没问题，就生成访问资源服务器的令牌 access_token，交给第三方应用。 第三方应用使用 access_token 向资源服务器请求资源。 资源服务器验证 access_token 成功后返回响应资源。 2.4 OAuth2 的几种授权模式OAuth2.0 有这么几个授权模式：授权码模式、简化模式、密码模式、客户端凭证模式。 授权码模式：（authorization_code）是功能最完整、流程最严密的授权模式，code 保证了 token 的安全性，即使 code 被拦截，由于没有 client_secret，也是无法通过 code 获得 token 的。 简化模式：和授权码模式类似，只不过少了获取 code 的步骤，是直接获取令牌 token 的，适用于公开的浏览器单页应用，令牌直接从授权服务器返回，不支持刷新令牌，且没有 code 安全保证，令牌容易因为被拦截窃听而泄露。 密码模式：使用用户名/密码作为授权方式从授权服务器上获取令牌，一般不支持刷新令牌。 客户端凭证模式：一般用于资源服务器是应用的一个后端模块，客户端向认证服务器验证身份来获取令牌。 2.5 实战 OAuth2 的密码模式本次结合 Spring Cloud Alibaba 组件，实现微服务的安全系统体系，本文主要讲解 OAuth2 的部分。 先来看鉴权中心，鉴权中心需要做到提供单点服务，为所有的客户端微服务的安全保驾护航。下面首先看依赖: 12345678910111213141516171819&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-cloud-starter-oauth2&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;!-- 对redis支持,引入的话项目缓存就支持redis了,所以必须加上redis的相关配置,否则操作相关缓存会报异常 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 如果需要使用 redis 来存储 token，则可以加入 reids 依赖，如果使用 jwt，则使用: 12345&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jjwt&lt;&#x2F;artifactId&gt; &lt;version&gt;0.9.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 当然，本次的项目模块引入的是比较新的 Spring Boot: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1.13.RELEASE&lt;&#x2F;version&gt; &lt;relativePath&#x2F;&gt;&lt;&#x2F;parent&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt; &lt;swagger.version&gt;2.6.1&lt;&#x2F;swagger.version&gt; &lt;xstream.version&gt;1.4.7&lt;&#x2F;xstream.version&gt; &lt;pageHelper.version&gt;4.1.6&lt;&#x2F;pageHelper.version&gt; &lt;fastjson.version&gt;1.2.51&lt;&#x2F;fastjson.version&gt; &lt;springcloud.version&gt;Greenwich.SR3&lt;&#x2F;springcloud.version&gt; &lt;mysql.version&gt;5.1.46&lt;&#x2F;mysql.version&gt; &lt;alibaba-cloud.version&gt;2.1.1.RELEASE&lt;&#x2F;alibaba-cloud.version&gt; &lt;springcloud.alibaba.version&gt;0.9.0.RELEASE&lt;&#x2F;springcloud.alibaba.version&gt; &lt;&#x2F;properties&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;alibaba-cloud.version&#125;&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;springcloud.alibaba.version&#125;&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;springcloud.version&#125;&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;dependencyManagement&gt; 剩下的，像数据库、持久化等，其他的可以根据需要添加。 配置完成后，我们需要写一个认证服务器的配置: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163package com.damon.config;import java.util.ArrayList;import java.util.List;import javax.sql.DataSource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Configuration;import org.springframework.core.env.Environment;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;import org.springframework.security.oauth2.provider.error.WebResponseExceptionTranslator;import org.springframework.security.oauth2.provider.token.TokenEnhancer;import org.springframework.security.oauth2.provider.token.TokenEnhancerChain;import org.springframework.security.oauth2.provider.token.TokenStore;import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;import com.damon.component.JwtTokenEnhancer;import com.damon.login.service.LoginService;@Configuration@EnableAuthorizationServerpublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter &#123; @Autowired private PasswordEncoder passwordEncoder; @Autowired private AuthenticationManager authenticationManager; @Autowired private LoginService loginService; @Autowired &#x2F;&#x2F;@Qualifier(&quot;jwtTokenStore&quot;) @Qualifier(&quot;redisTokenStore&quot;) private TokenStore tokenStore; &#x2F;*@Autowired private JwtAccessTokenConverter jwtAccessTokenConverter; @Autowired private JwtTokenEnhancer jwtTokenEnhancer;*&#x2F; @Autowired private Environment env; @Autowired private DataSource dataSource; @Autowired private WebResponseExceptionTranslator userOAuth2WebResponseExceptionTranslator; &#x2F;** * redis token 方式 *&#x2F; @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123; &#x2F;&#x2F;验证时发生的情况处理 endpoints.authenticationManager(authenticationManager) &#x2F;&#x2F;支持 password 模式 .exceptionTranslator(userOAuth2WebResponseExceptionTranslator)&#x2F;&#x2F;自定义异常处理类添加到认证服务器配置 .userDetailsService(loginService) .tokenStore(tokenStore); &#125; &#x2F;** * 客户端配置（给谁发令牌） * 不同客户端配置不同 * * authorizedGrantTypes 可以包括如下几种设置中的一种或多种： authorization_code：授权码类型。需要redirect_uri implicit：隐式授权类型。需要redirect_uri password：资源所有者（即用户）密码类型。 client_credentials：客户端凭据（客户端ID以及Key）类型。 refresh_token：通过以上授权获得的刷新令牌来获取新的令牌。 accessTokenValiditySeconds：token 的有效期 scopes：用来限制客户端访问的权限，在换取的 token 的时候会带上 scope 参数，只有在 scopes 定义内的，才可以正常换取 token。 * @param clients * @throws Exception * @author Damon * *&#x2F; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.inMemory() .withClient(&quot;provider-service&quot;) .secret(passwordEncoder.encode(&quot;provider-service-123&quot;)) .accessTokenValiditySeconds(3600) .refreshTokenValiditySeconds(864000)&#x2F;&#x2F;配置刷新token的有效期 .autoApprove(true) &#x2F;&#x2F;自动授权配置 .scopes(&quot;all&quot;)&#x2F;&#x2F;配置申请的权限范围 .authorizedGrantTypes(&quot;password&quot;, &quot;authorization_code&quot;, &quot;client_credentials&quot;, &quot;refresh_token&quot;)&#x2F;&#x2F;配置授权模式 .redirectUris(&quot;http:&#x2F;&#x2F;localhost:2001&#x2F;login&quot;)&#x2F;&#x2F;授权码模式开启后必须指定 .and() .withClient(&quot;consumer-service&quot;) .secret(passwordEncoder.encode(&quot;consumer-service-123&quot;)) .accessTokenValiditySeconds(3600) .refreshTokenValiditySeconds(864000)&#x2F;&#x2F;配置刷新token的有效期 .autoApprove(true) &#x2F;&#x2F;自动授权配置 .scopes(&quot;all&quot;)&#x2F;&#x2F;配置申请的权限范围 .authorizedGrantTypes(&quot;password&quot;, &quot;authorization_code&quot;, &quot;client_credentials&quot;, &quot;refresh_token&quot;)&#x2F;&#x2F;配置授权模式 .redirectUris(&quot;http:&#x2F;&#x2F;localhost:2005&#x2F;login&quot;)&#x2F;&#x2F;授权码模式开启后必须指定 .and() .withClient(&quot;resource-service&quot;) .secret(passwordEncoder.encode(&quot;resource-service-123&quot;)) .accessTokenValiditySeconds(3600) .refreshTokenValiditySeconds(864000)&#x2F;&#x2F;配置刷新token的有效期 .autoApprove(true) &#x2F;&#x2F;自动授权配置 .scopes(&quot;all&quot;)&#x2F;&#x2F;配置申请的权限范围 .authorizedGrantTypes(&quot;password&quot;, &quot;authorization_code&quot;, &quot;client_credentials&quot;, &quot;refresh_token&quot;)&#x2F;&#x2F;配置授权模式 .redirectUris(&quot;http:&#x2F;&#x2F;localhost:2006&#x2F;login&quot;)&#x2F;&#x2F;授权码模式开启后必须指定 .and() .withClient(&quot;test-sentinel&quot;) .secret(passwordEncoder.encode(&quot;test-sentinel-123&quot;)) .accessTokenValiditySeconds(3600) .refreshTokenValiditySeconds(864000)&#x2F;&#x2F;配置刷新token的有效期 .autoApprove(true) &#x2F;&#x2F;自动授权配置 .scopes(&quot;all&quot;)&#x2F;&#x2F;配置申请的权限范围 .authorizedGrantTypes(&quot;password&quot;, &quot;authorization_code&quot;, &quot;client_credentials&quot;, &quot;refresh_token&quot;)&#x2F;&#x2F;配置授权模式 .redirectUris(&quot;http:&#x2F;&#x2F;localhost:2008&#x2F;login&quot;)&#x2F;&#x2F;授权码模式开启后必须指定 .and() .withClient(&quot;test-sentinel-feign&quot;) .secret(passwordEncoder.encode(&quot;test-sentinel-feign-123&quot;)) .accessTokenValiditySeconds(3600) .refreshTokenValiditySeconds(864000)&#x2F;&#x2F;配置刷新token的有效期 .autoApprove(true) &#x2F;&#x2F;自动授权配置 .scopes(&quot;all&quot;)&#x2F;&#x2F;配置申请的权限范围 .authorizedGrantTypes(&quot;password&quot;, &quot;authorization_code&quot;, &quot;client_credentials&quot;, &quot;refresh_token&quot;)&#x2F;&#x2F;配置授权模式 .redirectUris(&quot;http:&#x2F;&#x2F;localhost:2010&#x2F;login&quot;)&#x2F;&#x2F;授权码模式开启后必须指定 .and() .withClient(&quot;customer-service&quot;) .secret(passwordEncoder.encode(&quot;customer-service-123&quot;)) .accessTokenValiditySeconds(3600) .refreshTokenValiditySeconds(864000)&#x2F;&#x2F;配置刷新token的有效期 .autoApprove(true) &#x2F;&#x2F;自动授权配置 .scopes(&quot;all&quot;) .authorizedGrantTypes(&quot;password&quot;, &quot;authorization_code&quot;, &quot;client_credentials&quot;, &quot;refresh_token&quot;)&#x2F;&#x2F;配置授权模式 .redirectUris(&quot;http:&#x2F;&#x2F;localhost:2012&#x2F;login&quot;)&#x2F;&#x2F;授权码模式开启后必须指定 ; &#125; @Override public void configure(AuthorizationServerSecurityConfigurer security) &#123; security.allowFormAuthenticationForClients();&#x2F;&#x2F;是允许客户端访问 OAuth2 授权接口，否则请求 token 会返回 401 security.checkTokenAccess(&quot;isAuthenticated()&quot;);&#x2F;&#x2F;是允许已授权用户访问 checkToken 接口 security.tokenKeyAccess(&quot;isAuthenticated()&quot;); &#x2F;&#x2F; security.tokenKeyAccess(&quot;permitAll()&quot;);获取密钥需要身份认证，使用单点登录时必须配置，是允许已授权用户获取 token 接口 &#125;&#125; Redis 配置: 123456789101112131415161718192021package com.damon.config;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.security.oauth2.provider.token.TokenStore;import org.springframework.security.oauth2.provider.token.store.redis.RedisTokenStore;@Configurationpublic class RedisTokenStoreConfig &#123; @Autowired private RedisConnectionFactory redisConnectionFactory; @Bean public TokenStore redisTokenStore ()&#123; &#x2F;&#x2F;return new RedisTokenStore(redisConnectionFactory); return new MyRedisTokenStore(redisConnectionFactory); &#125;&#125; 后面接下来需要配置安全访问的拦截，这时候需要 SpringSecurity: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.damon.config;import javax.servlet.http.HttpServletResponse;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.builders.WebSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125; @Override public void configure(HttpSecurity http) throws Exception &#123; http.csrf() .disable() .exceptionHandling() .authenticationEntryPoint(new AuthenticationEntryPointHandle()) &#x2F;&#x2F;.authenticationEntryPoint((request, response, authException) -&gt; response.sendError(HttpServletResponse.SC_UNAUTHORIZED)) .and() .authorizeRequests() .antMatchers(&quot;&#x2F;oauth&#x2F;**&quot;, &quot;&#x2F;login&#x2F;**&quot;)&#x2F;&#x2F;&quot;&#x2F;logout&#x2F;**&quot; .permitAll() .anyRequest() .authenticated() .and() .formLogin() .permitAll(); &#125; &#x2F;*@Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userDetailsService) .passwordEncoder(passwordEncoder()); &#125;*&#x2F; @Override public void configure(WebSecurity web) throws Exception &#123; web.ignoring().antMatchers(&quot;&#x2F;css&#x2F;**&quot;, &quot;&#x2F;js&#x2F;**&quot;, &quot;&#x2F;plugins&#x2F;**&quot;, &quot;&#x2F;favicon.ico&quot;); &#125;&#125; 再者，就是需要配置资源拦截: 12345678910111213141516171819202122232425262728293031package com.damon.config;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;@Configuration@EnableResourceServerpublic class ResourceServerConfig extends ResourceServerConfigurerAdapter &#123; @Override public void configure(HttpSecurity http) throws Exception &#123; http.csrf().disable() .exceptionHandling() .authenticationEntryPoint(new AuthenticationEntryPointHandle()) &#x2F;&#x2F;.authenticationEntryPoint((request, response, authException) -&gt; response.sendError(HttpServletResponse.SC_UNAUTHORIZED)) .and() .requestMatchers().antMatchers(&quot;&#x2F;api&#x2F;**&quot;) .and() .authorizeRequests() .antMatchers(&quot;&#x2F;api&#x2F;**&quot;).authenticated() .and() .httpBasic(); &#125;&#125; 其中，在上面我们配置了资源拦截、权限拦截的统一处理配置: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.damon.config;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.http.HttpStatus;import org.springframework.security.core.AuthenticationException;import org.springframework.security.web.AuthenticationEntryPoint;import com.alibaba.fastjson.JSON;import com.damon.commons.Response;&#x2F;** * * 统一结果处理 * * @author Damon * *&#x2F;public class AuthenticationEntryPointHandle implements AuthenticationEntryPoint &#123; &#x2F;** * * @author Damon * *&#x2F; @Override public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123; &#x2F;&#x2F;response.setStatus(HttpServletResponse.SC_FORBIDDEN); &#x2F;&#x2F;response.setStatus(HttpStatus.OK.value()); &#x2F;&#x2F;response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); &#x2F;&#x2F;gateway已加，无需再加 &#x2F;&#x2F;response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;token&quot;); &#x2F;&#x2F;解决低危漏洞点击劫持 X-Frame-Options Header未配置 response.setHeader(&quot;X-Frame-Options&quot;, &quot;SAMEORIGIN&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;); response.setContentType(&quot;application&#x2F;json; charset&#x3D;utf-8&quot;); response.getWriter() .write(JSON.toJSONString(Response.ok(response.getStatus(), -2, authException.getMessage(), null))); &#x2F;*response.getWriter() .write(JSON.toJSONString(Response.ok(200, -2, &quot;Internal Server Error&quot;, authException.getMessage())));*&#x2F; &#125;&#125; 最后，自定义异常处理类添加到认证服务器配置: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package com.damon.config;import java.io.IOException;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.security.access.AccessDeniedException;import org.springframework.security.core.AuthenticationException;import org.springframework.security.oauth2.common.DefaultThrowableAnalyzer;import org.springframework.security.oauth2.common.exceptions.InsufficientScopeException;import org.springframework.security.oauth2.common.exceptions.OAuth2Exception;import org.springframework.security.oauth2.provider.error.WebResponseExceptionTranslator;import org.springframework.security.web.util.ThrowableAnalyzer;import org.springframework.stereotype.Component;import org.springframework.web.HttpRequestMethodNotSupportedException;import com.damon.exception.UserOAuth2Exception;&#x2F;** * * 自定义异常转换类 * @author Damon * *&#x2F;@Component(&quot;userOAuth2WebResponseExceptionTranslator&quot;)public class UserOAuth2WebResponseExceptionTranslator implements WebResponseExceptionTranslator &#123; private ThrowableAnalyzer throwableAnalyzer &#x3D; new DefaultThrowableAnalyzer(); @Override public ResponseEntity&lt;OAuth2Exception&gt; translate(Exception e) throws Exception &#123; Throwable[] causeChain &#x3D; this.throwableAnalyzer.determineCauseChain(e); Exception ase &#x3D; (OAuth2Exception)this.throwableAnalyzer.getFirstThrowableOfType(OAuth2Exception.class, causeChain); &#x2F;&#x2F;异常链中有OAuth2Exception异常 if (ase !&#x3D; null) &#123; return this.handleOAuth2Exception((OAuth2Exception)ase); &#125; &#x2F;&#x2F;身份验证相关异常 ase &#x3D; (AuthenticationException)this.throwableAnalyzer.getFirstThrowableOfType(AuthenticationException.class, causeChain); if (ase !&#x3D; null) &#123; return this.handleOAuth2Exception(new UserOAuth2WebResponseExceptionTranslator.UnauthorizedException(e.getMessage(), e)); &#125; &#x2F;&#x2F;异常链中包含拒绝访问异常 ase &#x3D; (AccessDeniedException)this.throwableAnalyzer.getFirstThrowableOfType(AccessDeniedException.class, causeChain); if (ase instanceof AccessDeniedException) &#123; return this.handleOAuth2Exception(new UserOAuth2WebResponseExceptionTranslator.ForbiddenException(ase.getMessage(), ase)); &#125; &#x2F;&#x2F;异常链中包含Http方法请求异常 ase &#x3D; (HttpRequestMethodNotSupportedException)this.throwableAnalyzer.getFirstThrowableOfType(HttpRequestMethodNotSupportedException.class, causeChain); if(ase instanceof HttpRequestMethodNotSupportedException)&#123; return this.handleOAuth2Exception(new UserOAuth2WebResponseExceptionTranslator.MethodNotAllowed(ase.getMessage(), ase)); &#125; return this.handleOAuth2Exception(new UserOAuth2WebResponseExceptionTranslator.ServerErrorException(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase(), e)); &#125; private ResponseEntity&lt;OAuth2Exception&gt; handleOAuth2Exception(OAuth2Exception e) throws IOException &#123; int status &#x3D; e.getHttpErrorCode(); HttpHeaders headers &#x3D; new HttpHeaders(); headers.set(&quot;Cache-Control&quot;, &quot;no-store&quot;); headers.set(&quot;Pragma&quot;, &quot;no-cache&quot;); if (status &#x3D;&#x3D; HttpStatus.UNAUTHORIZED.value() || e instanceof InsufficientScopeException) &#123; headers.set(&quot;WWW-Authenticate&quot;, String.format(&quot;%s %s&quot;, &quot;Bearer&quot;, e.getSummary())); &#125; UserOAuth2Exception exception &#x3D; new UserOAuth2Exception(e.getMessage(),e); ResponseEntity&lt;OAuth2Exception&gt; response &#x3D; new ResponseEntity(exception, headers, HttpStatus.valueOf(status)); return response; &#125; private static class MethodNotAllowed extends OAuth2Exception &#123; public MethodNotAllowed(String msg, Throwable t) &#123; super(msg, t); &#125; @Override public String getOAuth2ErrorCode() &#123; return &quot;method_not_allowed&quot;; &#125; @Override public int getHttpErrorCode() &#123; return 405; &#125; &#125; private static class UnauthorizedException extends OAuth2Exception &#123; public UnauthorizedException(String msg, Throwable t) &#123; super(msg, t); &#125; @Override public String getOAuth2ErrorCode() &#123; return &quot;unauthorized&quot;; &#125; @Override public int getHttpErrorCode() &#123; return 401; &#125; &#125; private static class ServerErrorException extends OAuth2Exception &#123; public ServerErrorException(String msg, Throwable t) &#123; super(msg, t); &#125; @Override public String getOAuth2ErrorCode() &#123; return &quot;server_error&quot;; &#125; @Override public int getHttpErrorCode() &#123; return 500; &#125; &#125; private static class ForbiddenException extends OAuth2Exception &#123; public ForbiddenException(String msg, Throwable t) &#123; super(msg, t); &#125; @Override public String getOAuth2ErrorCode() &#123; return &quot;access_denied&quot;; &#125; @Override public int getHttpErrorCode() &#123; return 403; &#125; &#125;&#125; 最后，我们可能需要配置一些请求客户端的配置，以及变量配置: 123456789101112131415@Configurationpublic class BeansConfig &#123; @Resource private Environment env; @Bean public RestTemplate restTemplate() &#123; SimpleClientHttpRequestFactory requestFactory &#x3D; new SimpleClientHttpRequestFactory(); requestFactory.setReadTimeout(env.getProperty(&quot;client.http.request.readTimeout&quot;, Integer.class, 15000)); requestFactory.setConnectTimeout(env.getProperty(&quot;client.http.request.connectTimeout&quot;, Integer.class, 3000)); RestTemplate rt &#x3D; new RestTemplate(requestFactory); return rt; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.damon.config;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.context.annotation.Configuration;import org.springframework.stereotype.Component;&#x2F;** * 配置信息 * @author Damon * *&#x2F;@Component@RefreshScopepublic class EnvConfig &#123; @Value(&quot;$&#123;jdbc.driverClassName:&#125;&quot;) private String jdbc_driverClassName; @Value(&quot;$&#123;jdbc.url:&#125;&quot;) private String jdbc_url; @Value(&quot;$&#123;jdbc.username:&#125;&quot;) private String jdbc_username; @Value(&quot;$&#123;jdbc.password:&#125;&quot;) private String jdbc_password; public String getJdbc_driverClassName() &#123; return jdbc_driverClassName; &#125; public void setJdbc_driverClassName(String jdbc_driverClassName) &#123; this.jdbc_driverClassName &#x3D; jdbc_driverClassName; &#125; public String getJdbc_url() &#123; return jdbc_url; &#125; public void setJdbc_url(String jdbc_url) &#123; this.jdbc_url &#x3D; jdbc_url; &#125; public String getJdbc_username() &#123; return jdbc_username; &#125; public void setJdbc_username(String jdbc_username) &#123; this.jdbc_username &#x3D; jdbc_username; &#125; public String getJdbc_password() &#123; return jdbc_password; &#125; public void setJdbc_password(String jdbc_password) &#123; this.jdbc_password &#x3D; jdbc_password; &#125;&#125; 最后需要配置一些环境配置: 12345678910111213141516171819202122spring: application: name: oauth-cas cloud: nacos: discovery: server-addr: 127.0.0.1:8848 config: server-addr: 127.0.0.1:8848 refreshable-dataids: actuator.properties,log.properties redis: #redis相关配置 database: 8 host: 127.0.0.1 #localhost port: 6379 password: aaa #有密码时设置 jedis: pool: max-active: 8 max-idle: 8 min-idle: 0 timeout: 10000ms 记住：上面这个启动配置需要在 bootstrap 文件中添加，否则，可能会失败，大家可以尝试下。 1234567891011121314151617181920212223242526272829server: port: 2000 undertow: uri-encoding: UTF-8 accesslog: enabled: false pattern: combined #这里我们使用了SpringBoot2.x，注意session与1.x不同 servlet: session: timeout: PT120M cookie: name: OAUTH-CAS-SESSIONID #防止Cookie冲突，冲突会导致登录验证不通过client: http: request: connectTimeout: 8000 readTimeout: 30000mybatis: mapperLocations: classpath:mapper&#x2F;*.xml typeAliasesPackage: com.damon.*.modelspring: profiles: active: dev 最后，我们添加启动类: 123456789@Configuration@EnableAutoConfiguration@ComponentScan(basePackages &#x3D; &#123;&quot;com.damon&quot;&#125;)@EnableDiscoveryClientpublic class CasApp &#123; public static void main(String[] args) &#123; SpringApplication.run(CasApp.class, args); &#125;&#125; 以上，一个认证中心的代码实战逻辑就完成了。 接下来，我们看一个客户端如何去认证，首先还是依赖: 123456789101112131415161718192021222324&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 在客户端，我们也需要配置一个资源配置与权限配置: 12345678910111213141516171819202122232425262728293031323334package com.damon.config;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;&#x2F;** * * * @author Damon * *&#x2F;@Configuration@EnableResourceServerpublic class ResourceServerConfig extends ResourceServerConfigurerAdapter &#123; @Override public void configure(HttpSecurity http) throws Exception &#123; http.csrf().disable() .exceptionHandling() .authenticationEntryPoint(new AuthenticationEntryPointHandle()) &#x2F;&#x2F;.authenticationEntryPoint((request, response, authException) -&gt; response.sendError(HttpServletResponse.SC_UNAUTHORIZED)) .and() .requestMatchers().antMatchers(&quot;&#x2F;api&#x2F;**&quot;) .and() .authorizeRequests() .antMatchers(&quot;&#x2F;api&#x2F;**&quot;).authenticated() .and() .httpBasic(); &#125;&#125; 当然，权限拦截可能就相对简单了: 123456789101112131415161718package com.damon.config;import org.springframework.context.annotation.Configuration;import org.springframework.core.annotation.Order;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;&#x2F;** * * 在接口上配置权限时使用 * @author Damon * *&#x2F;@Configuration@EnableGlobalMethodSecurity(prePostEnabled &#x3D; true)@Order(101)public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;&#125; 同样，这里也需要一个统一结果处理类，这里就不展示了。 接下来，我们主要看配置: 123456789101112131415161718192021cas-server-url: http:&#x2F;&#x2F;oauth-cas #http:&#x2F;&#x2F;localhost:2000#设置可以访问的地址security: oauth2: #与cas对应的配置 client: client-id: provider-service client-secret: provider-service-123 user-authorization-uri: $&#123;cas-server-url&#125;&#x2F;oauth&#x2F;authorize #是授权码认证方式需要的 access-token-uri: $&#123;cas-server-url&#125;&#x2F;oauth&#x2F;token #是密码模式需要用到的获取 token 的接口 resource: loadBalanced: true #jwt: #jwt存储token时开启 #key-uri: $&#123;cas-server-url&#125;&#x2F;oauth&#x2F;token_key #key-value: test_jwt_sign_key id: provider-service #指定用户信息地址 user-info-uri: $&#123;cas-server-url&#125;&#x2F;api&#x2F;user #指定user info的URI，原生地址后缀为&#x2F;auth&#x2F;user prefer-token-info: false #token-info-uri: authorization: check-token-access: $&#123;cas-server-url&#125;&#x2F;oauth&#x2F;check_token #当此web服务端接收到来自UI客户端的请求后，需要拿着请求中的 token 到认证服务端做 token 验证，就是请求的这个接口 在上面的配置里，我们看到了各种注释了，讲得很仔细，但是我要强调下：为了高可用，我们的认证中心可能多个，所以需要域名来作 LB。同时，开启了 loadBalanced=true。最后，如果是授权码认证模式，则需要 “user-authorization-uri”，如果是密码模式，需要 “access-token-uri” 来获取 token。我们通过它 “user-info-uri” 来获取认证中心的用户信息，从而判断该用户的权限，从而访问相应的资源。另外，上面的配置需要在 bootstrap 文件中，否则可能失败，大家可以试试。 接下来，我们添加一般配置: 12345678910111213141516171819202122232425262728293031323334353637server: port: 2001 undertow: uri-encoding: UTF-8 accesslog: enabled: false pattern: combined servlet: session: timeout: PT120M cookie: name: PROVIDER-SERVICE-SESSIONID #防止Cookie冲突，冲突会导致登录验证不通过backend: ribbon: client: enabled: true ServerListRefreshInterval: 5000ribbon: ConnectTimeout: 3000 # 设置全局默认的ribbon的读超时 ReadTimeout: 1000 eager-load: enabled: true clients: oauth-cas,consumer-service MaxAutoRetries: 1 #对第一次请求的服务的重试次数 MaxAutoRetriesNextServer: 1 #要重试的下一个服务的最大数量（不包括第一个服务） #listOfServers: localhost:5556,localhost:5557 #ServerListRefreshInterval: 2000 OkToRetryOnAllOperations: true NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRulehystrix.command.BackendCall.execution.isolation.thread.timeoutInMilliseconds: 5000hystrix.threadpool.BackendCallThread.coreSize: 5 这里，我们使用了 Ribbon 来做 LB，hystrix 来作熔断，最后需要注意的是：加上了 cookie name，防止 Cookie 冲突，冲突会导致登录验证不通过。 配置启动类: 123456789101112@Configuration@EnableAutoConfiguration@ComponentScan(basePackages &#x3D; &#123;&quot;com.damon&quot;&#125;)@EnableDiscoveryClient@EnableOAuth2Ssopublic class ProviderApp &#123; public static void main(String[] args) &#123; SpringApplication.run(ProviderApp.class, args); &#125;&#125; 我们在上面配置了所有带有 “/api/**“ 的路径请求，都会加以拦截，根据用户的信息来判断其是否有权限访问。 写一个简单的测试类: 12345678910111213141516@RestController@RequestMapping(&quot;&#x2F;api&#x2F;user&quot;)public class UserController &#123; private static final Logger logger &#x3D; LoggerFactory.getLogger(UserController.class); @Autowired private UserService userService; @PreAuthorize(&quot;hasAuthority(&#39;admin&#39;)&quot;) @GetMapping(&quot;&#x2F;auth&#x2F;admin&quot;) public Object adminAuth() &#123; logger.info(&quot;test password mode&quot;); return &quot;Has admin auth!&quot;; &#125;&#125; 上面的代码表示：如果用户具有 “admin” 的权限，则能够访问该接口，否则会被拒绝。 本文用的是 alibaba 的组件来作 LB，具体可以看前面的文章，用域名来找到服务。同时也加上了网关 Gateway。 最后，我们先来通过密码模式来进行认证吧: 1curl -i -X POST -d &quot;username&#x3D;admin&amp;password&#x3D;123456&amp;grant_type&#x3D;password&amp;client_id&#x3D;provider-service&amp;client_secret&#x3D;provider-service-123&quot; http:&#x2F;&#x2F;localhost:5555&#x2F;oauth-cas&#x2F;oauth&#x2F;token 认证成功后，会返回如下结果: 1&#123;&quot;access_token&quot;:&quot;d2066f68-665b-4038-9dbe-5dd1035e75a0&quot;,&quot;token_type&quot;:&quot;bearer&quot;,&quot;refresh_token&quot;:&quot;44009836-731c-4e6a-9cc3-274ce3af8c6b&quot;,&quot;expires_in&quot;:3599,&quot;scope&quot;:&quot;all&quot;&#125; 接下来，我们通过 token 来访问接口: 1curl -i -H &quot;Accept: application&#x2F;json&quot; -H &quot;Authorization:bearer d2066f68-665b-4038-9dbe-5dd1035e75a0&quot; -X GET http:&#x2F;&#x2F;localhost:5555&#x2F;provider-service&#x2F;api&#x2F;user&#x2F;auth&#x2F;admin 成功会返回结果: 1Has admin auth! token 如果失效，会返回: 1&#123;&quot;error&quot;:&quot;invalid_token&quot;,&quot;error_description&quot;:&quot;d2066f68-665b-4038-9dbe-5dd1035e75a01&quot;&#125; 3、GitHub 的授权应用案例 如果你的应用想要接入 GitHub，则可以通过如下办法来实现。 首先注册一个 GitHub 账号，登陆后，找到设置，打开页面，最下面有一个开发者设置： 找到后，点击，可以看到三个，可以选择第二个方式来接入： 可以新增你的应用 app，新建时，应用名、回调地址必填项： 最后，完成后会生成一个 Client ID、Client Secret。 然后利用 Github 官方给的文档来进行认证、接入，授权逻辑： 1.在注册完信息后生成了 Client ID、Client Secret，首先，用户点击 github 登录本地应用引导用户跳转到第三方授权页跳转地址: 1https:&#x2F;&#x2F;github.com&#x2F;login&#x2F;oauth&#x2F;authorize?client_id&#x3D;&#123;client_id&#125;&amp;redirect_uri&#x3D;&#123;redirect_uri&#125;&amp;state&#x3D;&#123;state&#125; 其中，client_id，client_secret 是注册好 Oauth APP 后 github 提供的，需要写在本地代码或者配置文件中，state 也是在本地生成的。redirect_uri 就是在 GitHub 官网填的 Authorization callback URL。此时带着 state 等参数去申请授权，但此时尚未登陆，未能通过 authorize，GitHub 返回 code 参数。 2.授权成功后会重定向带参数访问上面的 redirect_uri，并多了一个 code 参数后台接收 code 这个参数,我们带着这个 code 再次访问 github 地址: 1https:&#x2F;&#x2F;github.com&#x2F;login&#x2F;oauth&#x2F;access_token?client_id&#x3D;xxx&amp;client_secret&#x3D;xxx&amp;code&#x3D;xxx&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;localhost:3001&#x2F;authCallback 注意：上面的 redirect_uri 要与之前在新建 app 时填写的保持一直，否则会报错。 3.通过 state 参数和 code 参数，成功获取 access_token有了 access_token，只需要把 access_token 参数放在 URL 后面即可，就可以换取用户信息了。访问地址: 1https:&#x2F;&#x2F;api.github.com&#x2F;user?access_token&#x3D;xxx 4.得到 GitHub 授权用户的个人信息，就表明授权成功。 4、微服务安全架构设计 在微服务中，安全性是一个很重要的问题。我们经常比较多的场景是：服务 A 需要调用服务 B，但是问题来了，到底是走外网调用呢？还是走局域网调用呢？这当然看 A、B 是否在同一个网段，如果在同一个局域网段，那肯定走局域网好。为什么呢？因为局域网快呀，如果说还有理由吗？当然有：除了网络快，降低网络开销，还可以保证安全性，不至于被黑客黑掉。这是安全的一个保证。 那么除了上面说的安全性，还有其他的吗？比如：在一个局域网下，有 N 个微服务模块，但是这些微服务并不想完全直接暴露给外部，这时候，就需要一个网关 Gateway 来处理。网关把所有的服务给路由了，就像在所有的服务上面一层，加了一个保护光环，突出高内聚的含义。同时还可以加上一些拦截，安全的拦截，鉴权、认证等。存在通过 token 的鉴权，也可以通过 jwt 的，等等。有时候，可以借助 redis 通过 session 共享。也可以通过 OAuth2 的鉴权模式来实现安全拦截。 最后安全性的考虑是在每个服务的接口设计上，比如：幂等的存在，让很多恶意攻击成为无用之功。更多的介绍可以看下面: 1https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s&#x2F;G3yhwvLVTu_T5uPxgZD00w 结束福利 开源实战利用 k8s 作微服务的架构设计代码： https://gitee.com/damon_one/spring-cloud-k8s https://gitee.com/damon_one/spring-cloud-oauth2 欢迎大家 star，多多指教。 关于作者 笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 docker、k8s 做微服务容器化，自动化部署等一站式项目部署、落地。Go 语言学习，k8s 研究，边缘计算框架 KubeEdge 等。公众号 程序猿Damon 发起人。个人微信 MrNull008，欢迎來撩。 欢迎关注：InfoQ 欢迎关注：腾讯自媒体专栏","tags":[]},{"title":"浅谈负载均衡","date":"2020-07-10T05:47:15.000Z","path":"2020/07/10/springcloud-01/","text":"1、 前言 负载均衡，英文：Load Balance，其含义是请求分发到多个粒度单元上进行执行操作，例如各种服务器、应用服务、中台服务、数据服务等，从而达到共同完成某项任务的目的。为了拓宽网络设备和服务器的带宽、增加吞吐量、加强网络请求处理能力、提高网络的灵活性和高可用性，负载均衡是一种廉价、有效、透明的方法，它为服务的高并发做了一次缓冲，让单个服务的压力瞬间减少，实现了服务的高可用，避免服务因为压力而面临宕机的危险。 2、负载均衡 2.1 基于网络的负载均衡大家都知道，OSI 模型有 7 层结构，每层都可以有几个子层。OSI 的 7 层从上到下分别是物理层、数据链路层、网络层、传输层、会话层、表示层、应用层： 在这七层结构中，高层次都是依赖于低层次的。层次越高，使用起来越方便。 根据负载均衡技术实现在 OSI 七层模型的不同层次，是可以给负载均衡分类的。 常见的实现方式中，主要可以在应用层、传输层、网络层和数据传输层做文章。所以，工作在应用层的负载均衡，我们通常称之为七层负载均衡、工作在传输层的我们称之为四层负载均衡。我们一个个来看看： 七层负载均衡 七层负载均衡工作在 OSI 模型的应用层，应用层协议较多，常用 http、dns、ftp 等。七层负载就可以基于这些协议来负载。这些应用层协议中会包含很多有意义的内容。比如同一个 Web 服务器的负载均衡，除了根据 IP 加 port 进行负载外，还可根据 URL 来决定是否要进行负载均衡。 四层负载均衡 四层负载均衡工作在 OSI 模型的传输层，由于在传输层，只有 TCP/UDP 协议，这两种协议中除了包含源 IP、目标 IP 以外，还包含源端口及目的端口。四层负载均衡服务器在接受到客户端请求后，以后通过修改数据包的地址信息（IP+端口号）将流量转发到应用服务器。 2.2 负载均衡工具负载均衡的工具，常见的有 Nginx、k8s、Ribbon、Feign、HAProxy 等。 Nginx Nginx 主要用来作七层负载均衡，反向代理 http、https 的协议链接，同时也提供了 IMAP/POP3/SMTP 的服务。 upstream proxy_demo_aaa { server weight=5; server weight=6;} location ~ ^/demo-aaa/api(.*)$ { proxy_pass http://proxy_demo_aaa/api$1$is_args$args;}k8s k8s 的负载均衡是基于 kube-proxy，其服务发现基于 kube-dns，最后由于每个 Service 对应的 pod 可以是多个，所以可以基于 kube-proxy 实现负载均衡，kube-proxy 进程其实就是一个智能的软件负载均衡器，他负责把 service 的请求转发到后端的某个 pod 实例。 Ribbon Ribbon 是一个为客户端提供负载均衡功能的服务，它内部提供了一个叫做 ILoadBalance 的接口代表负载均衡器的操作，比如有添加服务器、选择服务器、获取所有的服务器列表、获取可用的服务器列表等等。 常见的，使用 RestTemplate 进行服务提供者、服务消费者之间的通信，只需为 RestTemplate 配置类添加@LoadBalanced 注解即可。 @Bean@LoadBalanced public RestTemplate restTemplate() { return new RestTemplate();}Feign Feign 是一个声明式负载均衡客户端使用 Feign 能让编写 WebService 的客户端更加简单，它的使用方法是定义一个接口，然后在上面添加注解，同时也支持 JAX-RS 标准的注解。Feign 也支持可拔插式的编码器和解码器。 @FeignClient(name = “provider-service”, configuration = {Feign4HttpConfiguration.class, FeignLogConfiguration.class}, fallback = CustomerClientImpl.class)public interface CustomerClient { @PostMapping(&quot;/save&quot;) String save(); @GetMapping(&quot;/api/user/getUserInfo&quot;) Response&lt;Object&gt; getUserInfo();}HAProxy HAProxy 是一个使用 C 语言编写的自由、开放源代码软件，其提供高可用性、负载均衡，以及基于 TCP 和 HTTP 的应用程序代理的功能。 2.3 负载均衡算法 常见的几种负载均衡的算法有：随机、轮询、最少链接、Hash、加权、重试等。 随机：即请求随机分配到各台服务器上，这是默认的策略机制。 轮询：将所有请求，依次分发到每台服务器上，适合服务器硬件相同的场景，服务请求数相同。 最少链接：将本次请求分配到请求数最少的服务上，这种可以根据服务器当前的请求处理情况，动态分配。 Hash：根据 IP 地址进行 Hash 计算，得到 IP 地址，这种可以将来自同一 IP 地址的请求，同一会话期内，转发到同一服务器；实现会话粘滞。但目标服务器宕机后，会话也会随之丢失。 加权：在上面几种算法基础上，进行一定的加权比例分配。 重试：这种策略一般都会有，就是在调用失败后，进行二次重试机制。 当然，还有其他的动态的算法规则：最快模式、观察模式、动态性能分配等。 结束福利 开源实战利用 k8s 作微服务的架构设计代码: https://gitee.com/damon_one/spring-cloud-k8s 欢迎大家 star，多多指教。 关于作者 笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 docker、k8s 做微服务容器化，自动化部署等一站式项目部署、落地。Go 语言学习，k8s 研究，边缘计算框架 KubeEdge 等。公众号 程序猿Damon 发起人。个人微信 MrNull008，欢迎來撩。 欢迎关注：InfoQ 欢迎关注：腾讯自媒体专栏 欢迎关注","tags":[]}]