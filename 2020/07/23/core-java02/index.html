<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
  <meta name="sogou_site_verification" content="2PtvzVZiEs"/>
   
  <meta name="keywords" content="java,key, key1, key2, key3" />
   
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title style="color: blue; font-style: oblique">
    程序猿Damon | 微服务 | 容器化 | 自动化
  </title>
  <meta name="generator" content="hexo-theme-ayer">

  
  <link rel="shortcut icon" href="/images/logo/l1.png" />
  

  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  

  <script>
      (function(){
          var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
          document.write('<script src="' + src + '" id="sozz"><\/script>');
      })();
  </script>


  <!--<script data-ad-client="ca-pub-1354758384344627" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->

  

  


  <!--<script async custom-element="amp-auto-ads"
          src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
  </script>-->
<link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>

</html>

<body>

    <!--<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    &lt;!&ndash; Unit one &ndash;&gt;
    <ins class="adsbygoogle"
         style="display:inline-block;width:400px;height:90px"
         data-ad-client="ca-pub-1354758384344627"
         data-ad-slot="8964778819"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>-->

  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-core-java02"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  浅谈 Java 集合 | 底层源码解析
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/07/23/core-java02/" class="article-date">
  <time datetime="2020-07-23T00:41:01.000Z" itemprop="datePublished">2020-07-23</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">5.4k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长约</span>
            <span class="post-count">23 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>在 Java 中，我们经常会使用到一些处理缓存数据的集合类，这些集合类都有自己的特点，今天主要分享下 Java 集合中几种经常用的 Map、List、Set。</p>
<p>目录</p>
<p>1、Map</p>
<p>一、背景</p>
<p>二、Map家族</p>
<p>三、HashMap、Hashtable等</p>
<p>四、HashMap 底层数据结构</p>
<p>2、List</p>
<p>一、List 包括的子类</p>
<p>二、ArrayList</p>
<p>三、ArrayList 源码分析</p>
<p>四、LinkedList</p>
<p>五、LinkedList 源码分析</p>
<p>3、Set</p>
<p>一、Set的实质</p>
<p>二、HashSet</p>
<p>三、TreeSet</p>
<p>01</p>
<p>集合 1：Map</p>
<p>背景</p>
<p>如果一个海量的数据中，需要查询某个指定的信息，这时候，可能会犹如大海捞针，这时候，可以使用 Map 来进行一个获取。因为 Map 是键值对集合。Map这种键值（key-value）映射表的数据结构，作用就是通过key能够高效、快速查找value。</p>
<p>举一个例子：</p>
<p>import java.util.HashMap;<br>import java.util.Map;<br>import java.lang.Object;</p>
<p>public class Test {<br>    public static void main(String[] args) {<br>        Object o = new Object();<br>        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();<br>        map.put(“aaa”, o); //将”aaa”和 Object实例映射并关联<br>        Student target = map.get(“aaa”); //通过key查找并返回映射的Obj实例<br>        System.out.println(target == o); //true，同一个实例<br>        Student another = map.get(“bbb”); //通过另一个key查找<br>        System.out.println(another); //未找到则返回null<br>    }<br>}<br>Map&lt;K, V&gt;是一种键-值映射表，当我们调用put(K key, V value)方法时，就把key和value做了映射并放入Map。当我们调用V get(K key)时，就可以通过key获取到对应的value。如果key不存在，则返回null。和List类似，Map也是一个接口，最常用的实现类是HashMap。</p>
<p>在 Map&lt;K, V&gt; 中，如果遍历的时候，其 key 是无序的，如何理解：</p>
<p>import java.util.HashMap;<br>import java.util.Map;<br>public class Test {<br>    public static void main(String[] args) {<br>        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();<br>        map.put(“dog”, “a”);<br>        map.put(“pig”, “b”);<br>        map.put(“cat”, “c”);<br>        for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {<br>            String key = entry.getKey();<br>            Integer value = entry.getValue();<br>            System.out.println(key + “ = “ + value);<br>        }<br>    }<br>}</p>
<p>//print<br>cat = c<br>dog = a<br>pig = b<br>从上面的打印结果来看，其是无序的，有序的答案可以在下面找到。<br>接下来我们分析下 Map ，首先我们先看看 Map 家族：</p>
<p>它的子孙下面有我们常用的 HashMap、LinkedHashMap，也有 TreeMap，另外还有继承 Dictionary、实现 Map 接口的 Hashtable。</p>
<p>下面针对各个实现类的特点来说明：</p>
<p>（1）HashMap：它根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有高效的访问速度，但遍历顺序却是不确定的。HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap 非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的静态方法 synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap(分段加锁)。</p>
<p>（2）LinkedHashMap：LinkedHashMap 是 HashMap 的一个子类，替 HashMap 完成了输入顺序的记录功能，所以要想实现像输出同输入顺序一致，应该使用 LinkedHashMap。</p>
<p>（3）TreeMap：TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用 TreeMap 时，key 必须实现Comparable 接口或者在构造 TreeMap 传入自定义的 Comparator，否则会在运行时抛出 ClassCastException 类型的异常。</p>
<p>（4）Hashtable：Hashtable继承 Dictionary 类，实现 Map 接口，很多映射的常用功能与 HashMap 类似，Hashtable 采用”拉链法”实现哈希表，不同的是它来自 Dictionary 类，并且是线程安全的，任一时间只有一个线程能写 Hashtable，但并发性不如 ConcurrentHashMap，因为ConcurrentHashMap 引入了分段锁。Hashtable 使用 synchronized 来保证线程安全，在线程竞争激烈的情况下 HashTable 的效率非常低下。不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。Hashtable 并不是像 ConcurrentHashMap 对数组的每个位置加锁，而是对操作加锁，性能较差。 </p>
<p>上面讲到了 HashMap、Hashtable、ConcurrentHashMap，接下来先看看 HashMap 的源码实现：</p>
<p>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;<br>    implements Map&lt;K,V&gt;, Cloneable, Serializable {</p>
<pre><code>private static final long serialVersionUID = 362498820763181265L;
/**
  * 默认大小 16
  */
  static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;

  /**
  * 最大容量是必须是2的幂30
  */
  static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;

  /**
  * 负载因子默认为0.75，hashmap每次扩容为原hashmap的2倍
  */
  static final float DEFAULT_LOAD_FACTOR = 0.75f;

  /**
  * 链表的最大长度为8，当超过8时会将链表装换为红黑树进行存储
  */
  static final int TREEIFY_THRESHOLD = 8;

  /**
   * The table, initialized on first use, and resized as
   * necessary. When allocated, length is always a power of two.
   * (We also tolerate length zero in some operations to allow
   * bootstrapping mechanics that are currently not needed.)
   */
  transient Node&lt;K,V&gt;[] table;

  static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    final int hash;
    final K key;
    V value;
    Node&lt;K,V&gt; next;


    Node(int hash, K key, V value, Node&lt;K,V&gt; next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }


    public final K getKey()        { return key; }
    public final V getValue()      { return value; }
    public final String toString() { return key + &quot;=&quot; + value; }


    public final int hashCode() {
        return Objects.hashCode(key) ^ Objects.hashCode(value);
    }


    public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue;
        return oldValue;
    }


    public final boolean equals(Object o) {
        if (o == this)
            return true;
        if (o instanceof Map.Entry) {
            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
            if (Objects.equals(key, e.getKey()) &amp;&amp;
                Objects.equals(value, e.getValue()))
                return true;
        }
        return false;
    }
}</code></pre><p>从上面看到，HashMap 主要是数组 + 链表结构组成。HashMap 扩容是成倍的扩容。为什么是成倍，而不是1.5或其他的倍数呢？既然 HashMap 在进行 put 的时候针对 key 做了一些列的 hash 以及与运算就是为了减少碰撞的一个概率，如果扩容后的大小不是2的n次幂的话，之前做的不是白费了吗？</p>
<p>else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>                newThr = oldThr &lt;&lt; 1;<br>扩容后会重新把原来的所有的数据 key 的 hash 重新计算放入扩容后的数组里面去。为什么要这样做？因为不同的数组大小通过 key 的 hash 出来的下标是不一样的。还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引 index 更加均匀。</p>
<p>为何说 Hashmap 是非线程安全的呢？原因：当多线程并发时，检测到总数量超过门限值的时候就会同时调用 resize 操作，各自生成新的数组并rehash 后赋给底层数组，结果最终只有最后一个线程生成的新数组被赋给table 变量，其他线程均会丢失。而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的 table 作为原始数组，这样也是有问题滴。</p>
<p>疑问：</p>
<p> HashMap 中某个 entry 链过长，查询时间达到最大限度，如何处理呢？这个在 Jdk1.8，当链表过长，把链表转成红黑树(TreeNode)实现了更高的时间复杂度的查找。</p>
<p>HashMap中哈希算法实现？我们使用put(key,value)方法往HashMap中添加元素时，先计算得到key的 Hash 值，然后通过Key高16位与低16位相异或（高16位不变），然后与数组大小-1相与，得到了该元素在数组中的位置，流程：</p>
<p>延伸：如果一个对象中，重写了equals()而不重写hashcode()会发生什么样的问题？尽管我们在进行 get 和 put 操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode()，所以put操作时，key(hashcode1)–&gt;hash–&gt;indexFor–&gt;index，而通过key取出value的时候 key(hashcode2)–&gt;hash–&gt;indexFor–&gt;index，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null。所以，在重写equals()的时候，必须注意重写hashCode()，同时还要保证通过equals()判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode也可以相同的（只不过会发生哈希冲突，应尽量避免）。（1. hash相同，但key不一定相同：key1、key2产生的hash很有可能是相同的，如果key真的相同，就不会存在散列链表了，散列链表是很多不同的键算出的hash值和index相同的 2. key相同，经过两次hash，其hash值一定相同）</p>
<p>ConcurrentHashMap 采用了分段锁技术来将数据分成一段段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
<p>02</p>
<p>集合 2：List</p>
<p>集合 List 是接口 Collection 的子接口，也是大家经常用到的数据缓存。List 进行了元素排序，且允许存放相同的元素，即有序，可重复。我们先看看有哪些子类：</p>
<p>可以看到，其中包括比较多的子类，我们常用的是 ArrayList、LinkedList:</p>
<p>ArrayList：</p>
<p>优点：操作读取操作效率高，基于数组实现的，可以为null值，可以允许重复元素，有序，异步。</p>
<p>缺点：由于它是由动态数组实现的，不适合频繁的对元素的插入和删除操作，因为每次插入和删除都需要移动数组中的元素。</p>
<p>LinkedList：</p>
<p>优点：LinkedList由双链表实现，增删由于不需要移动底层数组数据，其底层是链表实现的，只需要修改链表节点指针，对元素的插入和删除效率较高。</p>
<p>缺点：遍历效率较低。HashMap和双链表也有关系。</p>
<p>ArrayList 底层是一个变长的数组，基本上等同于Vector，但是ArrayList对writeObjec() 和 readObject()方法实现了同步。</p>
<p>transient Object[] elementData;</p>
<p>/**</p>
<ul>
<li>Constructs an empty list with an initial capacity of ten.</li>
<li>/<br>public ArrayList() {<br>  this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>}<br>If multiple threads access an <tt>ArrayList</tt> instance<br>concurrently, and at least one of the threads modifies<br>the list structurally, it <i>must</i> be synchronized externally.<br>(A structural modification is any operation that adds or deletes one or more elements, or explicitly resizes the backing array; merely setting the value of an element is not a structural modification.)<br>This is typically accomplished by synchronizing<br>on some object that naturally encapsulates the list.<br>从注释，我们知道 ArrayList 是线程不安全的，多线程环境下要通过外部的同步策略后使用，比如List list = Collections.synchronizedList(new ArrayList(…))。</li>
</ul>
<p>源码实现：</p>
<p>private void writeObject(java.io.ObjectOutputStream s)<br>  throws java.io.IOException{<br>  // Write out element count, and any hidden stuff<br>  int expectedModCount = modCount;<br>  s.defaultWriteObject();</p>
<p>  // Write out size as capacity for behavioural compatibility with clone()<br>  s.writeInt(size);</p>
<p>  // Write out all elements in the proper order.<br>  for (int i=0; i&lt;size; i++) {<br>    s.writeObject(elementData[i]);<br>  }</p>
<p>  if (modCount != expectedModCount) {<br>    throw new ConcurrentModificationException();<br>  }<br>}</p>
<p>/**</p>
<ul>
<li><p>Reconstitute the <tt>ArrayList</tt> instance from a stream (that is,</p>
</li>
<li><p>deserialize it).</p>
</li>
<li><p>/<br>private void readObject(java.io.ObjectInputStream s)<br>throws java.io.IOException, ClassNotFoundException {<br>elementData = EMPTY_ELEMENTDATA;</p>
<p>// Read in size, and any hidden stuff<br>s.defaultReadObject();</p>
<p>// Read in capacity<br>s.readInt(); // ignored</p>
<p>if (size &gt; 0) {<br>  // be like clone(), allocate array based upon size not capacity<br>  int capacity = calculateCapacity(elementData, size);<br>  SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);<br>  ensureCapacityInternal(size);</p>
<p>  Object[] a = elementData;<br>  // Read in all elements in the proper order.<br>  for (int i=0; i&lt;size; i++) {</p>
<pre><code>a[i] = s.readObject();</code></pre><p>  }<br>}<br>}<br>当调用add函数时，会调用ensureCapacityInternal函数进行扩容，每次扩容为原来大小的1.5倍，但是当第一次添加元素或者列表中元素个数小于10的话，列表容量默认为10。</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>Default initial capacity.</li>
<li>/<br>private static final int DEFAULT_CAPACITY = 10;</li>
</ul>
<p>/**</p>
<ul>
<li>Shared empty array instance used for empty instances.</li>
<li>/<br>private static final Object[] EMPTY_ELEMENTDATA = {};</li>
</ul>
<p>/**</p>
<ul>
<li>Shared empty array instance used for default sized empty instances.</li>
<li>/<br>private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};</li>
</ul>
<p>/**</p>
<ul>
<li>The array buffer into which the elements of the ArrayList are stored.</li>
<li>/<br>transient Object[] elementData; // non-private to simplify nested class access</li>
</ul>
<p>/**</p>
<ul>
<li>The size of the ArrayList (the number of elements it contains).</li>
<li>/<br>private int size;<br>扩容原理：根据当前数组的大小，判断是否小于默认值10，如果大于，则需要扩容至当前数组大小的1.5倍，重新将新扩容的数组数据copy只当前elementData，最后将传入的元素赋值给size++位置。</li>
</ul>
<p>private void ensureCapacityInternal(int minCapacity) {<br>  ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>}</p>
<p>private void ensureExplicitCapacity(int minCapacity) {<br>  modCount++;</p>
<p>  // overflow-conscious code<br>  if (minCapacity - elementData.length &gt; 0)<br>    grow(minCapacity);<br>}</p>
<p>/**</p>
<ul>
<li>The maximum size of array to allocate.</li>
<li>Some VMs reserve some header words in an array.</li>
<li>Attempts to allocate larger arrays may result in</li>
<li>OutOfMemoryError: Requested array size exceeds VM limit</li>
<li>/<br>private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</li>
</ul>
<p>/**</p>
<ul>
<li>Increases the capacity to ensure that it can hold at least the</li>
<li>number of elements specified by the minimum capacity argument.</li>
<li></li>
<li>@param minCapacity the desired minimum capacity</li>
<li>/<br>private void grow(int minCapacity) {<br>// overflow-conscious code<br>int oldCapacity = elementData.length;<br>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);<br>if (newCapacity - minCapacity &lt; 0)<br>  newCapacity = minCapacity;<br>if (newCapacity - MAX_ARRAY_SIZE &gt; 0)<br>  newCapacity = hugeCapacity(minCapacity);<br>// minCapacity is usually close to size, so this is a win:<br>elementData = Arrays.copyOf(elementData, newCapacity);<br>}</li>
</ul>
<p>private static int hugeCapacity(int minCapacity) {<br>  if (minCapacity &lt; 0) // overflow<br>    throw new OutOfMemoryError();<br>  return (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>    Integer.MAX_VALUE :<br>    MAX_ARRAY_SIZE;<br>}<br>接下来我们分析为什么 ArrayList 增删很慢，查询很快呢？</p>
<p>public boolean add(E e) {<br>  ensureCapacityInternal(size + 1);  // Increments modCount!!<br>  elementData[size++] = e;<br>  return true;<br>}<br>根据源码可知，当调用add函数时，首先要调用ensureCapacityInternal(size + 1)，该函数是进行自动扩容的，效率低的原因也就是在这个扩容上了，每次新增都要对现有的数组进行一次1.5倍的扩大，数组间值的copy等，最后等扩容完毕，有空间位置了，将数组size+1的位置放入元素e，实现新增。</p>
<p>删除时源码：</p>
<p>/**</p>
<ul>
<li><p>Removes the element at the specified position in this list.</p>
</li>
<li><p>Shifts any subsequent elements to the left (subtracts one from their</p>
</li>
<li><p>indices).</p>
</li>
<li></li>
<li><p>@param index the index of the element to be removed</p>
</li>
<li><p>@return the element that was removed from the list</p>
</li>
<li><p>@throws IndexOutOfBoundsException {@inheritDoc}</p>
</li>
<li><p>/<br>public E remove(int index) {<br>rangeCheck(index);</p>
<p>modCount++;<br>E oldValue = elementData(index);</p>
<p>int numMoved = size - index - 1;<br>if (numMoved &gt; 0)<br>  System.arraycopy(elementData, index+1, elementData, index,</p>
<pre><code>numMoved);</code></pre><p>elementData[–size] = null;</p>
<p>return oldValue;<br>}<br>在删除index位置的元素时，要先调用 rangeCheck(index) 进行 index 的check，index 要超过当前个数，则判定越界，抛出异常，throw new IndexOutOfBoundsException(outOfBoundsMsg(index))，其他函数也有用到如：get(int index)，set(int index, E element) 等后面删除重点在于计算删除的index是末尾还是中间位置，末尾直接–，然后置空完事，如果是中间位置，那就要进行一个数组间的copy，重新组合数组数据了，这一就比较耗性能了。</p>
</li>
</ul>
<p>而查询：</p>
<p>/**</p>
<ul>
<li><p>Returns the element at the specified position in this list.</p>
</li>
<li></li>
<li><p>@param  index index of the element to return</p>
</li>
<li><p>@return the element at the specified position in this list</p>
</li>
<li><p>@throws IndexOutOfBoundsException {@inheritDoc}</p>
</li>
<li><p>/<br>public E get(int index) {<br>rangeCheck(index);</p>
<p>return elementData(index);<br>}<br>获取指定index的元素，首先调用rangeCheck(index)进行index的check，通过后直接获取数组的下标index获取数据，没有任何多余操作，高效。</p>
</li>
</ul>
<p>LinkedList 继承AbstractSequentialList和实现List接口，新增接口如下：</p>
<p>addFirst(E e):将指定元素添加到刘表开头</p>
<p>addLast(E e):将指定元素添加到列表末尾</p>
<p>descendingIterator():以逆向顺序返回列表的迭代器</p>
<p>element():获取但不移除列表的第一个元素</p>
<p>getFirst():返回列表的第一个元素</p>
<p>getLast():返回列表的最后一个元素</p>
<p>offerFirst(E e):在列表开头插入指定元素</p>
<p>offerLast(E e):在列表尾部插入指定元素</p>
<p>peekFirst():获取但不移除列表的第一个元素</p>
<p>peekLast():获取但不移除列表的最后一个元素</p>
<p>pollFirst():获取并移除列表的最后一个元素</p>
<p>pollLast():获取并移除列表的最后一个元素</p>
<p>pop():从列表所表示的堆栈弹出一个元素</p>
<p>push(E e);将元素推入列表表示的堆栈</p>
<p>removeFirst():移除并返回列表的第一个元素</p>
<p>removeLast():移除并返回列表的最后一个元素</p>
<p>removeFirstOccurrence(E e):从列表中移除第一次出现的指定元素</p>
<p>removeLastOccurrence(E e):从列表中移除最后一次出现的指定元素<br>LinkedList 的实现原理：LinkedList 的实现是一个双向链表。在 Jdk 1.6中是一个带空头的循环双向链表，而在 Jdk1.7+ 中则变为不带空头的双向链表，这从源码中可以看出：</p>
<p>//jdk 1.6<br>private transient Entry<E> header = new Entry<E>(null, null, null);<br>private transient int size = 0;</p>
<p>//jdk 1.7<br>transient int size = 0;</p>
<p>transient Node<E> first;</p>
<p>transient Node<E> last;<br>从源码注释看，LinkedList不是线程安全的，多线程环境下要通过外部的同步策略后使用，比如List list = Collections.synchronizedList(new LinkedList(…))：</p>
<p> If multiple threads access a linked list concurrently,<br> and at least one of the threads modifies the list structurally,<br>  it <i>must</i> be synchronized externally.<br>  (A structural modification is any operation that adds or<br>  deletes one or more elements; merely setting the value of<br>  an element is not a structural modification.)<br>  This is typically accomplished by synchronizing on some object<br>   that naturally encapsulates the list.<br>为什么说 LinkedList 增删很快呢？</p>
<p>/**</p>
<ul>
<li>Appends the specified element to the end of this list.</li>
<li></li>
<li><p>This method is equivalent to {@link #addLast}.</li>
<li></li>
<li>@param e element to be appended to this list</li>
<li>@return {@code true} (as specified by {@link Collection#add})</li>
<li>/<br>public boolean add(E e) {<br>linkLast(e);<br>return true;<br>}<br>/**</li>
<li>Links e as last element.</li>
<li>/<br>void linkLast(E e) {<br>final Node<E> l = last;<br>final Node<E> newNode = new Node&lt;&gt;(l, e, null);<br>last = newNode;<br>if (l == null)<br>  first = newNode;<br>else<br>  l.next = newNode;<br>size++;<br>modCount++;<br>}<br>从注释看，add函数实则是将元素append至list的末尾，具体过程是：新建一个Node节点，其中将后面的那个节点last作为新节点的前置节点，后节点为null；将这个新Node节点作为整个list的后节点，如果之前的后节点l为null，将新建的Node作为list的前节点，否则，list的后节点指针指向新建Node，最后size+1，当前llist操作数modCount+1。</li>
</ul>
<p>在add一个新元素时，LinkedList 所关心的重要数据，一共两个变量，一个first，一个last，这大大提升了插入时的效率，且默认是追加至末尾，保证了顺序。</p>
<p>再看删除一个元素：</p>
<p>/**</p>
<ul>
<li>Removes the element at the specified position in this list.  Shifts any</li>
<li>subsequent elements to the left (subtracts one from their indices).</li>
<li>Returns the element that was removed from the list.</li>
<li></li>
<li>@param index the index of the element to be removed</li>
<li>@return the element previously at the specified position</li>
<li>@throws IndexOutOfBoundsException {@inheritDoc}</li>
<li>/<br>public E remove(int index) {<br>checkElementIndex(index);<br>return unlink(node(index));<br>}</li>
</ul>
<p>/**</p>
<ul>
<li><p>Unlinks non-null node x.</p>
</li>
<li><p>/<br>E unlink(Node<E> x) {<br>// assert x != null;<br>final E element = x.item;<br>final Node<E> next = x.next;<br>final Node<E> prev = x.prev;</p>
<p>if (prev == null) {<br>  first = next;<br>} else {<br>  prev.next = next;<br>  x.prev = null;<br>}</p>
<p>if (next == null) {<br>  last = prev;<br>} else {<br>  next.prev = prev;<br>  x.next = null;<br>}</p>
<p>x.item = null;<br>size–;<br>modCount++;<br>return element;<br>}<br>删除指定index的元素，删除之前要调用checkElementIndex(index)去check一下index是否存在元素，如果不存在抛出throw new IndexOutOfBoundsException(outOfBoundsMsg(index));越界错误，同样这个check方法也是很多方法用到的，如：get(int index)，set(int index, E element)等。</p>
</li>
</ul>
<p>注释讲，删除的是非空的节点，这里的node节点也是通过node(index)获取的，分别根据当前Node得到链表上的关节要素：element、next、prev，分别对 prev 和 next 进行判断，以便对当前 list 的前后节点进行重新赋值，frist和last，最后将节点的element置为null，个数-1，操作数+1。根据以上分析，remove节点关键的变量，是Node实例本身的局部变量 next、prev、item 重新构建内部变量指针指向，以及list的局部变量first和last保证节点相连。这些变量的操作使得其删除动作也很高效。</p>
<p>而对于查询：</p>
<p>/**</p>
<ul>
<li>Returns the element at the specified position in this list.</li>
<li></li>
<li>@param index index of the element to return</li>
<li>@return the element at the specified position in this list</li>
<li>@throws IndexOutOfBoundsException {@inheritDoc}</li>
<li>/<br>public E get(int index) {<br>checkElementIndex(index);<br>return node(index).item;<br>}<br>获取指定index位置的node，获取之前还是调用checkElementIndex(index)进行检查元素，之后通过node(index)获取元素，上文有提到，node的获取是遍历得到的元素，所以相对性能效率会低一些。</li>
</ul>
<p>03</p>
<p>集合 3：Set</p>
<p>Set 集合在我们日常中，用到的也比较多。用于存储不重复的元素集合，它主要提供下面几种方法：</p>
<p>将元素添加进Set<E>：add(E e)</p>
<p>将元素从Set<E>删除：remove(Object e)</p>
<p>判断是否包含元素：contains(Object e)</p>
<p>这几种方法返回结果都是 boolean值，即返回是否正确或成功。Set 相当于只存储key、不存储value的Map。我们经常用 Set 用于去除重复元素，因为 重复add同一个 key 时，会返回 false。</p>
<p>public HashSet() {<br>    map = new HashMap&lt;&gt;();<br>}</p>
<p>public TreeSet() {<br>    this(new TreeMap&lt;E,Object&gt;());<br>}<br>Set 子孙中主要有：HashSet、SortedSet。HashSet是无序的，因为它实现了Set接口，并没有实现SortedSet接口，而TreeSet 实现了SortedSet接口，从而保证元素是有序的。</p>
<p>HashSet 添加后输出也是无序的：</p>
<p>public class Test {<br>    public static void main(String[] args) {<br>        Set<String> set = new HashSet&lt;&gt;();<br>        set.add(“2”);<br>        set.add(“6”);<br>        set.add(“44”);<br>        set.add(“5”);<br>        for (String s : set) {<br>            System.out.println(s);<br>        }<br>    }<br>}</p>
<p>//print<br>44<br>2<br>5<br>6<br>看到输出的顺序既不是添加的顺序，也不是String排序的顺序，在不同版本的JDK中，这个顺序也可能是不同的。</p>
<p>换成TreeSet：</p>
<p>public static void main(String[] args) {<br>  Set<String> set = new TreeSet&lt;&gt;();<br>      set.add(“2”);<br>      set.add(“6”);<br>      set.add(“44”);<br>      set.add(“5”);<br>      for (String s : set) {<br>          System.out.println(s);<br>      }<br> }<br>//print<br>2<br>44<br>5<br>6</p>
<p>在遍历TreeSet时，输出就是有序的，不是添加时的顺序，而是元素的排序顺序。</p>
<p>注意：添加的元素必须实现Comparable接口，如果没有实现Comparable接口，那么创建TreeSet时必须传入一个Comparator对象。</p>
<br data-tool="mdnice编辑器">

<h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码：</p>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #282c34; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #282c34; border-radius: 5px;">https://gitee.com/damon_one/spring-cloud-k8s
https://gitee.com/damon_one/spring-cloud-oauth2
</code></pre>

<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p>
<br data-tool="mdnice编辑器">

<h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 docker、k8s 做微服务容器化，自动化部署等一站式项目部署、落地。Go 语言学习，k8s 研究，边缘计算框架 KubeEdge 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">程序猿Damon</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://www.damon8.cn" style="text-decoration: none" title="">程序猿Damon | 微服务 | 容器化 | 自动化</a>，欢迎來撩。</em></p>
<br data-tool="mdnice编辑器">



<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p>

<br>

<p><img src="https://imgkr2.cn-bj.ufileos.com/c841221b-4862-40a2-9713-b000ee91bce3.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=3mkNYl543gx2ngq9gXFQjVBjKm8%253D&Expires=1597915188" alt="公号：天山六路折梅手"></p>
 
      <!-- reward -->
      
      <div id="reward-btn">
        打赏
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://www.damon8.cn/2020/07/23/core-java02/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2020/07/23/micro-service02/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            微服务架构设计之解耦合
          
        </div>
      </a>
    
    
      <a href="/2020/07/23/mysql-norm/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">大佬整理的mysql规范，分享给大家</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "",
    app_key: "",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020
        <i class="ri-heart-fill heart_icon"></i> Damon
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered By <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Title - Nothing
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
        <li>
          <a href="http://www.beian.miit.gov.cn/" target="_black"></a>
        </li>
        
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1279099062&amp;web_id=1279099062'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href=""><img src="/images/logo/logo1.png" alt="程序猿Damon"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/doc">文档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/os">开源</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/zsxq">星球</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/links">友情链接</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat1.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->

<style type="text/css">
    #so360{white-space:nowrap}
    #so360_keyword{width:222
    #so360 form{margin:0;padding:0}px center;}
    #so360_submit{width:60outline:0;vertical-align:middle;padding-right: 95px;}
    #so360_keyword{background:url(https://p.ssl.qhimg.com/t01ab1a3fb05f0ee893.png)
    no-repeat 242
</style>

<div id="so360">
    <form action="http://www.so.com/s" target="_blank" id="so360form">
        <input type="text" autocomplete="off" name="q" id="so360_keyword">
        <input type="submit" id="so360_submit" value="搜 索">
        <input type="hidden" name="ie" value="utf8">
        <input type="hidden" name="src" value="zz_damon8.cn">
        <input type="hidden" name="site" value="damon8.cn">
        <input type="hidden" name="rg" value="0">
    </form>
</div>



<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: '程序猿Damon'
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->

<!-- CanvasBackground -->


<script src="/js/dz.js"></script>



    
  </div>
</body>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:inline-block;width:700px;height:90px; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-1354758384344627"
     data-ad-slot="1051270406"></ins>
<script>
    (adsbygoogle = window.adsbygoogle || []).push({});
</script>

</html>